/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: alr_dc_csc_srv_0010_m()

-- drop function alr_dc_csc_srv_0010_m();

create or replace function alr_dc_csc_srv_0010_m(out rtn refcursor)
  returns refcursor as
$BODY$
declare
   v_alm_id integer;
   v_fecha date;
   v_offset_inicio integer;
   v_offset_alarma1 integer;
   v_offset_alarma2 integer;
   v_offset_finalizado integer;
   v_offset_vencido integer;
begin
   rtn := 'rtn';

   v_alm_id := 2;

   v_offset_inicio := 1000000;

   v_offset_alarma1 := 2000000;

   v_offset_alarma2 := 3000000;

   v_offset_finalizado := 4000000;

   v_offset_vencido := 5000000;

   v_fecha := dateadd('N', -5, now());

   open rtn for
      -- //////////////////////////////////////////////////////////////////////////////////////
      --
      -- Inicio
      --
      -- //////////////////////////////////////////////////////////////////////////////////////
      select v_offset_inicio + tar.tar_id almr_id_mail,
                 M.mail_id,
                 null maili_id,
                 mail_emailTo almr_emailto,
                 mail_emailCc almr_emailcc,
                 'Aviso de Inicio de tarea ' || tar_nombre almr_subject,
                 tar_nombre || CHR(13) || tar_descrip msg
        from Tarea tar
               join AlarmaItem ali
                on tar.ali_id = ali.ali_id
               join Mail M
                on ali.mail_id_inicio = M.mail_id
         where os_id is not null
                 and tar_fechahoraini >= v_fecha
                 and not exists ( select *
                                  from AlarmaMailResult
                                     where alm_id = v_alm_id
                                             and almr_id_mail = v_offset_inicio + tar_id )
      -- //////////////////////////////////////////////////////////////////////////////////////
      --
      -- Alarma 1
      --
      -- //////////////////////////////////////////////////////////////////////////////////////
      union all
      select v_offset_alarma1 + tar.tar_id almr_id_mail,
                 M.mail_id,
                 null maili_id,
                 mail_emailTo almr_emailto,
                 mail_emailCc almr_emailcc,
                 'Aviso de Inicio de tarea ' || tar_nombre almr_subject,
                 tar_nombre || CHR(13) || tar_descrip msg
        from Tarea tar
               join AlarmaItem ali
                on tar.ali_id = ali.ali_id
               join Mail M
                on ali.mail_id_alarma1 = M.mail_id
         where os_id is not null
                 and tar_estado1 >= v_fecha
                 and not exists ( select *
                                  from AlarmaMailResult
                                     where alm_id = v_alm_id
                                             and almr_id_mail = v_offset_alarma1 + tar_id )
      -- //////////////////////////////////////////////////////////////////////////////////////
      --
      -- Alarma 2
      --
      -- //////////////////////////////////////////////////////////////////////////////////////
      union all
      select v_offset_alarma2 + tar.tar_id almr_id_mail,
                 M.mail_id,
                 null maili_id,
                 mail_emailTo almr_emailto,
                 mail_emailCc almr_emailcc,
                 'Aviso de Inicio de tarea ' || tar_nombre almr_subject,
                 tar_nombre || CHR(13) || tar_descrip msg
        from Tarea tar
               join AlarmaItem ali
                on tar.ali_id = ali.ali_id
               join Mail M
                on ali.mail_id_alarma2 = M.mail_id
         where os_id is not null
                 and tar_estado2 >= v_fecha
                 and not exists ( select *
                                  from AlarmaMailResult
                                     where alm_id = v_alm_id
                                             and almr_id_mail = v_offset_alarma2 + tar_id )
      -- //////////////////////////////////////////////////////////////////////////////////////
      --
      -- Finalizado
      --
      -- //////////////////////////////////////////////////////////////////////////////////////
      union all
      select v_offset_finalizado + tar.tar_id almr_id_mail,
                 M.mail_id,
                 null maili_id,
                 mail_emailTo almr_emailto,
                 mail_emailCc almr_emailcc,
                 'Aviso de Inicio de tarea ' || tar_nombre almr_subject,
                 tar_nombre || CHR(13) || tar_descrip msg
        from Tarea tar
               join AlarmaItem ali
                on tar.ali_id = ali.ali_id
               join Mail M
                on ali.mail_id_finalizado = M.mail_id
         where os_id is not null
                 and tar_fechahorafin >= v_fecha
                 and not exists ( select *
                                  from AlarmaMailResult
                                     where alm_id = v_alm_id
                                             and almr_id_mail = v_offset_finalizado + tar_id )
      -- //////////////////////////////////////////////////////////////////////////////////////
      --
      -- Vencido
      --
      -- //////////////////////////////////////////////////////////////////////////////////////
      union all
      select v_offset_vencido + tar.tar_id almr_id_mail,
             M.mail_id,
             null maili_id,
             mail_emailTo almr_emailto,
             mail_emailCc almr_emailcc,
             'Aviso de Inicio de tarea ' || tar_nombre almr_subject,
             tar_nombre || CHR(13) || tar_descrip msg
        from Tarea tar
               join AlarmaItem ali
                on tar.ali_id = ali.ali_id
               join Mail M
                on ali.mail_id_vencido = M.mail_id
         where os_id is not null
                 and tar_fechahorafin >= v_fecha
                 and tar_finalizada = 0
                 and not exists ( select *
                                  from AlarmaMailResult
                                     where alm_id = v_alm_id
                                             and almr_id_mail = v_offset_vencido + tar_id );

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function alr_dc_csc_srv_0010_m()
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: alr_dc_csc_srv_0010_r(integer, integer, integer)

create or replace function alr_dc_csc_srv_0010_r(p_almr_id_mail integer, p_mail_id integer, p_maili_id integer)
  returns void as
$BODY$
declare
   v_alm_id integer;
begin

   v_alm_id := 2;

   insert into AlarmaMailResult
     ( alm_id, almr_id_mail )
     values ( v_alm_id, p_almr_id_mail );

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function alr_dc_csc_srv_0010_r(integer, integer, integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: alr_dc_csc_stk_0010_m()

-- drop function alr_dc_csc_stk_0010_m();

create or replace function alr_dc_csc_stk_0010_m(out rtn refcursor)
  returns refcursor as
$BODY$
declare
   v_alm_id integer;
   v_ultimo_aviso date;
   v_offset_inicio integer;
   v_offset_inicio_e integer;
   --////////////////////////////////////////////////////////////////////////////////
   v_cfg_valor varchar(255);
   v_bStockFisico decimal(3,0);
   v_pr_id integer;
   v_reposicion decimal(18,6);
   v_depl_id integer;
   v_depf_id integer;
   v_almr_id_mail integer;
   v_depf_id_logico integer;
   v_stock decimal(18,6);
   v_cantidad_pedida decimal(18,6);
   v_body varchar;
   v_msg varchar(1000);
   -- Obtengo la direccion de email
   --
   v_mail_emailTo varchar(1000);
   v_mail_emailCc varchar(1000);
   v_mail_id integer;
   v_temp numeric(1, 0) := 0;
   
   --////////////////////////////////////////////////////////////////////////////////
   /*
		Por cada articulo con punto de reposicion > 0 voy a ver cuanto stock tiene
		y si esta por debajo del minimo lo agrego al mail de notificacion
*/
   c_productos CURSOR for
   select pr_id,
	   pr_reposicion,
	   null::integer depl_id,
	   null::integer depf_id
     from Producto
      where pr_reposicion > 0
   union
   select pr_id,
	   prdepl_reposicion,
	   depl_id,
	   null::integer depf_id
     from ProductoDepositoLogico
      where prdepl_reposicion > 0
   union
   select pr_id,
	   prdepf_reposicion,
	   null::integer depl_id,
	   depf_id
     from ProductoDepositoFisico
      where prdepf_reposicion > 0;
      
   -- Creo un cursor con todos los articulos que estan por debajo del punto de reposicion
   --
   c_items CURSOR for
   select
	      'El producto ' || pr.pr_nombrecompra || ' en ' || 
	      case
		  when depl.depl_nombre is not null then 'el deposito logico ' || depl.depl_nombre
		  when depf.depf_nombre is not null then 'el deposito fisico ' || depf.depf_nombre
	      else 'la empesa'
	      end
	      || ' posee un stock de ' 
	      || to_char(stock, '999999999D9999') || ' y el punto de resposicion es ' 
	      || to_char(reposicion, '999999999D9999') 
	      || ' y existen pedidos pendientes por ' 
	      || to_char(pedidos, '999999999D99') 
	      || ' (' || coalesce(un.un_codigo, '') || ').' msg
     from tt_t_alr_dc_csc_stk_0010_st t
     join Producto pr
      on t.pr_id = pr.pr_id
     left join DepositoLogico depl
      on t.depl_id = depl.depl_id
     left join DepositoFisico depf
      on t.depf_id = depf.depf_id
     left join Unidad un
      on pr.un_id_stock = un.un_id
      where not exists ( select *
                         from AlarmaMailResult a
                                join AlarmaMailStock almst
                                 on almst.almst_fecha > v_ultimo_aviso
                                and a.alm_id = v_alm_id
                                and a.almr_id_mail = almst.almr_id_mail
                         where t.pr_id = almst.pr_id
                                and coalesce(t.depl_id, 0) = coalesce(almst.depl_id, 0)
                                and coalesce(t.depf_id, 0) = coalesce(almst.depf_id, 0));
begin

   rtn := 'rtn';

   create temporary table tt_t_alr_dc_csc_stk_0010_st
    (
    almr_id_mail integer  not null,
    pr_id integer  not null,
    depl_id integer,
    depf_id integer,
    reposicion decimal(18,2) default (0) not null,
    stock decimal(18,2) default (0) not null,
    pedidos decimal(18,2) default (0) not null
    ) on commit drop;

   v_alm_id := 3;

   v_ultimo_aviso := dateadd('D', -1, CURRENT_TIMESTAMP);

   v_offset_inicio := 10000000;

   v_offset_inicio_e := 11000000;

   -- Tengo que validar segun lo que indique la configuracion de stock
   select sp_cfg_getValor('Stock-General', 'Tipo Control Stock') into v_cfg_valor;

   v_cfg_valor := coalesce(v_cfg_valor, '0');

   if to_number(v_cfg_valor) = 4 then
      v_bStockFisico := 1;

   else
      v_bStockFisico := 0;

   end if;

   open c_productos;

   fetch c_productos into v_pr_id,v_reposicion,v_depl_id,v_depf_id;

   while (found)
   loop
      begin
         v_cantidad_pedida := 0;

         v_stock := 0;

         if coalesce(v_depl_id, 0) <> 0 then
         begin
            -- Obtengo el stock para este producto y deposito
            if v_bStockFisico <> 0 then
            begin
               select depf_id
                 into v_depf_id_logico
                 from DepositoLogico
                  where depl_id = v_depl_id;

               select SUM(stc_cantidad)
                 into v_stock
                 from StockCache S
                  where pr_id = v_pr_id
                          and exists ( select *
                                       from DepositoLogico
                                          where depf_id = v_depf_id_logico
                                                  and depl_id = S.depl_id );

            end;
            else
            begin
               select SUM(stc_cantidad)
                 into v_stock
                 from StockCache S
                  where pr_id = v_pr_id
                          and depl_id = v_depl_id;

            end;
            end if;

         end;
         else
         begin
            if coalesce(v_depf_id, 0) <> 0 then
            begin
               select SUM(stc_cantidad)
                 into v_stock
                 from StockCache S
                  where pr_id = v_pr_id
                          and exists ( select *
                                       from DepositoLogico
                                          where depf_id = v_depf_id
                                                  and depl_id = S.depl_id );

            end;
            else
            begin
               select SUM(stc_cantidad)
                 into v_stock
                 from StockCache S
                  where pr_id = v_pr_id;

            end;
            end if;

         end;
         end if;

         select SUM(pvi_pendiente)
           into v_cantidad_pedida
           from PedidoVentaItemStock
            where pr_id = v_pr_id;

         v_cantidad_pedida := coalesce(v_cantidad_pedida, 0);

         -- Si es menor al punto de reposicion lo agrego a la tabla
         if v_stock < v_reposicion then
         begin
            if v_almr_id_mail is null then
            begin
               select SP_DBGetNewId2('AlarmaMailStock',
                                     'almr_id_mail',
                                     v_offset_inicio,
                                     v_offset_inicio_e) into v_almr_id_mail;

            end;
            end if;

            insert into tt_t_alr_dc_csc_stk_0010_st
              ( almr_id_mail, pr_id, depl_id, depf_id, stock, reposicion, pedidos )
              values ( v_almr_id_mail, v_pr_id, v_depl_id, v_depf_id, v_stock, v_reposicion, v_cantidad_pedida );

         end;
         end if;

         fetch c_productos into v_pr_id,v_reposicion,v_depl_id,v_depf_id;

      end;
   end loop;

   close c_productos;

   v_body := '';

   open c_items;

   fetch c_items into v_msg;

   while (found)
   loop
      begin
         v_body := v_body || v_msg || CHR(10) || CHR(13);

         fetch c_items into v_msg;

      end;
   end loop;

   close c_items;

   -- Registro que ya notifique estos productos
   --
   insert into alarmamailstock
     ( almr_id_mail, almst_fecha, pr_id, depl_id, depf_id )
     ( select almr_id_mail,
              CURRENT_TIMESTAMP,
              pr_id,
              depl_id,
              depf_id
       from tt_t_alr_dc_csc_stk_0010_st  );

   select alm_mails
     into v_mail_emailTo
     from AlarmaMail
      where alm_id = v_alm_id;

   begin
      select 1 into v_temp
        from DUAL
       where exists ( select *
                      from Mail
                         where mail_codigo = v_mail_emailTo );
   exception
      when others then
         null;
   end;

   if v_temp = 1 then
   begin
      select mail_emailTo,
             mail_emailCc,
             mail_id
        into v_mail_emailTo,
             v_mail_emailCc,
             v_mail_id
        from Mail
         where mail_codigo = v_mail_emailTo;

   end;
   end if;

   open rtn for
      -- Devuelvo el email
      --
      select v_almr_id_mail almr_id_mail,
                  v_mail_id mail_id,
                  null maili_id,
                  v_mail_emailTo mail_emailTo,
                  v_mail_emailCc mail_emailCc,
                  'Articulos con stock por debajo del punto de reposición' almr_subject,
                  v_body msg
      where v_almr_id_mail is not null;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function alr_dc_csc_stk_0010_m()
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: alr_dc_csc_stk_0010_r(integer, integer, integer)

-- drop function alr_dc_csc_stk_0010_r(integer, integer, integer);

create or replace function alr_dc_csc_stk_0010_r(p_almr_id_mail integer, p_mail_id integer, p_maili_id integer)
  returns void as
$BODY$
declare
   v_alm_id integer;
begin

   v_alm_id := 3;

   insert into AlarmaMailResult
     ( alm_id, almr_id_mail )
     values ( v_alm_id, p_almr_id_mail );

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function alr_dc_csc_stk_0010_r(integer, integer, integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: alr_dc_csc_ven_0010_m()

-- drop function alr_dc_csc_ven_0010_m();

create or replace function alr_dc_csc_ven_0010_m(out rtn refcursor)
  returns refcursor as
$BODY$
declare
   v_alm_id integer;
   v_fecha date;
   -- Obtengo la direccion de email
   --
   v_mail_emailTo varchar(1000);
   v_mail_emailCc varchar(1000);
   v_mail_id integer;
   v_temp numeric(1, 0) := 0;
begin

   rtn := 'rtn';

   v_alm_id := 1;

   v_fecha := dateadd('D', -30, CURRENT_TIMESTAMP);

   select alm_mails
     into v_mail_emailTo
     from AlarmaMail
      where alm_id = v_alm_id;

   begin
      select 1 into v_temp
        from DUAL
       where exists ( select *
                      from Mail
                         where mail_codigo = v_mail_emailTo );
   exception
      when others then
         null;
   end;

   if v_temp = 1 then
   begin
      select mail_emailTo,
             mail_emailCc,
             mail_id
        into v_mail_emailTo,
             v_mail_emailCc,
             v_mail_id
        from Mail
         where mail_codigo = v_mail_emailTo;

   end;
   end if;

   open rtn for
      -- Facturas Vencidas por mas de 30 dias
      --
      select fvd.fvd_id almr_id_mail,
                  v_mail_id mail_id,
                  null maili_id,
                  v_mail_emailTo mail_emailTo,
                  v_mail_emailCc mail_emailCc,
                  'Facturas Vencidas por mas de 30 dias' almr_subject,
                  'La factura ' || fv.fv_nrodoc || ' del cliente ' || cli.cli_nombre 
                  || ' de fecha ' || to_char(fv.fv_fecha, 'dd/mm/yyyy') 
                  || ' y vencimiento el ' || to_char(fvd.fvd_fecha, 'dd/mm/yyyy') 
                  || ' ya posee ' 
                  || to_char(date_part('day', CURRENT_TIMESTAMP - fvd.fvd_fecha), '99')
                  || ' dias de vencida' msg
        from (FacturaVentaDeuda fvd
               join FacturaVenta fv
                on fvd.fv_id = fv.fv_id
               and fvd.fvd_fecha < v_fecha
              )
               join Cliente cli
                on fv.cli_id = cli.cli_id
         where not exists ( select *
                            from AlarmaMailResult
                               where alm_id = v_alm_id
                                       and almr_id_mail = fvd.fvd_id );

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function alr_dc_csc_ven_0010_m()
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: alr_dc_csc_ven_0010_r(integer)

-- drop function alr_dc_csc_ven_0010_r(integer);

create or replace function alr_dc_csc_ven_0010_r(p_almr_id_mail integer)
  returns void as
$BODY$
declare
   v_alm_id integer;
begin

   v_alm_id := 1;

   insert into AlarmaMailResult
     ( alm_id, almr_id_mail )
     values ( v_alm_id, p_almr_id_mail );

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function alr_dc_csc_ven_0010_r(integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: alr_dc_csc_ven_0020_m()

-- drop function alr_dc_csc_ven_0020_m();

create or replace function alr_dc_csc_ven_0020_m(out rtn refcursor)
  returns refcursor as
$BODY$
declare
   v_alm_id integer;
   v_fecha date;
   -- Obtengo la direccion de email
   --
   v_mail_emailTo varchar(1000);
   v_mail_emailCc varchar(1000);
   v_mail_id integer;
   v_temp numeric(1, 0) := 0;
begin

   rtn := 'rtn';

   v_alm_id := 4;

   v_fecha := dateadd('D', -30, CURRENT_TIMESTAMP);

   select alm_mails
     into v_mail_emailTo
     from AlarmaMail
      where alm_id = v_alm_id;

   begin
      select 1 into v_temp
        from DUAL
       where exists ( select *
                      from Mail
                         where mail_codigo = v_mail_emailTo );
   exception
      when others then
         null;
   end;

   if v_temp = 1 then
   begin
      select mail_emailTo,
             mail_emailCc,
             mail_id
        into v_mail_emailTo,
             v_mail_emailCc,
             v_mail_id
        from Mail
         where mail_codigo = v_mail_emailTo;

   end;
   end if;

   open rtn for
      -- Facturas Vencidas por mas de 30 dias
      --
      select fvd.fvd_id almr_id_mail,
                  v_mail_id mail_id,
                  null maili_id,
                  v_mail_emailTo mail_emailTo,
                  v_mail_emailCc mail_emailCc,
                  'Facturas Vencidas por mas de 30 dias' almr_subject,
                  'La factura ' || fv.fv_nrodoc || ' del cliente ' || cli.cli_nombre 
                  || ' de fecha ' || to_char(fv.fv_fecha, 'dd/mm/yyyy') 
                  || ' y vencimiento el ' || to_char(fvd.fvd_fecha, 'dd/mm/yyyy') 
                  || ' ya posee ' 
                  || to_char(date_part('day', CURRENT_TIMESTAMP - fvd.fvd_fecha), '99') 
                  || ' dias de vencida' msg
        from ( FacturaVentaDeuda fvd
               join FacturaVenta fv
                on fvd.fv_id = fv.fv_id
               and fvd.fvd_fecha < v_fecha
                )
               join Cliente cli
                on fv.cli_id = cli.cli_id
         where not exists ( select *
                            from AlarmaMailResult
                               where alm_id = v_alm_id
                                       and almr_id_mail = fvd.fvd_id );

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function alr_dc_csc_ven_0020_m()
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_auditoria_credito_check_doc_fc()

-- drop function sp_auditoria_credito_check_doc_fc(integer);

create or replace function sp_auditoria_credito_check_doc_fc
(
  in p_fc_id integer,
  out p_success integer,
  out p_error_msg varchar
)
  returns record as
$BODY$
declare
   v_error smallint;

   v_fc_nrodoc varchar(50);
   v_fc_numero varchar(50);
   v_fc_pendiente decimal(18,6);
   v_fc_total decimal(18,6);

   v_doct_id integer;
   v_doct_facturaCpra integer := 2;
   v_emp_id integer;
   v_est_id integer;
   v_prov_id integer;

   v_aplicado decimal(18,6);
   v_pendiente decimal(18,6);
   v_cache decimal(18,6);
begin

   v_error := 0;
   p_success := 0;
   p_error_msg := '@@ERROR_SP:';

   select fc.doct_id,
          fc.fc_nrodoc,
          trim(to_char(fc.fc_numero)),
          fc.est_id,
          fc.fc_pendiente,
          fc.fc_total,
          fc.prov_id,
          doc.emp_id
     into v_doct_id,
          v_fc_nrodoc,
          v_fc_numero,
          v_est_id,
          v_fc_pendiente,
          v_fc_total,
          v_prov_id,
          v_emp_id
   from FacturaCompra fc
   join Documento doc
     on fc.doc_id = doc.doc_id
   where fc.fc_id = p_fc_id;

   if exists ( select prov_id
               from ProveedorCacheCredito
               where prov_id <> v_prov_id
                 and doct_id = v_doct_facturaCpra
                 and id = p_fc_id ) then

      v_error := 1;
      p_error_msg := p_error_msg || 'Esta factura esta afectando el cache de credito de otro Proveedor' || CHR(10);

   end if;

   select sum(fcd_pendiente)
     into v_pendiente
   from FacturaCompraDeuda
   where fc_id = p_fc_id;

   v_pendiente := coalesce(v_pendiente, 0);

   if v_doct_id = 8 /* nota de credito */ then
      v_pendiente := -v_pendiente;
   end if;

   if v_pendiente <> 0 then

      if not exists ( select id
                      from ProveedorCacheCredito
                      where prov_id = v_prov_id
                        and doct_id = v_doct_facturaCpra
                        and id = p_fc_id ) then

         v_error := 1;
         p_error_msg := p_error_msg
                        || 'Esta factura tiene pendiente y no hay registro en el cache de credito'
                        || CHR(10);

      else

         select sum(provcc_importe)
           into v_cache
         from ProveedorCacheCredito
         where prov_id = v_prov_id
           and doct_id = v_doct_facturaCpra
           and id = p_fc_id
           and emp_id = v_emp_id;

         v_cache := coalesce(v_cache, 0);

         if abs(v_pendiente - v_cache) >= 0.01 then

            v_error := 1;
            p_error_msg := p_error_msg
                           || 'Esta factura tiene un pendiente distinto al que figura en el cache de credito'
                           || CHR(10);

         end if;

      end if;

   else

      if exists ( select id
                  from ProveedorCacheCredito
                  where prov_id = v_prov_id
                    and doct_id = v_doct_facturaCpra
                    and id = p_fc_id ) then

         v_error := 1;
         p_error_msg := p_error_msg
                        || 'Esta factura no tiene pendiente y tiene registro en el cache de credito'
                        || CHR(10);

      end if;

   end if;

   -- no hubo errores asi que todo bien
   --
   if v_error = 0 then
      p_success := 1;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_auditoria_credito_check_doc_fc(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_auditoria_estado_check_doc_fc()

-- drop function sp_auditoria_estado_check_doc_fc(integer);

create or replace function sp_auditoria_estado_check_doc_fc
(
  in p_fc_id integer,
  out p_success integer,
  out p_error_msg varchar
)
  returns record as
$BODY$
declare
   v_error smallint;
   v_doct_id integer;
   v_fc_nrodoc varchar(50);
   v_fc_numero varchar(50);
   v_fc_pendiente decimal(18,6);
   v_est_id integer;
begin

   v_error := 0;
   p_success := 0;
   p_error_msg := '@@ERROR_SP:';

   select doct_id,
          fc_nrodoc,
          trim(to_char(fc_numero)),
          est_id
     into v_doct_id,
          v_fc_nrodoc,
          v_fc_numero,
          v_est_id
   from FacturaCompra
   where fc_id = p_fc_id;

   if exists ( select *
               from FacturaCompraItem fci
               where (fci.fci_pendiente
                      + (coalesce(( select sum(rcfc_cantidad)
                                    from RemitoFacturaCompra
                                    where fci_id = fci.fci_id ), 0))
                      + (coalesce(( select sum(ocfc_cantidad)
                                    from OrdenFacturaCompra
                                    where fci_id = fci.fci_id ), 0))
                     ) <> fci.fci_cantidadaremitir
                 and fci.fc_id = p_fc_id ) then

      v_error := 1;
      p_error_msg := p_error_msg
                     || 'El pendiente de los items de esta factura no coincide con la suma de sus aplicaciones'
                     || CHR(10);

   end if;

   if v_est_id <> 7 and v_est_id <> 5 and v_est_id <> 4 then

      select fc_pendiente
        into v_fc_pendiente
      from FacturaCompra
      where fc_id = p_fc_id;

      if v_fc_pendiente = 0 then

         v_error := 1;
         p_error_msg := p_error_msg
                        || 'La factura no tiene vencimientos pendientes y su estado no es finalizado, o anulado, o pendiente de firma'
                        || CHR(10);

      end if;

   end if;

   -- no hubo errores asi que todo bien
   --
   if v_error = 0 then
      p_success := 1;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_auditoria_estado_check_doc_fc(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_auditoria_estado_check_doc_oc()

-- drop function sp_auditoria_estado_check_doc_oc(integer);

create or replace function sp_auditoria_estado_check_doc_oc
(
  in p_oc_id integer,
  out p_success integer,
  out p_error_msg varchar
)
  returns record as
$BODY$
declare
   v_error smallint;
   v_doct_id integer;
   v_oc_nrodoc varchar(50);
   v_oc_numero varchar(50);
   v_oc_pendiente decimal(18,6);
   v_est_id integer;
begin

   v_error := 0;
   p_success := 0;
   p_error_msg := '@@ERROR_SP:';

   select doct_id,
          oc_nrodoc,
          trim(to_char(oc_numero)),
          est_id
     into v_doct_id,
          v_oc_nrodoc,
          v_oc_numero,
          v_est_id
   from OrdenCompra
   where oc_id = p_oc_id;

   if exists ( select *
               from OrdenCompraItem oci
               where (oci.oci_pendientefac
                      + (coalesce(( select sum(ocfc_cantidad)
                                    from OrdenFacturaCompra
                                    where oci_id = oci.oci_id ), 0)
                       + coalesce(( select sum(ocdc_cantidad)
                                    from OrdenDevolucionCompra
                                    where ( oci_id_Orden = oci.oci_id and v_doct_id = 35 )
                                       or ( oci_id_devolucion = oci.oci_id and v_doct_id = 36 ) ), 0)
                       + coalesce(( select sum(ocrc_cantidad)
                                    from OrdenRemitoCompra
                                    where oci_id = oci.oci_id ), 0)
                        )
                     ) <> oci.oci_cantidadaremitir
                 and oci.oc_id = p_oc_id ) then

      v_error := 1;
      p_error_msg := p_error_msg
                     || 'El pendiente de los items de esta orden de compra no coincide con la suma de sus aplicaciones'
                     || CHR(10);

   end if;


   if exists ( select *
               from OrdenCompraItem oci
               where (oci_pendiente
                      + (coalesce(( select sum(pcoc_cantidad)
                                    from PedidoOrdenCompra
                                    where oci_id = oci.oci_id ), 0))
                     ) <> oci_cantidadaremitir
                 and oc_id = p_oc_id ) then

      v_error := 1;
      p_error_msg := p_error_msg
                     || 'El pendiente de los items de esta orden de compra no coincide con la suma de sus aplicaciones'
                     || CHR(10);

   end if;

   if v_est_id <> 7 and v_est_id <> 5 and v_est_id <> 4 then

      select sum(oci_pendientefac)
        into v_oc_pendiente
      from OrdenCompraItem
      where oc_id = p_oc_id;

      if v_oc_pendiente = 0 then

         v_error := 1;
         p_error_msg := p_error_msg
                        || 'La orden de compra no tiene items pendientes y su estado no es finalizado, o anulado, o pendiente de firma'
                        || CHR(10);
      end if;

   end if;

   -- no hubo errores asi que todo bien
   --
   if v_error = 0 then
      p_success := 1;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_auditoria_estado_check_doc_oc(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_auditoria_estado_check_doc_opg()

-- drop function sp_auditoria_estado_check_doc_opg(integer);

create or replace function sp_auditoria_estado_check_doc_opg
(
  in p_opg_id integer,
  out p_success integer,
  out p_error_msg varchar
)
  returns record as
$BODY$
declare
   v_error smallint;
   v_doct_id integer;
   v_opg_nrodoc varchar(50);
   v_opg_numero varchar(50);
   v_est_id integer;
   v_opg_pendiente decimal(18,6);
   v_opg_total decimal(18,6);
   v_aplicado decimal(18,6);
begin

   v_error := 0;
   p_success := 0;
   p_error_msg := '@@ERROR_SP:';

   select doct_id,
          opg_nrodoc,
          trim(to_char(opg_numero)),
          est_id,
          opg_pendiente,
          opg_total
     into v_doct_id,
          v_opg_nrodoc,
          v_opg_numero,
          v_est_id,
          v_opg_pendiente,
          v_opg_total
   from OrdenPago
   where opg_id = p_opg_id;

   select (coalesce(( select sum(fcopg_importe)
                      from FacturaCompraOrdenPago
                      where opg_id = p_opg_id ), 0))
   into v_aplicado;

   if abs(round(v_opg_total, 2) - round(v_opg_pendiente + v_aplicado, 2)) > 0.01 then

      v_error := 1;
      p_error_msg := p_error_msg
                     || 'El pendiente de la orden de pago no coincide con la suma de sus aplicaciones'
                     || CHR(10);

   end if;

   if v_est_id <> 7 and v_est_id <> 5 and v_est_id <> 4 then

      if round(v_opg_pendiente, 2) = 0 then

         v_error := 1;
         p_error_msg := p_error_msg
                        || 'La orden de pago no tiene pendiente y su estado no es finalizado, o anulado, o pendiente de firma'
                        || CHR(10);

      end if;

   end if;

   if exists ( select 1
               from OrdenPagoItem
               where cue_id in ( select cue_id from RetencionTipo )
                 and ret_id is null
                 and opg_id = p_opg_id
                 and opgi_tipo = 4 ) then

      v_error := 1;
      p_error_msg := p_error_msg
                     || 'Debe indicar la retencion para los items de tipo otro de cuentas de retenciones'
                     || CHR(10);

   end if;

   -- no hubo errores asi que todo bien
   --
   if v_error = 0 then
      p_success := 1;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_auditoria_estado_check_doc_oc(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_auditoria_estado_check_doc_rc()

-- drop function sp_auditoria_estado_check_doc_rc(integer);

create or replace function sp_auditoria_estado_check_doc_rc
(
  in p_rc_id integer,
  out p_success integer,
  out p_error_msg varchar
)
  returns record as
$BODY$
declare
   v_error smallint;
   v_doct_id integer;
   v_rc_nrodoc varchar(50);
   v_rc_numero varchar(50);
   v_rc_pendiente decimal(18,6);
   v_est_id integer;
begin

   v_error := 0;
   p_success := 0;
   p_error_msg := '@@ERROR_SP:';

   select doct_id,
          rc_nrodoc,
          trim(to_char(rc_numero)),
          est_id
     into v_doct_id,
          v_rc_nrodoc,
          v_rc_numero,
          v_est_id
   from RemitoCompra
   where rc_id = p_rc_id;

   if exists ( select *
               from RemitoCompraItem rci
               where (rci.rci_pendientefac
                      + (coalesce(( select sum(rcfc_cantidad)
                                    from RemitoFacturaCompra
                                    where rci_id = rci.rci_id ), 0)
                       + coalesce(( select sum(rcdc_cantidad)
                                    from RemitoDevolucionCompra
                                    where ( rci_id_remito = rci.rci_id and v_doct_id = 4 )
                                       or ( rci_id_devolucion = rci.rci_id and v_doct_id = 25 ) ), 0)
                        )
                     ) <> rci.rci_cantidadaremitir
                 and rci.rc_id = p_rc_id ) then

      v_error := 1;
      p_error_msg := p_error_msg
                     || 'El pendiente de los items de este remito no coincide con la suma de sus aplicaciones'
                     || CHR(10);

   end if;

   if exists ( select *
               from RemitoCompraItem rci
               where (rci_pendiente
                      + (coalesce(( select sum(ocrc_cantidad)
                                    from OrdenRemitoCompra
                                    where rci_id = rci.rci_id ), 0))
                     ) <> rci_cantidad
                 and rc_id = p_rc_id ) then

      v_error := 1;
      p_error_msg := p_error_msg
                     || 'El pendiente de los items de este remito no coincide con la suma de sus aplicaciones'
                     || CHR(10);

   end if;

   if v_est_id <> 7 and v_est_id <> 5 and v_est_id <> 4 then

      select sum(rci_pendientefac)
        into v_rc_pendiente
      from RemitoCompraItem
      where rc_id = p_rc_id;

      if v_rc_pendiente = 0 then

         v_error := 1;
         p_error_msg := p_error_msg
                        || 'El remito no tiene items pendientes y su estado no es finalizado, o anulado, o pendiente de firma'
                        || CHR(10);

      end if;

   end if;

   -- no hubo errores asi que todo bien
   --
   if v_error = 0 then
      p_success := 1;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_auditoria_estado_check_doc_rc(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_auditoria_totales_check_doc_opg()

-- drop function sp_auditoria_totales_check_doc_opg(integer);

create or replace function sp_auditoria_totales_check_doc_opg
(
  in p_opg_id integer,
  out p_success integer,
  out p_error_msg varchar
)
  returns record as
$BODY$
declare
   v_error smallint;
   v_doct_id integer;
   v_opg_nrodoc varchar(50);
   v_opg_numero varchar(50);
   v_opg_total decimal(18,6);
   v_opg_otros decimal(18,6);
   v_importe decimal(18,6);
begin

   v_error := 0;
   p_success := 0;
   p_error_msg := '@@ERROR_SP:';

   select doct_id,
          opg_nrodoc,
          trim(to_char(opg_numero)),
          opg_total,
          opg_otros
     into v_doct_id,
          v_opg_nrodoc,
          v_opg_numero,
          v_opg_total,
          v_opg_otros
   from OrdenPago
   where opg_id = p_opg_id;

   select sum(case opgi_otrotipo
                 when 1 then -opgi_importe
                 else opgi_importe
              end)
     into v_importe
   from OrdenPagoItem
   where opg_id = p_opg_id
     and opgi_tipo <> 5 -- cuenta corriente
   group by opg_id;

   v_importe := coalesce(v_importe, 0);

   if abs(round(v_importe, 2) - round(v_opg_total, 2)) > 0.01 then

      v_error := 1;
      p_error_msg := p_error_msg
                     || 'El total de esta orden de pago no coincide con la suma de los totales de sus items'
                     || CHR(10);

   end if;

   v_importe := 0;

   select sum(case opgi_otrotipo
                 when 1 then -opgi_importe
                 else opgi_importe
              end)
     into v_importe
   from OrdenPagoItem
   where opg_id = p_opg_id and opgi_tipo = 4 -- otros
   group by opg_id;

   v_importe := coalesce(v_importe, 0);

   if abs(round(v_importe, 2) - round(v_opg_otros, 2)) > 0.01 then

      v_error := 1;
      p_error_msg := p_error_msg
                     || 'El total de otros de esta orden de pago no coincide con la suma de los totales de sus items de tipo otros'
                     || CHR(10) || 'Dif: ' || (round(v_importe, 2) - round(v_opg_otros, 2))::varchar
                     || CHR(10) || 'Total: ' || (round(v_opg_otros, 2))::varchar
                     || CHR(10) || 'Deuda: ' || (round(v_importe, 2))::varchar
                     || CHR(10);

   end if;

   if not exists ( select opg_id
                   from OrdenPagoItem
                   where opg_id = p_opg_id ) then

      v_error := 1;
      p_error_msg := p_error_msg
                     || 'Esta orden de pago no contiene items. Todas las ordens de pago deben tener almenos dos items uno de cuenta corriente y otro de un medio de pago.'
                     || CHR(10);

   end if;

   -- no hubo errores asi que todo bien
   --
   if v_error = 0 then
      p_success := 1;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_auditoria_totales_check_doc_opg(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_auditoria_vto_check_doc_fc()

-- drop function sp_auditoria_vto_check_doc_fc(integer);

create or replace function sp_auditoria_vto_check_doc_fc
(
  in p_fc_id integer,
  out p_success integer,
  out p_error_msg varchar
)
  returns record as
$BODY$
declare
   v_error smallint;

   v_fc_nrodoc varchar(50);
   v_fc_numero varchar(50);

   v_fc_pendiente decimal(18,6);
   v_fc_descuento1 decimal(18,6);
   v_fc_descuento2 decimal(18,6);
   v_fc_totalotros decimal(18,6);
   v_fc_totalpercepciones decimal(18,6);
   v_fc_totaldeuda decimal(18,6);

   v_doct_id integer;
   v_est_id integer;

   v_vto decimal(18,6);
   v_deuda decimal(18,6);
   v_pagos decimal(18,6);
   v_total decimal(18,6);
begin

   v_error := 0;
   p_success := 0;
   p_error_msg := '@@ERROR_SP:';

   select doct_id,
          fc_nrodoc,
          trim(to_char(fc_numero)),
          est_id
     into v_doct_id,
          v_fc_nrodoc,
          v_fc_numero,
          v_est_id
   from FacturaCompra
   where fc_id = p_fc_id;

   -- 1 si esta anulado no tiene que tener deuda ni pendiente en items
   --
   if v_est_id = 7 then

      if exists ( select *
                  from FacturaCompraDeuda
                  where fc_id = p_fc_id ) then

         v_error := 1;
         p_error_msg := p_error_msg || 'La factura esta anulada y posee deuda' || CHR(10);

      end if;

      if exists ( select *
                  from FacturaCompraPago
                  where fc_id = p_fc_id ) then

         v_error := 1;
         p_error_msg := p_error_msg || 'La factura esta anulada y posee pagos' || CHR(10);

      end if;

      if exists ( select *
                  from FacturaCompraItem
                  where fc_id = p_fc_id
                    and fci_pendiente <> 0 ) then

         v_error := 1;
         p_error_msg := p_error_msg || 'La factura esta anulada y posee pendiente en sus items' || CHR(10);

      end if;

   else

      select sum(fcd_importe)
        into v_deuda
      from FacturaCompraDeuda
      where fc_id = p_fc_id;

      select sum(fcp_importe)
        into v_pagos
      from FacturaCompraPago
      where fc_id = p_fc_id;

      select fc_descuento1,
             fc_descuento2,
             fc_totalotros,
             fc_totalpercepciones,
             fc_pendiente
        into v_fc_descuento1,
             v_fc_descuento2,
             v_fc_totalotros,
             v_fc_totalpercepciones,
             v_fc_pendiente
      from FacturaCompra
      where fc_id = p_fc_id;

      select sum(fci.fci_importe)
        into v_fc_totaldeuda
      from FacturaCompraItem fci
      join TipoOperacion t
        on fci.to_id = t.to_id
      where fci.fc_id = p_fc_id
        and t.to_generadeuda <> 0;

      v_fc_totaldeuda := v_fc_totaldeuda - ((v_fc_totaldeuda * v_fc_descuento1) / 100);
      v_fc_totaldeuda := v_fc_totaldeuda - ((v_fc_totaldeuda * v_fc_descuento2) / 100);
      v_fc_totaldeuda := v_fc_totaldeuda + v_fc_totalotros + v_fc_totalpercepciones;
      v_total := coalesce(v_fc_totaldeuda, 0);
      v_vto := coalesce(v_deuda, 0) + coalesce(v_pagos, 0);

      if abs(round(v_vto - v_total, 2)) > 0.10 then

         v_error := 1;
         p_error_msg := p_error_msg
                        || 'El total de la factura no coincide con el total de su deuda' || CHR(10)
                        || 'Dif: ' || (round(v_vto - v_total, 2))::varchar || CHR(10)
                        || 'Total: ' || (round(v_total, 2))::varchar || CHR(10)
                        || 'Deuda: ' || (round(v_vto, 2))::varchar || CHR(10);

      end if;

      select sum(fcd_pendiente)
        into v_deuda
      from FacturaCompraDeuda
      where fc_id = p_fc_id;

      if abs(round(v_fc_pendiente - coalesce(v_deuda, 0), 2)) > 0.10 then

         v_error := 1;
         p_error_msg := p_error_msg || 'El pendiente de la factura no coincide con el total de su deuda' || CHR(10);

      end if;

      if exists ( select *
                  from FacturaCompraDeuda fcd
                  where abs(
                            round((fcd.fcd_pendiente
                                   + (coalesce(( select sum(fcopg_importe)
                                                 from FacturaCompraOrdenPago
                                                 where fcd_id = fcd.fcd_id ), 0)
                                   + coalesce(( select sum(fcnc_importe)
                                                from FacturaCompraNotaCredito
                                                where ( fcd_id_factura = fcd.fcd_id and v_doct_id in ( 2,10 ) )
                                                  or ( fcd_id_notacredito = fcd.fcd_id and v_doct_id = 8 ) ), 0)
                                     )
                                  ) - fcd.fcd_importe, 2)) > 0.10
                    and fc_id = p_fc_id ) then

         v_error := 1;
         p_error_msg := p_error_msg
                        || 'El importe de la deuda de esta factura no coincide con la suma de sus aplicaciones'
                        || CHR(10);

      end if;

      if exists ( select *
                  from FacturaCompraPago fcp
                  where abs(
                            round(fcp.fcp_importe
                                  - (coalesce(( select sum(fcopg_importe)
                                                from FacturaCompraOrdenPago
                                                where fcp_id = fcp.fcp_id ), 0)
                                  + coalesce(( select sum(fcnc_importe)
                                               from FacturaCompraNotaCredito
                                               where ( fcp_id_factura = fcp.fcp_id and v_doct_id in ( 2,10 ) )
                                                  or ( fcp_id_notacredito = fcp.fcp_id
                                                 and v_doct_id = 8 ) ), 0)), 2)
                           ) > 0.10
                    and fc_id = p_fc_id ) then

         v_error := 1;
         p_error_msg := p_error_msg
                        || 'El importe del pago de esta factura no coincide con la suma de sus aplicaciones'
                        || CHR(10);

      end if;

   end if;

   -- no hubo errores asi que todo bien
   --
   if v_error = 0 then
      p_success := 1;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_auditoria_vto_check_doc_fc(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_fac_cpra_validate_deposito()

-- drop function sp_doc_fac_cpra_validate_deposito(integer);

/*
          select * from facturacompratmp;
          select * from sp_doc_fac_cpra_validate_deposito(45);
*/

create or replace function sp_doc_fac_cpra_validate_deposito
(
  in p_fcTMP_id integer,
  out p_success integer,
  out p_error_msg varchar
)
  returns record as
$BODY$
declare
    v_error integer;
    v_llevaStock integer;

    v_depl_nombre varchar(255);
    v_pr_nombrecompra varchar(2000);
    v_productos varchar(8000);
begin

   v_error := 0;
   p_success := 0;
   p_error_msg := '@@ERROR_SP:';

   select doc.doc_muevestock
     into v_llevaStock
   from Documento doc
   join FacturaCompraTMP fc
     on doc.doc_id = fc.doc_id
   where fc.fcTMP_id = p_fcTMP_id;

   if v_llevaStock <> 0 then

      if exists ( select 1
                  from FacturaCompraItemTMP fci
                  join FacturaCompraTMP fc
                    on fci.fcTMP_id = fc.fcTMP_id
                  join Documento doc
                    on fc.doc_id = doc.doc_id
                  where fc.fcTMP_id = p_fcTMP_id
                    and not exists ( select *
                                     from ProductoDepositoEntrega
                                     where pr_id = fci.pr_id
                                       and depl_id = fc.depl_id
                                       and suc_id = fc.suc_id
                                       and emp_id = doc.emp_id
                                       and ( prov_id is null or prov_id = fc.prov_id ) )
                    and exists ( select *
                                 from ProductoDepositoEntrega
                                 where pr_id = fci.pr_id
                                   and depl_id <> fc.depl_id
                                   and suc_id = fc.suc_id
                                   and emp_id = doc.emp_id
                                   and ( prov_id is null or prov_id = fc.prov_id ) ) ) then
         select depl.depl_nombre
           into v_depl_nombre
         from FacturaCompraTMP fc
         join DepositoLogico depl
           on fc.depl_id = depl.depl_id
         where fc.fcTMP_id = p_fcTMP_id;

         v_productos := '';

         for v_pr_nombrecompra in
            select pr.pr_nombrecompra
            from FacturaCompraItemTMP fci
            join FacturaCompraTMP fc
             on fci.fcTMP_id = fc.fcTMP_id
            join Producto pr
             on fci.pr_id = pr.pr_id
            join Documento doc
             on fc.doc_id = doc.doc_id
            where fc.fcTMP_id = p_fcTMP_id
              and not exists ( select *
                               from ProductoDepositoEntrega
                               where pr_id = fci.pr_id
                                 and depl_id = fc.depl_id
                                 and suc_id = fc.suc_id
                                 and emp_id = doc.emp_id
                                 and ( prov_id is null or prov_id = fc.prov_id ) )
              and exists ( select *
                           from ProductoDepositoEntrega
                           where pr_id = fci.pr_id
                             and depl_id <> fc.depl_id
                             and suc_id = fc.suc_id
                             and emp_id = doc.emp_id
                             and ( prov_id is null or prov_id = fc.prov_id ) )
         loop
            v_productos := v_productos || v_pr_nombrecompra || CHR(10);
         end loop;

         v_error := 1;

         p_error_msg := p_error_msg || 'Esta factura indica articulos que no estan habilitados para ingresar en el deposito:' || CHR(10) || CHR(10) || v_depl_nombre || CHR(10) || CHR(10) || 'Los articulos son:' || CHR(10) || CHR(10) || v_productos;

      end if;

   end if;

   -- no hubo errores asi que todo bien
   --
   if v_error = 0 then
      p_success := 1;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_fac_cpra_validate_deposito(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_compra_asiento_save_interno()

-- drop function sp_doc_factura_compra_asiento_save_interno(integer, integer, integer, integer, integer, decimal, decimal, integer);

create or replace function sp_doc_factura_compra_asiento_save_interno
(
  in p_fc_id integer,
  in p_as_id integer,
  in p_mon_id integer,
  in p_doct_id_factura integer,
  in p_ccos_id integer,
  in p_desc1 decimal(18, 6),
  in p_desc2 decimal(18, 6),
  in p_doc_esresumenbco integer
)
  returns void as
$BODY$
declare
   v_iva decimal(18,6);
   v_fci_importe decimal(18,6);
   v_fci_importeorigen decimal(18,6);
   v_cue_id integer;
   v_asi_debe decimal(18,6);
   v_asi_haber decimal(18,6);
   v_asi_origen decimal(18,6);
   v_fci_neto decimal(18,6);
   v_asi_orden smallint;
   v_asi_id integer;
   v_is_new integer;

   c_items refcursor;
begin

   select max(asi_orden)
     into v_asi_orden
   from AsientoItem
   where as_id = p_as_id;

   -- los resumenes bancarios no agrupan los renlgones por cuenta
   -- para ayudar a la conciliacion bancaria
   --
   if p_doc_esresumenbco <> 0 then

      open c_items for
         select fci.fci_internos,
                fci.fci_importe,
                fci.fci_importeorigen,
                ti.cue_id
         from FacturaCompraItem fci
         join Producto p
           on fci.pr_id = p.pr_id
         join TasaImpositiva ti
            on p.ti_id_internosc = ti.ti_id
         where fci.fc_id = p_fc_id;

   else

      open c_items for
         select sum(fci.fci_internos),
                sum(fci.fci_importe),
                sum(fci.fci_importeorigen),
                ti.cue_id
         from FacturaCompraItem fci
         join Producto p
           on fci.pr_id = p.pr_id
         join TasaImpositiva ti
           on p.ti_id_internosc = ti.ti_id
         where fci.fc_id = p_fc_id
         group by ti.cue_id
         having sum(fci.fci_internos) <> 0;

   end if;

   loop
      fetch c_items into v_iva,v_fci_importe,v_fci_importeorigen,v_cue_id;
      exit when not found;

      v_asi_id := null;

      if p_doct_id_factura = 2 /* Factura */ or p_doct_id_factura = 10 /* Nota de Debito */ then

         v_asi_debe := v_iva;
         v_asi_debe := v_asi_debe - (v_asi_debe * p_desc1 / 100);
         v_asi_debe := v_asi_debe - (v_asi_debe * p_desc2 / 100);
         v_asi_haber := 0;

         select asi_id
           into v_asi_id
         from AsientoItem
         where as_id = p_as_id
           and cue_id = v_cue_id
           and asi_haber = 0
           and coalesce(ccos_id, 0) = coalesce(p_ccos_id, 0);

      else

         if p_doct_id_factura = 8 /* Nota de Credito */ then

            v_asi_debe := 0;
            v_asi_haber := v_iva;
            v_asi_haber := v_asi_haber - (v_asi_haber * p_desc1 / 100);
            v_asi_haber := v_asi_haber - (v_asi_haber * p_desc2 / 100);

            select asi_id
              into v_asi_id
            from AsientoItem
            where as_id = p_as_id
              and cue_id = v_cue_id
              and asi_debe = 0
              and coalesce(ccos_id, 0) = coalesce(p_ccos_id, 0);

         end if;

      end if;

      if v_fci_importeorigen <> 0 then

         v_fci_importeorigen := v_fci_importeorigen - (v_fci_importeorigen * p_desc1 / 100);
         v_fci_importeorigen := v_fci_importeorigen - (v_fci_importeorigen * p_desc2 / 100);
         v_asi_origen := v_iva / (v_fci_importe / v_fci_importeorigen);

      else

         v_asi_origen := 0;

      end if;

      v_asi_id := coalesce(v_asi_id, 0);

      -- en los resumenes bancarios no juntamos los importes por cuenta
      -- para facilitar la conciliacion con el banco
      --
      if p_doc_esresumenbco <> 0 then
         v_asi_id := 0;
      end if;

      if v_asi_id = 0 then

         select sp_dbGetNewId('AsientoItem', 'asi_id') into v_asi_id;

         v_asi_orden := v_asi_orden + 1;

         insert into AsientoItem( as_id, asi_id, asi_orden, asi_descrip, asi_debe, asi_haber, asi_origen, cue_id,
                                  ccos_id, mon_id )
         values ( p_as_id, v_asi_id, v_asi_orden, '', v_asi_debe, v_asi_haber, v_asi_origen, v_cue_id, p_ccos_id, p_mon_id );

      else

         update AsientoItem
            set asi_debe = asi_debe + v_asi_debe,
                asi_haber = asi_haber + v_asi_haber,
                asi_origen = asi_origen + v_asi_origen
         where asi_id = v_asi_id;

      end if;

   end loop;

   close c_items;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_compra_asiento_save_interno(integer, integer, integer, integer, integer, decimal, decimal, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_compra_editable_get()

-- drop function sp_doc_factura_compra_editable_get(integer, integer, integer, integer, integer);

create or replace function sp_doc_factura_compra_editable_get
/*
          select * from sp_doc_factura_compra_editable_get(1,7,1)
*/
(
  in p_emp_id integer,
  in p_fc_id integer,
  in p_us_id integer,
  in p_no_anulado integer default 0,
  in p_delete integer default 0,
  out p_editable integer,
  out p_edit_msg varchar  
)
  returns record as
$BODY$
declare
   v_doc_id integer;
   v_fc_fecha date;
   v_estado integer;
   v_firmado integer;
   v_emp_id integer;
   v_emp_nombre varchar(255);
   v_impreso numeric(3,0);

   v_anulado integer := 7;
   v_csPreCpraEditFactura integer := 17003;
   v_csPreCpraDeleteFactura integer := 17004;

   v_pre_id integer;
   v_doc_nombre varchar(255);
   v_fca_id integer;

   v_fca_fechaDesde date;
   v_fca_fechaHasta date;

   v_doc_editarimpresos smallint;
begin

   if p_fc_id <> 0 then

      select d.doc_id,
             d.emp_id,
             c.fc_fecha,
             c.est_id,
             c.impreso
        into v_doc_id,
             v_emp_id,
             v_fc_fecha,
             v_estado,
             v_impreso
      from FacturaCompra c
               join Documento d
                on c.doc_id = d.doc_id
      where c.fc_id = p_fc_id;

      if p_emp_id <> v_emp_id then

         select emp_nombre
           into v_emp_nombre
         from Empresa
         where emp_id = v_emp_id;

         p_editable := 0;

         if p_delete = 0 then
            p_edit_msg := 'El comprobante pertenece a la empresa ' || v_emp_nombre || ', para editarlo debe ingresar al sistema indicando dicha empresa.';
         else
            p_edit_msg := 'El comprobante pertenece a la empresa ' || v_emp_nombre || ', para borrarlo debe ingresar al sistema indicando dicha empresa.';
         end if;

         return;

      end if;

      if v_estado = v_anulado and p_no_anulado = 0 then

         p_editable := 0;
         p_edit_msg := 'El comprobante esta anulado';

         return;

      end if;

      if p_delete = 0 then
         v_pre_id := v_csPreCpraEditFactura;
      else
         v_pre_id := v_csPreCpraDeleteFactura;
      end if;

      -- Tiene permiso para editar facturas de compra
      --
      if not exists ( select per_id
                      from Permiso
                      where pre_id = v_pre_id
                        and ( ( us_id = p_us_id )
                             or exists ( select us_id
                                         from UsuarioRol
                                         where us_id = p_us_id
                                           and rol_id = Permiso.rol_id ))) then

         p_editable := 0;

         if p_delete = 0 then
            p_edit_msg := 'Usted no tiene permiso para editar facturas de compra';
         else
            p_edit_msg := 'Usted no tiene permiso para borrar facturas de compra';
         end if;

         return;

      end if;

      v_pre_id := null;

      select case
               when p_delete = 0 then pre_id_edit
               else pre_id_delete
             end,
             doc_nombre
        into v_pre_id,
             v_doc_nombre
      from Documento
      where doc_id = v_doc_id;

      if not exists ( select per_id
                      from Permiso
                      where pre_id = v_pre_id
                        and ( ( us_id = p_us_id )
                             or exists ( select us_id
                                         from UsuarioRol
                                         where us_id = p_us_id
                                           and rol_id = Permiso.rol_id))) then
         p_editable := 0;

         if p_delete = 0 then
            p_edit_msg := 'Usted no tiene permiso para editar ' || v_doc_nombre;
         else
            p_edit_msg := 'Usted no tiene permiso para borrar ' || v_doc_nombre;
         end if;

         return;

      end if;

      -- Fechas de control de Acceso
      select fca_id
        into v_fca_id
      from Documento
      where doc_id = v_doc_id;

      if not v_fca_id is null then

         if not exists ( select fca_id
                         from FechaControlAcceso
                         where fca_id = v_fca_id
                           and v_fc_fecha BETWEEN fca_fechaDesde and fca_fechaHasta ) then

            select fca_fechaDesde,
                   fca_fechaHasta
              into v_fca_fechaDesde,
                   v_fca_fechaHasta
            from FechaControlAcceso
            where fca_id = v_fca_id;

            p_editable := 0;

            p_edit_msg := 'La fecha del comprobante esta fuera del intervalo definido por las fechas de control de acceso ('
                            || to_char(coalesce(v_fca_fechaDesde, ''), 'dd-mm-yyyy')
                            || ' - '
                            || to_char(coalesce(v_fca_fechaHasta, ''), 'dd-mm-yyyy')
                            || ')';
            return;

         end if;

      end if;

      if exists ( select fc_id
                  from FacturaCompraOrdenPago
                  where fc_id = p_fc_id ) then

         -- Si la condicion de pago es por debito automatico
         -- la aplicacion no impide la edicion
         --
         if not exists ( select fc.cpg_id
                         from FacturaCompra fc
                         join CondicionPago cpg
                           on fc.cpg_id = cpg.cpg_id
                          and cpg.cpg_tipo in ( 2,3 )
                         where fc.fc_id = p_fc_id ) then
            p_editable := 0;
            p_edit_msg := 'El comprobante esta vinculado a una orden de pago';

            return;

         end if;

      end if;

      if exists ( select fc_id_factura
                  from FacturaCompraNotaCredito
                  where fc_id_factura = p_fc_id
                     or fc_id_notacredito = p_fc_id ) then

         p_editable := 0;
         p_edit_msg := 'El comprobante esta vinculado a una factura o nota de credito';

         return;

      end if;


      if exists ( select fci.fc_id
                  from RemitoFacturaCompra r
                  join FacturaCompraItem fci
                    on r.fci_id = fci.fci_id
                  where fci.fc_id = p_fc_id ) then

         p_editable := 0;
         p_edit_msg := 'El comprobante esta vinculado a un remito';

         return;

      end if;

      if exists ( select fci.fc_id
                  from OrdenFacturaCompra oc
                  join FacturaCompraItem fci
                    on oc.fci_id = fci.fci_id
                  where fci.fc_id = p_fc_id ) then

         p_editable := 0;
         p_edit_msg := 'El comprobante esta vinculado a una orden de compra';

         return;

      end if;

      if v_impreso <> 0 and p_no_anulado = 0 then

         select doc_editarimpresos
           into v_doc_editarimpresos
         from Documento
         where doc_id = v_doc_id;

         if v_doc_editarimpresos = 0 then

            p_editable := 0;

            if p_delete = 0 then
               p_edit_msg := 'El comprobante esta impreso y la definición de su documento no permite la edición de comprobantes impresos.';
            else
               p_edit_msg := 'El comprobante esta impreso y la definición de su documento no permite eliminar comprobantes impresos.';
            end if;

            return;

         end if;

      end if;

   end if;

   p_editable := 1;
   p_edit_msg := '';

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_compra_editable_get(integer, integer, integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_compra_get()

-- drop function sp_doc_factura_compra_get(integer, integer, integer);
/*
select * from sp_doc_factura_compra_get(1,1,1);
fetch all from rtn;
*/
create or replace function sp_doc_factura_compra_get
(
  in p_emp_id integer,
  in p_fc_id integer,
  in p_us_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_editable smallint;
   v_edit_msg varchar(255);
   v_doc_id integer;
   v_doct_id integer;
   v_ta_mascara varchar(100);
   v_ta_propuesto smallint;
   v_DeplNombre varchar(255);
   v_DeplId integer;
   v_bIvari smallint;
   v_bIvarni smallint;
   v_prov_id integer;
begin

   rtn := 'rtn';

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                             TALONARIO Y ESTADO DE EDICION                                                          //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   select prov_id,
          doc_id,
          doct_id
   into v_prov_id,
          v_doc_id,
          v_doct_id
   from FacturaCompra
   where fc_id = p_fc_id;

   select * from sp_talonario_get_propuesto(v_doc_id, 0, v_prov_id) into v_ta_mascara, v_ta_propuesto;

   select * from sp_proveedor_get_iva(v_prov_id) into v_bIvari, v_bIvarni;

   select * from sp_doc_factura_compra_editable_get(p_emp_id, p_fc_id, p_us_id) into v_editable, v_edit_msg;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                             DEPOSITO                                                                               //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    /*Factura de Compra*/
    /*Nota de Debito Compra*/
   if v_doct_id = 2
     or v_doct_id = 10 then
   begin
      select dDestino.depl_nombre,
             depl_id_destino
      into v_DeplNombre,
           v_DeplId
      from FacturaCompra
               join Stock
                on FacturaCompra.st_id = Stock.st_id
               left join DepositoLogico dDestino
                on Stock.depl_id_destino = dDestino.depl_id
      where fc_id = p_fc_id;

      v_DeplNombre := coalesce(v_DeplNombre, '');

      v_DeplId := coalesce(v_DeplId, 0);

      if v_DeplId = 0 then
      begin
         select dDestino.depl_nombre,
                depl_id_destino
           into v_DeplNombre,
                v_DeplId
           from FacturaCompra
                  join RemitoCompra
                   on FacturaCompra.rc_id = RemitoCompra.rc_id
                  join Stock
                   on RemitoCompra.st_id = Stock.st_id
                  left join DepositoLogico dDestino
                   on Stock.depl_id_destino = dDestino.depl_id
            where fc_id = p_fc_id;

      end;
      end if;

   end;
   else
   begin
      /*Nota de Credito Compra*/
      if v_doct_id = 8 then
         select dOrigen.depl_nombre,
                        depl_id_origen
           into v_DeplNombre,
                v_DeplId
           from FacturaCompra
                  join Stock
                   on FacturaCompra.st_id = Stock.st_id
                  left join DepositoLogico dOrigen
                   on Stock.depl_id_origen = dOrigen.depl_id
            where fc_id = p_fc_id;

      end if;

      v_DeplNombre := coalesce(v_DeplNombre, '');

      v_DeplId := coalesce(v_DeplId, 0);

      if v_DeplId = 0 then
      begin
         select dOrigen.depl_nombre,
                depl_id_origen
           into v_DeplNombre,
                v_DeplId
           from FacturaCompra
                  join RemitoCompra
                   on FacturaCompra.rc_id = RemitoCompra.rc_id
                  join Stock
                   on RemitoCompra.st_id = Stock.st_id
                  left join DepositoLogico dOrigen
                   on Stock.depl_id_origen = dOrigen.depl_id
            where fc_id = p_fc_id;

      end;
      end if;

   end;
   end if;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                             select                                                                                 //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
   open rtn for

      select FacturaCompra.*,
             doct_nombre,
             mon_nombre,
             prov_nombre,
             lp_nombre,
             ld_nombre,
             cpg_nombre,
             est_nombre,
             ccos_nombre,
             suc_nombre,
             doc_nombre,
             case
                  when lgj_titulo <> '' then lgj_titulo
                  else lgj_codigo
             end lgj_codigo,
             pOrigen.pro_nombre ProOrigen,
             pDestino.pro_nombre ProDestino,
             v_DeplId depl_id,
             v_DeplNombre depl_nombre,
             v_bIvari bIvaRi,
             v_bIvarni bIvaRni,
             v_editable editable,
             v_edit_msg editMsg,
             v_ta_mascara ta_mascara,
             v_ta_propuesto ta_propuesto,
             doc_muevestock,
             doc_tipofactura
        from FacturaCompra
               join Documento
                on FacturaCompra.doc_id = Documento.doc_id
               join DocumentoTipo
                on FacturaCompra.doct_id = DocumentoTipo.doct_id
               join Moneda
                on FacturaCompra.mon_id = Moneda.mon_id
               join CondicionPago
                on FacturaCompra.cpg_id = CondicionPago.cpg_id
               join Estado
                on FacturaCompra.est_id = Estado.est_id
               join Sucursal
                on FacturaCompra.suc_id = Sucursal.suc_id
               join Proveedor
                on FacturaCompra.prov_id = Proveedor.prov_id
               left join CentroCosto
                on FacturaCompra.ccos_id = CentroCosto.ccos_id
               left join ListaPrecio
                on FacturaCompra.lp_id = ListaPrecio.lp_id
               left join ListaDescuento
                on FacturaCompra.ld_id = ListaDescuento.ld_id
               left join Legajo
                on FacturaCompra.lgj_id = Legajo.lgj_id
               left join Provincia pOrigen
                on FacturaCompra.pro_id_origen = pOrigen.pro_id
               left join Provincia pDestino
                on FacturaCompra.pro_id_destino = pDestino.pro_id
         where fc_id = p_fc_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_compra_get(integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_compra_get_items()

-- drop function sp_doc_factura_compra_get_items(integer);
/*
select * from sp_doc_factura_compra_get_items(1);
fetch all from rtn;
fetch all from rtn_serie;
*/
create or replace function sp_doc_factura_compra_get_items
(
  in p_fc_id integer,
  out rtn refcursor,
  out rtn_serie refcursor
)
  returns record as
$BODY$
begin

   rtn := 'rtn';

   open rtn for

      select fci.*,
             pr_nombreCompra,
             pr_llevanroserie,
             pr_llevanrolote,
             pr_porcinternoc,
             tri.ti_porcentaje iva_ri_porcentaje,
             trni.ti_porcentaje iva_rni_porcentaje,
             tint.ti_porcentaje internos_porcentaje,
             ccos.ccos_nombre,
             un_nombre,
             to_nombre,
             stl.stl_codigo
      from FacturaCompraItem fci
      join Producto
       on fci.pr_id = Producto.pr_id
      join Unidad
       on Producto.un_id_compra = Unidad.un_id
      join TipoOperacion
       on fci.to_id = TipoOperacion.to_id
      left join TasaImpositiva tri
       on Producto.ti_id_ivaricompra = tri.ti_id
      left join TasaImpositiva trni
       on Producto.ti_id_ivarnicompra = trni.ti_id
      left join TasaImpositiva tint
       on Producto.ti_id_internosc = tint.ti_id
      left join CentroCosto ccos
       on fci.ccos_id = ccos.ccos_id
      left join StockLote stl
       on fci.stl_id = stl.stl_id
      where fci.fc_id = p_fc_id
      order by fci.fci_orden;

--///////////////////////////////////////////////////////////////////////////////////////////////////
--
--  NUMEROS DE SERIE
--
--///////////////////////////////////////////////////////////////////////////////////////////////////

   rtn_serie := 'rtn_serie';

   open rtn_serie for

      select prns.prns_id,
             prns.prns_codigo,
             prns.prns_descrip,
             prns.prns_fechavto,
             fci.fci_id
      from ProductoNumeroSerie prns
       join StockItem sti
        on prns.prns_id = sti.prns_id
       join FacturaCompraItem fci
        on sti.sti_grupo = fci.fci_id
       join FacturaCompra fc
        on fci.fc_id = fc.fc_id
      where fci.fc_id = p_fc_id and sti.st_id = fc.st_id
      GROUP by prns.prns_id,prns.prns_codigo,prns.prns_descrip,prns.prns_fechavto,fci.fci_id
      order by fci.fci_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_compra_get_items(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_compra_get_legajos()

-- drop function sp_doc_factura_compra_get_legajos(integer);
/*
select * from sp_doc_factura_compra_get_legajos(1);
fetch all from rtn;
fetch all from rtn_serie;
*/
create or replace function sp_doc_factura_compra_get_legajos
/*
sp_doc_factura_compra_get_legajos 1
*/
(
  in p_fc_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
begin

   rtn := 'rtn';

   open rtn for
      select FacturaCompraLegajo.*,
             case
               when lgj_titulo <> '' then lgj_titulo
               else lgj_codigo
             end lgj_codigo
      from FacturaCompraLegajo
       join Legajo on FacturaCompraLegajo.lgj_id = Legajo.lgj_id
      where fc_id = p_fc_id
      order by fclgj_orden;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_compra_get_legajos(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_compra_get_otros()

-- drop function sp_doc_factura_compra_get_otros(integer);
/*
select * from sp_doc_factura_compra_get_otros(1);
fetch all from rtn;
fetch all from rtn_serie;
*/
create or replace function sp_doc_factura_compra_get_otros
(
  in p_fc_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
begin

   open rtn for
      select FacturaCompraOtro.*,
             cue_nombre,
             ccos.ccos_nombre
      from FacturaCompraOtro
        join Cuenta
                on FacturaCompraOtro.cue_id = Cuenta.cue_id
        left join CentroCosto ccos
                on FacturaCompraOtro.ccos_id = ccos.ccos_id
      where fc_id = p_fc_id
      order by fcot_orden;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_compra_get_otros(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_compra_get_percepciones()

-- drop function sp_doc_factura_compra_get_percepciones(integer);
/*
select * from sp_doc_factura_compra_get_percepciones(1);
fetch all from rtn;
fetch all from rtn_serie;
*/
create or replace function sp_doc_factura_compra_get_percepciones
/*
sp_DocFacCpraGetPercepcionesones 1
*/
(
  in p_fc_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
begin

   rtn := 'rtn';

   open rtn for
      select FacturaCompraPercepcion.*,
             perc_nombre,
             ccos.ccos_nombre
      from FacturaCompraPercepcion
        join Percepcion
                on FacturaCompraPercepcion.perc_id = Percepcion.perc_id
        left join CentroCosto ccos
                on FacturaCompraPercepcion.ccos_id = ccos.ccos_id
      where fc_id = p_fc_id
      order by fcperc_orden;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_compra_get_percepciones(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_compra_get_remitos()

-- drop function sp_doc_factura_compra_get_remitos(integer, integer, integer);
/*

  select * from sp_doc_factura_compra_get_remitos(1,1,2);
  fetch all from rtn;

*/

create or replace function sp_doc_factura_compra_get_remitos
(
  in p_emp_id integer,
  in p_prov_id integer,
  in p_mon_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_doct_remito integer;
begin

   v_doct_remito := 4;

   rtn := 'rtn';

   open rtn for

      select rc.rc_id,
             d.doc_nombre,
             rc.rc_numero,
             rc.rc_nrodoc,
             rc.rc_fecha,
             rc.rc_total,
             rc.rc_pendiente,
             rc.rc_descrip
      from remitocompra rc
      join documento d
        on rc.doc_id = d.doc_id
      join moneda m
        on d.mon_id = m.mon_id
      where rc.prov_id = p_prov_id
        and rc.est_id <> 7 -- anulado
        and rc.doct_id = v_doct_remito
        and d.mon_id = p_mon_id
        and d.emp_id = p_emp_id
        and exists ( select rci_id
                     from remitocompraitem
                     where rc_id = rc.rc_id
                       and rci_pendientefac > 0 )
      order by rc.rc_nrodoc,
               rc.rc_fecha;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_compra_get_remitos(integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_compra_save()

-- drop function sp_doc_factura_compra_save(integer, integer);

create or replace function sp_doc_factura_compra_save
(
  in p_us_id integer,
  in p_fcTMP_id integer
)
  returns setof row_result as
$BODY$
declare
   rtn row_result;

   v_success smallint;
   v_error smallint;
   v_error_msg varchar(5000);   
   v_cfg_valor varchar(5000);
   
   v_is_new smallint;
   
   v_fc_id integer;
   v_fci_id integer;
   
   v_orden smallint;
   v_doct_id integer;
   v_cpg_id integer;
   v_doc_mueveStock smallint;
   v_depl_id integer;
   v_mon_id integer;
   v_ta_id integer;
   v_doc_id integer;
   v_prov_id integer;
   v_est_id integer;
   v_suc_id integer;
   v_lp_id integer;
   v_ld_id integer;
   v_ccos_id integer;
   v_lgj_id integer;
   v_pro_id_origen integer;
   v_pro_id_destino integer;
   
   v_fc_total decimal(18,6);
   v_fc_fecha date;
   v_fc_fechaVto date;
   v_fc_fechaiva date;
   v_fc_descuento1 decimal(18,6);
   v_fc_descuento2 decimal(18,6);
   v_fc_totalotros decimal(18,6);
   v_fc_totalpercepciones decimal(18,6);
   v_fc_nrodoc varchar(50);
   v_fc_numero integer;
   v_fc_descrip varchar(5000);
   v_fc_fechaentrega date;
   v_fc_neto decimal(18,6);
   v_fc_ivari decimal(18,6);
   v_fc_ivarni decimal(18,6);
   v_fc_internos decimal(18,6);
   v_fc_subtotal decimal(18,6);
   v_fc_totalorigen decimal(18,6);
   v_fc_cotizacion decimal(18,6);
   v_fc_cotizacionProv decimal(18,6);
   v_fc_pendiente decimal(18,6);
   v_fc_importedesc1 decimal(18,6);
   v_fc_importedesc2 decimal(18,6);
   v_fc_grabarasiento smallint;
   v_fc_cai varchar(100);
   v_fc_tipoComprobante smallint;

   v_creado date;
   v_modificado date;
   v_modifico integer;

   v_fciTMP_id integer;
   v_fci_orden smallint;
   v_fci_cantidad decimal(18,6);
   v_fci_cantidadaremitir decimal(18,6);
   v_fci_pendiente decimal(18,6);
   v_fci_descrip varchar(5000);
   v_fci_precio decimal(18,6);
   v_fci_precioUsr decimal(18,6);
   v_fci_precioLista decimal(18,6);
   v_fci_descuento varchar(100);
   v_fci_neto decimal(18,6);
   v_fci_ivari decimal(18,6);
   v_fci_ivarni decimal(18,6);
   v_fci_ivariporc decimal(18,6);
   v_fci_ivarniporc decimal(18,6);
   v_fci_internos decimal(18,6);
   v_fci_internosporc decimal(18,6);
   v_fci_importe decimal(18,6);
   v_fci_importeorigen decimal(18,6);

   v_pr_id integer;
   v_stl_id integer;
   v_to_id integer;

   v_cue_id integer;
   v_cue_id_ivari integer;
   v_cue_id_ivarni integer;

   v_opg_id integer;

   v_fcot_id integer;
   v_fcot_orden smallint;
   v_fcot_debe decimal(18,6);
   v_fcot_haber decimal(18,6);
   v_fcot_origen decimal(18,6);
   v_fcot_descrip varchar(255);

   v_fcperc_id integer;
   v_fcperc_orden smallint;
   v_fcperc_base decimal(18,6);
   v_fcperc_porcentaje decimal(18,6);
   v_fcperc_importe decimal(18,6);
   v_fcperc_origen decimal(18,6);
   v_fcperc_descrip varchar(255);

   v_perc_id integer;

   v_fclgj_id integer;
   v_fclgj_orden smallint;
   v_fclgj_importe decimal(18,6);
   v_fclgj_importeorigen decimal(18,6);
   v_fclgj_descrip varchar(255);
   v_fc_totaldeuda decimal(18,6);

   v_ta_propuesto smallint;
   v_ta_tipo smallint;
   v_ta_nrodoc varchar(100);
   dummyChar varchar;

   v_emp_id integer;
begin

   -- si no existe chau
   --
   if not exists ( select fcTMP_id
                   from FacturaCompraTMP
                   where fcTMP_id = p_fcTMP_id ) then

      return query select * from result_failed;
      return;

   end if;

   select sp_cfg_getValor('Compras-General', 'Exigir Centro Costo') into v_cfg_valor;

   v_cfg_valor := coalesce(v_cfg_valor, '0');

   if to_number(v_cfg_valor) <> 0 then

      if exists ( select ccos_id
                  from FacturaCompraTMP
                  where ccos_id is null
                   and fcTMP_id = p_fcTMP_id ) then


         if exists ( select ccos_id
                     from FacturaCompraItemTMP
                     where ccos_id is null
                       and fcTMP_id = p_fcTMP_id ) then

            raise exception '@@ERROR_SP: %',
               'Debe indicar un centro de costo en cada item o un centro de costo en la cabecera del documento.';

         end if;

         if exists ( select ccos_id
                     from FacturaCompraOtroTMP
                     where ccos_id is null
                       and fcTMP_id = p_fcTMP_id ) then

            raise exception '@@ERROR_SP: %',
               'Debe indicar un centro de costo en cada item de la solapa "Otros" o un centro de costo en la cabecera del documento.';

         end if;

         if exists ( select ccos_id
                     from FacturaCompraPercepcionTMP
                     where ccos_id is null
                       and fcTMP_id = p_fcTMP_id ) then

            raise exception '@@ERROR_SP: %',
               'Debe indicar un centro de costo en cada item de percepciones o un centro de costo en la cabecera del documento.';

         end if;

      end if;

   end if;

   v_error_msg := '';

   select * from sp_doc_fac_cpra_validate_deposito(p_fcTMP_id) into v_success, v_error_msg;
   if coalesce(v_success, 0) = 0 then
      raise exception '%', v_error_msg;
   end if;

   select fc_id
     into v_fc_id
   from FacturaCompraTMP
   where fcTMP_id = p_fcTMP_id;

   v_fc_id := coalesce(v_fc_id, 0);

   select mon_id,
          case prov_catfiscal
              when 1  then ta_id_inscripto    --'Inscripto'
              when 2  then ta_id_final        --'Exento'
              when 3  then ta_id_final        --'No inscripto'
              when 4  then ta_id_final        --'Consumidor Final'
              when 5  then ta_id_externo      --'Extranjero'
              when 6  then ta_id_final        --'Mono Tributo'
              when 7  then ta_id_externo      --'Extranjero Iva'
              when 8  then ta_id_final        --'No responsable'
              when 9  then ta_id_final        --'No Responsable exento'
              when 10 then ta_id_final        --'No categorizado'
              when 11 then ta_id_inscriptoM   --'Inscripto M'
              else -1                         --'Sin categorizar'
          end,
          Documento.doct_id,
          FacturaCompraTMP.cpg_id,
          FacturaCompraTMP.fc_total,
          FacturaCompraTMP.fc_fecha,
          FacturaCompraTMP.fc_fechaVto,
          FacturaCompraTMP.fc_fechaIva,
          FacturaCompraTMP.depl_id,
          Documento.doc_muevestock,
          FacturaCompraTMP.fc_descuento1,
          FacturaCompraTMP.fc_descuento2,
          fc_totalotros,
          fc_totalpercepciones,
          fc_nrodoc,
          FacturaCompraTMP.doc_id,
          FacturaCompraTMP.prov_id,
          FacturaCompraTMP.est_id
          into    v_mon_id,
                  v_ta_id,
                  v_doct_id,
                  v_cpg_id,
                  v_fc_total,
                  v_fc_fecha,
                  v_fc_fechaVto,
                  v_fc_fechaiva,
                  v_depl_id,
                  v_doc_mueveStock,
                  v_fc_descuento1,
                  v_fc_descuento2,
                  v_fc_totalotros,
                  v_fc_totalpercepciones,
                  v_fc_nrodoc,
                  v_doc_id,
                  v_prov_id,
                  v_est_id

   from FacturaCompraTMP
   join Documento
     on FacturaCompraTMP.doc_id = Documento.doc_id
   join Proveedor
     on FacturaCompraTMP.prov_id = Proveedor.prov_id
   where fcTMP_id = p_fcTMP_id;

   if v_ta_id = -1 then
      return query select * from result_error('El proveedor no esta categorizado. Debe indicar en que categoria fiscal se encuentra el proveedor.')
      return;
   end if;

   set TRANSACTION READ WRITE;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                        insert                                                                      //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
   if v_fc_id = 0 then

      v_is_new := -1;

      select sp_dbGetNewId('FacturaCompra', 'fc_id') into v_fc_id;
      select sp_dbGetNewId('FacturaCompra', 'fc_numero') into v_fc_numero;
      select * from sp_talonario_get_propuesto(v_doc_id, 0, v_prov_id) into dummyChar, v_ta_propuesto, v_ta_id, v_ta_tipo;

      if v_ta_propuesto = 0 then
         if v_ta_tipo = 3 then /*Auto Impresor*/

            select sp_talonario_get_next_number(v_ta_id) into v_ta_nrodoc;

            -- con esto evitamos que dos tomen el mismo Numero
            --
            perform sp_talonario_set(v_ta_id, v_ta_nrodoc);

            v_fc_nrodoc := v_ta_nrodoc;

         end if;
      end if;

      insert into FacturaCompra
        ( fc_id, fc_numero, fc_nrodoc, fc_descrip, fc_fecha, fc_fechaentrega, fc_fechaVto, fc_fechaiva, fc_neto,
          fc_ivari, fc_ivarni, fc_internos, fc_total, fc_totalorigen, fc_subtotal, fc_totalotros,
          fc_totalpercepciones, fc_descuento1, fc_descuento2, fc_importedesc1, fc_importedesc2, fc_grabarasiento,
          fc_cotizacion, fc_cotizacionprov, fc_cai, fc_tipocomprobante, mon_id, est_id, suc_id, prov_id, doc_id,
          doct_id, lp_id, ld_id, cpg_id, ccos_id, lgj_id, pro_id_origen, pro_id_destino, modifico )
        ( select v_fc_id,
                 v_fc_numero,
                 v_fc_nrodoc,
                 fc_descrip,
                 fc_fecha,
                 fc_fechaentrega,
                 fc_fechaVto,
                 fc_fechaiva,
                 fc_neto,
                 fc_ivari,
                 fc_ivarni,
                 fc_internos,
                 fc_total,
                 fc_totalorigen,
                 fc_subtotal,
                 fc_totalotros,
                 fc_totalpercepciones,
                 fc_descuento1,
                 fc_descuento2,
                 fc_importedesc1,
                 fc_importedesc2,
                 fc_grabarasiento,
                 fc_cotizacion,
                 fc_cotizacionProv,
                 fc_cai,
                 fc_tipocomprobante,
                 v_mon_id,
                 est_id,
                 suc_id,
                 prov_id,
                 doc_id,
                 v_doct_id,
                 lp_id,
                 ld_id,
                 cpg_id,
                 ccos_id,
                 lgj_id,
                 pro_id_origen,
                 pro_id_destino,
                 modifico
          from FacturaCompraTMP
          where fcTMP_id = p_fcTMP_id );

      select doc_id,
             fc_nrodoc
        into v_doc_id,
             v_fc_nrodoc
      from FacturaCompra
      where fc_id = v_fc_id;
/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                        update                                                                      //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
   else

      v_is_new := 0;

      select fc_id,
             fc_nrodoc,
             fc_descrip,
             fc_fechaentrega,
             fc_neto,
             fc_ivari,
             fc_ivarni,
             fc_internos,
             fc_totalorigen,
             fc_cotizacion,
             fc_cotizacionProv,
             fc_descuento1,
             fc_descuento2,
             fc_subtotal,
             fc_importedesc1,
             fc_importedesc2,
             fc_grabarasiento,
             fc_cai,
             fc_tipocomprobante,
             est_id,
             suc_id,
             prov_id,
             doc_id,
             lp_id,
             ld_id,
             ccos_id,
             lgj_id,
             pro_id_origen,
             pro_id_destino,
             modifico,
             modificado
        into v_fc_id,
             v_fc_nrodoc,
             v_fc_descrip,
             v_fc_fechaentrega,
             v_fc_neto,
             v_fc_ivari,
             v_fc_ivarni,
             v_fc_internos,
             v_fc_totalorigen,
             v_fc_cotizacion,
             v_fc_cotizacionProv,
             v_fc_descuento1,
             v_fc_descuento2,
             v_fc_subtotal,
             v_fc_importedesc1,
             v_fc_importedesc2,
             v_fc_grabarasiento,
             v_fc_cai,
             v_fc_tipocomprobante,
             v_est_id,
             v_suc_id,
             v_prov_id,
             v_doc_id,
             v_lp_id,
             v_ld_id,
             v_ccos_id,
             v_lgj_id,
             v_pro_id_origen,
             v_pro_id_destino,
             v_modifico,
             v_modificado
      from FacturaCompraTMP
      where fcTMP_id = p_fcTMP_id;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                          generacion automatica de orden de pago                                                    //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
      /*
            si la condicion de pago de la factura es de tipo [Debito Automatico] o [Fondo Fijo]
            debo generar una orden de pago automaticamente.

            para esto tengo que sacar de la condicion de pago el documento y la cuenta contable
            de los fondos pasando por la cuenta grupo asociada a dicha condicion de pago.
      */

      -- tengo que desaplicar la orden de pago para poder regenerar la deuda
      --
      select opg_id
        into v_opg_id
      from FacturaCompra
      where fc_id = v_fc_id;

      if v_opg_id is not null then

         delete from FacturaCompraOrdenPago where fc_id = v_fc_id;

         update FacturaCompra set opg_id = null where fc_id = v_fc_id;

         update OrdenPago set fc_id = null where fc_id = v_fc_id;

         select emp_id into v_emp_id from OrdenPago where opg_id = v_opg_id;

         perform sp_doc_orden_pago_delete(v_opg_id, v_emp_id, v_modifico);

         delete from FacturaCompraDeuda where fc_id = v_fc_id;

         delete from FacturaCompraPago where fc_id = v_fc_id;

      end if;

      update FacturaCompra
         set fc_nrodoc = v_fc_nrodoc,
             fc_descrip = v_fc_descrip,
             fc_fecha = v_fc_fecha,
             fc_fechaentrega = v_fc_fechaentrega,
             fc_fechaVto = v_fc_fechaVto,
             fc_fechaiva = v_fc_fechaiva,
             fc_neto = v_fc_neto,
             fc_ivari = v_fc_ivari,
             fc_ivarni = v_fc_ivarni,
             fc_internos = v_fc_internos,
             fc_total = v_fc_total,
             fc_totalorigen = v_fc_totalorigen,
             fc_totalotros = v_fc_totalotros,
             fc_totalpercepciones = v_fc_totalpercepciones,
             fc_cotizacion = v_fc_cotizacion,
             fc_cotizacionprov = v_fc_cotizacionprov,
             fc_descuento1 = v_fc_descuento1,
             fc_descuento2 = v_fc_descuento2,
             fc_subtotal = v_fc_subtotal,
             fc_importedesc1 = v_fc_importedesc1,
             fc_importedesc2 = v_fc_importedesc2,
             fc_grabarasiento = v_fc_grabarasiento,
             fc_cai = v_fc_cai,
             fc_tipocomprobante = v_fc_tipocomprobante,
             mon_id = v_mon_id,
             est_id = v_est_id,
             suc_id = v_suc_id,
             prov_id = v_prov_id,
             doc_id = v_doc_id,
             doct_id = v_doct_id,
             lp_id = v_lp_id,
             ld_id = v_ld_id,
             cpg_id = v_cpg_id,
             lgj_id = v_lgj_id,
             pro_id_origen = v_pro_id_origen,
             pro_id_destino = v_pro_id_destino,
             ccos_id = v_ccos_id,
             modifico = v_modifico,
             modificado = v_modificado
      where fc_id = v_fc_id;

   end if;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                        ITEMS                                                                       //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   v_orden := 1;

   while exists(select 1 from FacturaCompraItemTMP where fcTMP_id = p_fcTMP_id and fci_orden = v_orden)
   loop

      select fciTMP_id,
             fci_id,
             fci_orden,
             fci_cantidad,
             fci_cantidadaremitir,
             fci_pendiente,
             fci_descrip,
             fci_precio,
             fci_precioUsr,
             fci_precioLista,
             fci_descuento,
             fci_neto,
             fci_ivari,
             fci_ivarni,
             fci_ivariporc,
             fci_ivarniporc,
             fci_internos,
             fci_internosporc,
             fci_importe,
             fci_importeorigen,
             pr_id,
             to_id,
             ccos_id,
             cue_id,
             cue_id_ivari,
             cue_id_ivarni,
             stl_id
        into v_fciTMP_id,
             v_fci_id,
             v_fci_orden,
             v_fci_cantidad,
             v_fci_cantidadaremitir,
             v_fci_pendiente,
             v_fci_descrip,
             v_fci_precio,
             v_fci_precioUsr,
             v_fci_precioLista,
             v_fci_descuento,
             v_fci_neto,
             v_fci_ivari,
             v_fci_ivarni,
             v_fci_ivariporc,
             v_fci_ivarniporc,
             v_fci_internos,
             v_fci_internosporc,
             v_fci_importe,
             v_fci_importeorigen,
             v_pr_id,
             v_to_id,
             v_ccos_id,
             v_cue_id,
             v_cue_id_ivari,
             v_cue_id_ivarni,
             v_stl_id
      from FacturaCompraItemTMP
      where fcTMP_id = p_fcTMP_id
        and fci_orden = v_orden;

      -- cuando se inserta se indica
      -- como cantidad a remitir la cantidad (por ahora)
      --
      v_fci_cantidadaremitir := v_fci_cantidad;

      if v_is_new <> 0 or v_fci_id = 0 then

         -- cuando se inserta se toma la cantidad a remitir
         -- como el pendiente
         --
         v_fci_pendiente := v_fci_cantidadaremitir;

         select sp_dbGetNewId('FacturaCompraItem', 'fci_id') into v_fci_id;

         insert into FacturaCompraItem
           ( fc_id, fci_id, fci_orden, fci_cantidad, fci_cantidadaremitir, fci_descrip, fci_pendiente,
             fci_precio, fci_precioUsr, fci_precioLista, fci_descuento, fci_neto, fci_ivari, fci_ivarni,
             fci_ivariporc, fci_ivarniporc, fci_internos, fci_internosporc, fci_importe, fci_importeorigen,
             pr_id, to_id, ccos_id, cue_id, cue_id_ivari, cue_id_ivarni, stl_id )

         values ( v_fc_id, v_fci_id, v_fci_orden, v_fci_cantidad, v_fci_cantidadaremitir, v_fci_descrip,
                  v_fci_pendiente, v_fci_precio, v_fci_precioUsr, v_fci_precioLista, v_fci_descuento,
                  v_fci_neto, v_fci_ivari, v_fci_ivarni, v_fci_ivariporc, v_fci_ivarniporc, v_fci_internos,
                  v_fci_internosporc, v_fci_importe, v_fci_importeorigen, v_pr_id, v_to_id, v_ccos_id,
                  v_cue_id, v_cue_id_ivari, v_cue_id_ivarni, v_stl_id );

         update FacturaCompraItemTMP
            set fci_id = v_fci_id
         where fcTMP_id = p_fcTMP_id
           and fciTMP_id = v_fciTMP_id
           and fci_orden = v_orden;

         update FacturaCompraItemSerieTMP
            set fci_id = v_fci_id
         where fcTMP_id = p_fcTMP_id
           and fciTMP_id = v_fciTMP_id;

      else

         -- cuando se actualiza se indica
         -- como pendiente la cantidad a remitir menos lo aplicado
         --
         select sum(ocfc_cantidad)
           into v_fci_pendiente
         from OrdenFacturaCompra
         where fci_id = v_fci_id;

         v_fci_pendiente := v_fci_cantidadaremitir - coalesce(v_fci_pendiente, 0);

         update FacturaCompraItem
            set fc_id = v_fc_id,
                fci_orden = v_fci_orden,
                fci_cantidad = v_fci_cantidad,
                fci_cantidadaremitir = v_fci_cantidadaremitir,
                fci_pendiente = v_fci_pendiente,
                fci_descrip = v_fci_descrip,
                fci_precio = v_fci_precio,
                fci_precioUsr = v_fci_precioUsr,
                fci_precioLista = v_fci_precioLista,
                fci_descuento = v_fci_descuento,
                fci_neto = v_fci_neto,
                fci_ivari = v_fci_ivari,
                fci_ivarni = v_fci_ivarni,
                fci_ivariporc = v_fci_ivariporc,
                fci_ivarniporc = v_fci_ivarniporc,
                fci_internos = v_fci_internos,
                fci_internosporc = v_fci_internosporc,
                fci_importe = v_fci_importe,
                fci_importeorigen = v_fci_importeorigen,
                pr_id = v_pr_id,
                to_id = v_to_id,
                ccos_id = v_ccos_id,
                cue_id = v_cue_id,
                cue_id_ivari = v_cue_id_ivari,
                cue_id_ivarni = v_cue_id_ivarni,
                stl_id = v_stl_id
         where fc_id = v_fc_id
           and fci_id = v_fci_id;

         update FacturaCompraItemTMP
            set fci_id = v_fci_id
         where fcTMP_id = p_fcTMP_id
           and fciTMP_id = v_fciTMP_id
           and fci_orden = v_orden;


         update FacturaCompraItemSerieTMP
            set fci_id = v_fci_id
         where fcTMP_id = p_fcTMP_id
           and fciTMP_id = v_fciTMP_id;

      end if;

      v_orden := v_orden + 1;

   end loop;

   v_orden := 1;

   while exists(select 1 from FacturaCompraOtroTMP where fcTMP_id = p_fcTMP_id and fcot_orden = v_orden)
   loop

      select fcot_id,
             fcot_orden,
             fcot_debe,
             fcot_haber,
             fcot_origen,
             fcot_descrip,
             cue_id,
             ccos_id
        into v_fcot_id,
             v_fcot_orden,
             v_fcot_debe,
             v_fcot_haber,
             v_fcot_origen,
             v_fcot_descrip,
             v_cue_id,
             v_ccos_id
      from FacturaCompraOtroTMP
      where fcTMP_id = p_fcTMP_id
        and fcot_orden = v_orden;

      if v_is_new <> 0 or v_fcot_id = 0 then

         select sp_dbGetNewId('FacturaCompraOtro', 'fcot_id') into v_fcot_id;

         insert into FacturaCompraOtro( fc_id, fcot_id, fcot_orden, fcot_debe, fcot_haber, fcot_origen,
                                  fcot_descrip, cue_id, ccos_id )
         values ( v_fc_id, v_fcot_id, v_fcot_orden, v_fcot_debe, v_fcot_haber, v_fcot_origen,
               v_fcot_descrip, v_cue_id, v_ccos_id );

      else

         update FacturaCompraOtro
            set fc_id = v_fc_id,
                fcot_orden = v_fcot_orden,
                fcot_debe = v_fcot_debe,
                fcot_haber = v_fcot_haber,
                fcot_origen = v_fcot_origen,
                fcot_descrip = v_fcot_descrip,
                cue_id = v_cue_id,
                ccos_id = v_ccos_id
         where fc_id = v_fc_id
           and fcot_id = v_fcot_id;

      end if;

      v_orden := v_orden + 1;

   end loop;

   v_orden := 1;

   while exists(select 1 from FacturaCompraPercepcionTMP where fcTMP_id = p_fcTMP_id and fcperc_orden = v_orden)
   loop

      select fcperc_id,
             fcperc_orden,
             fcperc_base,
             fcperc_porcentaje,
             fcperc_importe,
             fcperc_origen,
             fcperc_descrip,
             perc_id,
             ccos_id
        into v_fcperc_id,
             v_fcperc_orden,
             v_fcperc_base,
             v_fcperc_porcentaje,
             v_fcperc_importe,
             v_fcperc_origen,
             v_fcperc_descrip,
             v_perc_id,
             v_ccos_id
      from FacturaCompraPercepcionTMP
      where fcTMP_id = p_fcTMP_id
      and fcperc_orden = v_orden;

      if v_is_new <> 0 or v_fcperc_id = 0 then

         select sp_dbGetNewId('FacturaCompraPercepcion', 'fcperc_id') into v_fcperc_id;

         insert into FacturaCompraPercepcion( fc_id, fcperc_id, fcperc_orden, fcperc_base, fcperc_porcentaje,
                                              fcperc_importe, fcperc_origen, fcperc_descrip, perc_id, ccos_id )
         values ( v_fc_id, v_fcperc_id, v_fcperc_orden, v_fcperc_base, v_fcperc_porcentaje, v_fcperc_importe,
                  v_fcperc_origen, v_fcperc_descrip, v_perc_id, v_ccos_id );

      else
         update FacturaCompraPercepcion
            set fc_id = v_fc_id,
                fcperc_orden = v_fcperc_orden,
                fcperc_base = v_fcperc_base,
                fcperc_porcentaje = v_fcperc_porcentaje,
                fcperc_importe = v_fcperc_importe,
                fcperc_origen = v_fcperc_origen,
                fcperc_descrip = v_fcperc_descrip,
                perc_id = v_perc_id,
                ccos_id = v_ccos_id
         where fc_id = v_fc_id
           and fcperc_id = v_fcperc_id;

      end if;

      v_orden := v_orden + 1;

   end loop;

   v_orden := 1;

   while exists(select 1 from FacturaCompraLegajoTMP where fcTMP_id = p_fcTMP_id and fclgj_orden = v_orden)
   loop
      select fclgj_id,
             fclgj_orden,
             fclgj_importe,
             fclgj_importeorigen,
             fclgj_descrip,
             lgj_id
        into v_fclgj_id,
             v_fclgj_orden,
             v_fclgj_importe,
             v_fclgj_importeorigen,
             v_fclgj_descrip,
             v_lgj_id
      from FacturaCompraLegajoTMP
      where fcTMP_id = p_fcTMP_id
      and fclgj_orden = v_orden;

      if v_is_new <> 0 or v_fclgj_id = 0 then

         select sp_dbGetNewId('FacturaCompraLegajo', 'fclgj_id') into v_fclgj_id;

         insert into FacturaCompraLegajo ( fc_id, fclgj_id, fclgj_orden, fclgj_importe, fclgj_importeorigen,
                                           fclgj_descrip, lgj_id )
         values ( v_fc_id, v_fclgj_id, v_fclgj_orden, v_fclgj_importe, v_fclgj_importeorigen,
                  v_fclgj_descrip, v_lgj_id );
      else

         update FacturaCompraLegajo
            set fc_id = v_fc_id,
                fclgj_orden = v_fclgj_orden,
                fclgj_importe = v_fclgj_importe,
                fclgj_importeorigen = v_fclgj_importeorigen,
                fclgj_descrip = v_fclgj_descrip,
                lgj_id = v_lgj_id
         where fc_id = v_fc_id
           and fclgj_id = v_fclgj_id;

      end if;

      v_orden := v_orden + 1;

   end loop;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     items borrados                                                                 //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   -- hay que borrar los items borrados del orden
   --
   if v_is_new = 0 then

      delete from FacturaCompraItem
      where exists ( select fci_id
                     from FacturaCompraItemBorradoTMP
                     where fc_id = v_fc_id
                       and fci_id = FacturaCompraItem.fci_id
                       and fcTMP_id = p_fcTMP_id );

      delete from FacturaCompraOtro
      where exists ( select fcot_id
                     from FacturaCompraOtroBorradoTMP
                     where fc_id = v_fc_id
                       and fcot_id = FacturaCompraOtro.fcot_id
                       and fcTMP_id = p_fcTMP_id );

      delete from FacturaCompraOtroBorradoTMP where fc_id = v_fc_id and fcTMP_id = p_fcTMP_id;

      delete from FacturaCompraPercepcion
      where exists ( select fcperc_id
                     from FacturaCompraPercepcionBorradoTMP
                     where fc_id = v_fc_id
                       and fcperc_id = FacturaCompraPercepcion.fcperc_id
                       and fcTMP_id = p_fcTMP_id );

      delete from FacturaCompraPercepcionBorradoTMP where fc_id = v_fc_id and fcTMP_id = p_fcTMP_id;

      delete from FacturaCompraLegajo
      where exists ( select fclgj_id
                     from FacturaCompraLegajoBorradoTMP
                     where fc_id = v_fc_id
                       and fclgj_id = FacturaCompraLegajo.fclgj_id
                       and fcTMP_id = p_fcTMP_id );

      delete from FacturaCompraLegajoBorradoTMP where fc_id = v_fc_id and fcTMP_id = p_fcTMP_id;

   end if;

   select sum(fci.fci_importe)
     into v_fc_totaldeuda
   from FacturaCompraItem fci
   join TipoOperacion t
     on fci.to_id = t.to_id
   where fci.fc_id = v_fc_id
     and t.to_generadeuda <> 0;

   if v_fc_totaldeuda is null then

      v_fc_totaldeuda := 0;

   else

      v_fc_totaldeuda := v_fc_totaldeuda - ((v_fc_totaldeuda * v_fc_descuento1) / 100);
      v_fc_totaldeuda := v_fc_totaldeuda - ((v_fc_totaldeuda * v_fc_descuento2) / 100);
      v_fc_totaldeuda := v_fc_totaldeuda + v_fc_totalotros + v_fc_totalpercepciones;

   end if;

   perform sp_doc_factura_compra_save_deuda(
                          v_fc_id,
                          v_cpg_id,
                          v_fc_fecha,
                          v_fc_fechaVto,
                          v_fc_totaldeuda,
                          v_est_id
                          );

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     aplicacion orden - remito                                                      //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   perform sp_doc_fac_cpra_orden_remito_save_aplic(v_fc_id, p_fcTMP_id, 0);

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     talonarios                                                                     //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   perform sp_talonario_set(v_ta_id, v_fc_nrodoc);

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     credito y estado                                                               //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   perform sp_doc_factura_compra_set_pendiente(v_fc_id);

   perform sp_doc_factura_compra_set_credito(v_fc_id);

   perform sp_doc_factura_compra_set_estado(v_fc_id);

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     asiento                                                                        //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   v_cfg_valor := null;
   select sp_cfg_getValor('Compras-General', 'Grabar Asiento') into v_cfg_valor;

   v_cfg_valor := coalesce(v_cfg_valor, '0');

   if to_number(v_cfg_valor) <> 0 then

      select * from sp_doc_factura_compra_asiento_save(v_fc_id, 0) into v_error, v_error_msg;
      if coalesce(v_error, 0) <> 0 then
         raise exception '%', v_error_msg;
      end if;

   else

      if not exists ( select fc_id
                      from FacturaCompraAsiento
                      where fc_id = v_fc_id ) then

         insert into FacturaCompraAsiento
           ( fc_id, fc_fecha )
           ( select fc_id,
                    fc_fecha
             from FacturaCompra
             where fc_grabarAsiento <> 0
               and fc_id = v_fc_id );

      end if;

   end if;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     stock                                                                          //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   if coalesce(v_doc_mueveStock, 0) <> 0 then

      select * from sp_doc_factura_compra_stock_save(p_fcTMP_id, v_fc_id, v_depl_id, 0) into v_error, v_error_msg;
      if coalesce(v_error, 0) <> 0 then
         raise exception '%', v_error_msg;
      end if;

   end if;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                          total comercial - necesario para los reportes de cta cte                                  //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   update facturacompra set fc_totalcomercial = coalesce(v_fc_totaldeuda, 0) where fc_id = v_fc_id;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     generacion automatica de orden de pago																										               //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   select * from sp_doc_factura_compra_orden_pago_save(v_fc_id) into v_success, v_error_msg;
   if coalesce(v_success, 0) = 0 then
      raise exception '%', v_error_msg;
   end if;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     validaciones al documento                                                      //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   -- estado
   --
   select * from sp_auditoria_estado_check_doc_fC(v_fc_id) into v_success, v_error_msg;
   if coalesce(v_success, 0) = 0 then
      raise exception '%', v_error_msg;
   end if;

   -- stock
   --
   select * from sp_auditoria_stock_check_doc_fc(v_fc_id) into v_success, v_error_msg;
   if coalesce(v_success, 0) = 0 then
      raise exception '%', v_error_msg;
   end if;

   -- totales
   --
   select * from sp_auditoria_totales_check_doc_fc(v_fc_id) into v_success, v_error_msg;
   if coalesce(v_success, 0) = 0 then
      raise exception '%', v_error_msg;
   end if;

   -- vtos
   --
   select * from sp_auditoria_vto_check_doc_fc(v_fc_id) into v_success, v_error_msg;
   if coalesce(v_success, 0) = 0 then
      raise exception '%', v_error_msg;
   end if;

   -- credito
   --
   select * from sp_auditoria_credito_check_doc_fc(v_fc_id) into v_success, v_error_msg;
   if coalesce(v_success, 0) = 0 then
      raise exception '%', v_error_msg;
   end if;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     borrar temporales                                                              //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   delete from RemitoFacturaCompraTMP where fcTMP_ID = p_fcTMP_ID;
   delete from OrdenFacturaCompraTMP where fcTMP_ID = p_fcTMP_ID;
   delete from FacturaCompraItemSerieTMP where fcTMP_id = p_fcTMP_id;
   delete from FacturaCompraPercepcionTMP where fcTMP_id = p_fcTMP_id;
   delete from FacturaCompraLegajoTMP where fcTMP_id = p_fcTMP_id;
   delete from FacturaCompraOtroTMP where fcTMP_id = p_fcTMP_id;
   delete from FacturaCompraItemTMP where fcTMP_id = p_fcTMP_id;
   delete from FacturaCompraItemSerieBTMP where fcTMP_id = p_fcTMP_id;

   /*OJO: esta aca y no en el if (if @IsNew = 0 begin)
          como estaba antes, por que necesito usar
          los registros de esta tabla en
          sp_DocRemitoCompraStockSave para borrar los
          numeros de serie asociados al r‚nglon
   */
   delete from FacturaCompraItemBorradoTMP where fc_id = v_fc_id and fcTMP_id = p_fcTMP_id;

   delete from FacturaCompraTMP where fcTMP_id = p_fcTMP_id;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     historial de modificaciones                                                    //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   select modifico into v_modifico from FacturaCompra where fc_id = v_fc_id;

   if v_is_new <> 0 then
      perform sp_historia_update(17001, v_fc_id, v_modifico, 1);
   else
      perform sp_historia_update(17001, v_fc_id, v_modifico, 3);
   end if;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     fin                                                                            //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   rtn.type := 'fc_id';
   rtn.id := v_fc_id;

   return next rtn;

   perform sp_lista_precio_save_auto(v_fc_id, v_doct_id, v_is_new, v_fc_fecha);

exception
   when others then

     raise exception 'Ha ocurrido un error al grabar la factura de compra. sp_doc_factura_compra_save. %. %.',
                      sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_compra_save(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_compra_set_pendiente()

-- drop function sp_doc_factura_compra_set_pendiente(integer);

create or replace function sp_doc_factura_compra_set_pendiente
(
  in p_fc_id integer
)
  returns void as
$BODY$
declare
   v_fc_pendiente decimal(18,6);
begin

   SET TRANSACTION READ WRITE;

   select sum(fcd_pendiente)
     into v_fc_pendiente
   from FacturaCompraDeuda
   where fc_id = p_fc_id;

   v_fc_pendiente := coalesce(v_fc_pendiente, 0);

   update FacturaCompra
      set fc_pendiente = round(v_fc_pendiente, 2)
   where fc_id = p_fc_id;

exception
   when others then

      raise exception 'Ha ocurrido un error al actualizar el pendiente de la factura de Compra. sp_doc_factura_compra_set_pendiente. %. %.',
                      sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_compra_set_pendiente(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_cpra_set_item_pendiente()

-- drop function sp_doc_factura_cpra_set_item_pendiente(integer);

create or replace function sp_doc_factura_cpra_set_item_pendiente
(
  in p_fc_id integer
)
  returns void as
$BODY$
declare
   v_fci_id integer;
   v_est_id integer;

   v_aplicadoorden decimal(18,6);
   v_aplicadoremito decimal(18,6);
begin

   select est_id
     into v_est_id
   from FacturaCompra
   where fc_id = p_fc_id;

   SET TRANSACTION READ WRITE;

   if v_est_id <> 7 then

      for v_fci_id in
         select fci_id
         from FacturaCompraItem
         where fc_id = p_fc_id
      loop

         select coalesce(sum(ocfc_cantidad), 0)
           into v_aplicadoorden
         from OrdenFacturaCompra
         where fci_id = v_fci_id;

         select coalesce(sum(rcfc_cantidad), 0)
           into v_aplicadoremito
         from RemitoFacturaCompra
         where fci_id = v_fci_id;

         v_aplicadoorden := coalesce(v_aplicadoorden, 0);
         v_aplicadoremito := coalesce(v_aplicadoremito, 0);

         update FacturaCompraItem
            set fci_pendiente = fci_cantidadaremitir - v_aplicadoorden - v_aplicadoremito
         where fci_id = v_fci_id;

      end loop;

   else

      update FacturaCompraItem
         set fci_pendiente = 0
      where fc_id = p_fc_id;

   end if;

exception
   when others then

   raise exception 'Ha ocurrido un error al actualizar el pendiente de la factura de compra. sp_doc_factura_cpra_set_item_pendiente. %. %.',
                   sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_cpra_set_item_pendiente(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_orden_compra_set_estado()

-- drop function sp_doc_orden_compra_set_estado(integer, integer);

create or replace function sp_doc_orden_compra_set_estado
(
  in p_oc_id integer,
  out p_est_id integer
)
  returns integer as
$BODY$
declare
   v_est_id integer;
   v_prov_id integer;
   v_pendiente decimal(18,6);
   v_creditoTotal decimal(18,6);
   v_llevaFirma smallint;
   v_firmado smallint;
   v_deuda decimal(18,6);
   v_doc_id integer;
   v_doc_llevafirma smallint;

   v_estado_pendiente integer := 1;
   v_estado_pendienteCredito integer := 3;
   v_estado_pendienteFirma integer := 4;
   v_estado_finalizado integer := 5;
   v_estado_anulado integer := 7;
begin

   if p_oc_id = 0 then
      return;
   end if;

   select prov_id,
          oc_firmado,
          est_id,
          doc_id
     into v_prov_id,
          v_firmado,
          v_est_id,
          v_doc_id
   from OrdenCompra
   where oc_id = p_oc_id;

   select doc_llevafirma
     into v_doc_llevafirma
   from Documento
   where doc_id = v_doc_id;

   if v_est_id <> v_estado_anulado then

      -- si el documento requiere firma y el comprobante no esta firmado
      -- y no esta finalizado (puede ser que se finalizo y luego se modifico el documento
      -- para que requiera firma en cuyo caso no se exige firma para documentos finalizados)
      --
      if v_firmado = 0 and v_doc_llevafirma <> 0 and v_est_id <> v_estado_finalizado then

         v_est_id := v_estado_pendienteFirma;

      else

         -- se obtiene la deuda del comprobante
         --
         select round(sum(oci_pendientefac), 2)
           into v_deuda
         from OrdenCompraItem
         where oc_id = p_oc_id;

         -- si el comprobante no tiene deuda se finaliza
         --
         if coalesce(v_deuda, 0) <= 0 then

            v_est_id := v_estado_finalizado;

         else

            -- se obtiene la deuda del Proveedor
            --
            select sum(provcc_importe)
              into v_pendiente
            from ProveedorCacheCredito
            where prov_id = v_prov_id;

            -- se obtiene el credito del Proveedor
            --
            select prov_creditototal
              into v_creditoTotal
            from Proveedor
            where prov_id = v_prov_id;

            -- si debe mas que el credito concedido al Proveedor
            --
            if v_pendiente > v_creditoTotal then

               v_est_id := v_estado_pendienteCredito;

            -- sino solo pendiente
            --
            else

               v_est_id := v_estado_pendiente;

            end if;

         end if;

      end if;

      update OrdenCompra
         set est_id = v_est_id
      where oc_id = p_oc_id;

   end if;

   p_est_id := v_est_id;

exception
   when others then

   raise exception 'Ha ocurrido un error al actualizar el estado de la orden de compra. sp_doc_orden_compra_set_estado. %. %.',
                   sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_orden_compra_set_estado(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_orden_compra_set_pendiente()

-- drop function sp_doc_orden_compra_set_pendiente(integer);

create or replace function sp_doc_orden_compra_set_pendiente
(
  in p_oc_id integer
)
  returns void as
$BODY$
declare
   v_oc_pendiente decimal(18,6);
begin

   SET TRANSACTION READ WRITE;

   perform sp_doc_orden_cpra_set_item_pendiente(p_oc_id);

   select sum(oci_pendientefac * (oci_importe / oci_cantidad))
     into v_oc_pendiente
   from OrdenCompraItem
   where oc_id = p_oc_id;

   v_oc_pendiente := coalesce(v_oc_pendiente, 0);

   update OrdenCompra
      set oc_pendiente = round(v_oc_pendiente, 2)
   where oc_id = p_oc_id;

exception
   when others then

   raise exception 'Ha ocurrido un error al actualizar el pendiente del Orden de compra. sp_doc_orden_compra_set_pendiente. %. %.',
                   sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_orden_compra_set_pendiente(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_remito_compra_set_credito()

-- drop function sp_doc_remito_compra_set_credito(integer, integer);

create or replace function sp_doc_remito_compra_set_credito
(
  in p_rc_id integer,
  in p_borrar integer default 0
)
  returns void as
$BODY$
declare
   v_pendiente decimal(18,6);
   v_prov_id integer;
   v_doct_id integer;
   v_emp_id integer;
   v_desc1 decimal(18,6);
   v_desc2 decimal(18,6);
   v_doct_remitocompra integer := 4;

   v_old_prov_ids integer[];
   i integer;
begin

   -- si no hay documento adios
   --
   if p_rc_id = 0 then
      return;
   end if;

   select rc.prov_id,
          case
             when rc.rc_cotizacion > 0 then round(rc.rc_pendiente, 2) * rc.rc_cotizacion
             else round(rc.rc_pendiente, 2)
          end,
          rc.doct_id,
          doc.emp_id,
          rc.rc_descuento1,
          rc.rc_descuento2
     into v_prov_id,
          v_pendiente,
          v_doct_id,
          v_emp_id,
          v_desc1,
          v_desc2
   from RemitoCompra rc
   join Documento doc
     on rc.doc_id = doc.doc_id
   where rc.rc_id = p_rc_id;

   v_pendiente := coalesce(v_pendiente, 0) - (coalesce(v_pendiente, 0) * v_desc1 / 100);
   v_pendiente := coalesce(v_pendiente, 0) - (coalesce(v_pendiente, 0) * v_desc2 / 100);

   -- borrar referencias a este documento por otro cliente
   --
   -- siempre borro cualquier mencion a este documento en el cache de cualquier
   -- proveedor que no sea el indicado por el documento
   --
   if exists ( select prov_id
               from ProveedorCacheCredito
               where prov_id <> v_prov_id
                 and doct_id = v_doct_remitocompra
                 and id = p_rc_id ) then

      select into v_old_prov_ids prov_id
      from ProveedorCacheCredito
      where prov_id <> v_prov_id
        and doct_id = v_doct_remitocompra
        and id = p_rc_id;

      delete from ProveedorCacheCredito
      where prov_id <> v_prov_id
        and doct_id = v_doct_remitocompra
        and id = p_rc_id;

      for i in 1 .. array_upper(v_old_prov_ids, 1)
      loop

         perform sp_proveedor_update_remito_credito(v_old_prov_ids[i], v_emp_id);

      end loop;

   end if;

   -- borrar
   --
   if p_borrar <> 0 then

      delete from ProveedorCacheCredito
      where prov_id = v_prov_id
        and doct_id = v_doct_remitocompra
        and id = p_rc_id;

   -- insert - update
   --
   else

      if v_doct_id = 25 then /* devolucion */
         v_pendiente := -v_pendiente;
      end if;

      if exists ( select id
                  from ProveedorCacheCredito
                  where prov_id = v_prov_id
                    and doct_id = v_doct_remitocompra
                    and id = p_rc_id ) then

         if abs(v_pendiente) >= 0.01 then

            update ProveedorCacheCredito
               set provcc_importe = v_pendiente
            where prov_id = v_prov_id
              and doct_id = v_doct_remitocompra
              and id = p_rc_id;

         -- si no hay nada pendiente lo saco del cache
         --
         else

            delete from ProveedorCacheCredito
            where prov_id = v_prov_id
              and doct_id = v_doct_remitocompra
              and id = p_rc_id;

         end if;

      else

         -- solo si hay algo pendiente
         --
         if abs(v_pendiente) >= 0.01 then

            insert into ProveedorCacheCredito( prov_id, doct_id, id, provcc_importe, emp_id )
            values ( v_prov_id, v_doct_remitocompra, p_rc_id, v_pendiente, v_emp_id );

         end if;

      end if;

   end if;

   -- deuda en cache
   --

   -- actualizo la deuda en la tabla cliente
   --
   perform sp_proveedor_update_remito_credito(v_prov_id, v_emp_id);

exception
   when others then

      raise exception 'Ha ocurrido un error al actualizar el estado del remito de compra. sp_doc_remito_compra_set_credito. %. %.',
                      sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_remito_compra_set_credito(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_remito_compra_set_estado()

-- drop function sp_doc_remito_compra_set_estado(integer, integer);

create or replace function sp_doc_remito_compra_set_estado
(
  in p_rc_id integer,
  out p_est_id integer
)
  returns integer as
$BODY$
declare
   v_est_id integer;
   v_prov_id integer;
   v_pendiente decimal(18,6);
   v_creditoTotal decimal(18,6);
   v_llevaFirma smallint;
   v_firmado smallint;
   v_deuda decimal(18,6);
   v_doc_id integer;
   v_doc_llevafirma smallint;

   v_estado_pendiente integer := 1;
   v_estado_pendienteCredito integer := 3;
   v_estado_pendienteFirma integer := 4;
   v_estado_finalizado integer := 5;
   v_estado_anulado integer := 7;
begin

   if p_rc_id = 0 then
      return;
   end if;

   select prov_id,
          rc_firmado,
          est_id,
          doc_id
     into v_prov_id,
          v_firmado,
          v_est_id,
          v_doc_id
   from RemitoCompra
   where rc_id = p_rc_id;

   select doc_llevafirma
     into v_doc_llevafirma
   from Documento
   where doc_id = v_doc_id;

   if v_est_id <> v_estado_anulado then

      -- si el documento requiere firma y el comprobante no esta firmado
      -- y no esta finalizado (puede ser que se finalizo y luego se modifico el documento
      -- para que requiera firma en cuyo caso no se exige firma para documentos finalizados)
      --
      if v_firmado = 0 and v_doc_llevafirma <> 0 and v_est_id <> v_estado_finalizado then

         v_est_id := v_estado_pendienteFirma;

      else

         -- se obtiene la deuda del comprobante
         --
         select round(sum(rci_pendientefac), 2)
           into v_deuda
         from RemitoCompraItem
         where rc_id = p_rc_id;

         -- si el comprobante no tiene deuda se finaliza
         --
         if coalesce(v_deuda, 0) <= 0 then

            v_est_id := v_estado_finalizado;

         else

            -- se obtiene la deuda del proveedor
            --
            select sum(provcc_importe)
              into v_pendiente
            from ProveedorCacheCredito
            where prov_id = v_prov_id;

            -- se obtiene el credito del proveedor
            --
            select prov_creditototal
              into v_creditoTotal
            from Proveedor
            where prov_id = v_prov_id;

            -- si debe mas que el credito concedido al proveedor
            --
            if v_pendiente > v_creditoTotal then

               v_est_id := v_estado_pendienteCredito;

            -- sino solo pendiente
            --
            else

               v_est_id := v_estado_pendiente;

            end if;

         end if;

      end if;

      update RemitoCompra
         set est_id = v_est_id
      where rc_id = p_rc_id;

   end if;

   p_est_id := v_est_id;

exception
   when others then

   raise exception 'Ha ocurrido un error al actualizar el estado del Remito de compra. sp_doc_remito_compra_set_estado. %. %.',
                   sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_remito_compra_set_estado(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_remito_compra_set_pendiente()

-- drop function sp_doc_remito_compra_set_pendiente(integer);

create or replace function sp_doc_remito_compra_set_pendiente
(
  in p_rc_id integer
)
  returns void as
$BODY$
declare
   v_rc_pendiente decimal(18,6);
begin

   SET TRANSACTION READ WRITE;

   perform sp_doc_remito_cpra_set_item_pendiente(p_rc_id);

   select sum(rci_pendientefac * (rci_importe / rci_cantidadaremitir))
     into v_rc_pendiente
   from RemitoCompraItem
   where rc_id = p_rc_id;

   v_rc_pendiente := coalesce(v_rc_pendiente, 0);

   update RemitoCompra
      set rc_pendiente = round(v_rc_pendiente, 2)
   where rc_id = p_rc_id;

exception
   when others then

      raise exception 'Ha ocurrido un error al actualizar el pendiente del remito de compra. sp_doc_remito_compra_set_pendiente. %. %.',
                      sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_remito_compra_set_pendiente(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_remito_cpra_set_item_pendiente()

-- drop function sp_doc_remito_cpra_set_item_pendiente(integer);

create or replace function sp_doc_remito_cpra_set_item_pendiente
(
  in p_rc_id integer
)
  returns void as
$BODY$
declare
   v_rci_id integer;
   v_doct_id integer;
   v_est_id integer;
   v_aplicadoOrden decimal(18,6);
   v_aplicadoRemito decimal(18,6);
begin

   select doct_id,
          est_id
     into v_doct_id,
          v_est_id
   from RemitoCompra
   where rc_id = p_rc_id;

   SET TRANSACTION READ WRITE;

   if v_est_id <> 7 then

      for v_rci_id in
         select rci_id
         from RemitoCompraItem
         where rc_id = p_rc_id
      loop

         select coalesce(sum(ocrc_cantidad), 0)
           into v_aplicadoOrden
         from OrdenRemitoCompra
         where rci_id = v_rci_id;

         select coalesce(sum(rcfc_cantidad), 0)
           into v_aplicadoRemito
         from RemitoFacturaCompra
         where rci_id = v_rci_id;

         if v_doct_id = 4 then

            select coalesce(v_aplicadoRemito, 0) + coalesce(sum(rcdc_cantidad), 0)
              into v_aplicadoRemito
            from RemitoDevolucionCompra
            where rci_id_remito = v_rci_id;

         else

            select coalesce(v_aplicadoRemito, 0) + coalesce(sum(rcdc_cantidad), 0)
              into v_aplicadoRemito
            from RemitoDevolucionCompra
            where rci_id_devolucion = v_rci_id;

         end if;

         v_aplicadoOrden := coalesce(v_aplicadoOrden, 0);
         v_aplicadoRemito := coalesce(v_aplicadoRemito, 0);

         update RemitoCompraItem
            set rci_pendiente = rci_cantidad - v_aplicadoOrden,
                rci_pendientefac = rci_cantidadaremitir - v_aplicadoRemito
         where rci_id = v_rci_id;

      end loop;

   else

      update RemitoCompraItem
         set rci_pendiente = 0,
             rci_pendientefac = 0
      where rc_id = p_rc_id;

   end if;


exception
   when others then

      raise exception 'Ha ocurrido un error al actualizar el pendiente del remito de compra. sp_doc_remito_cpra_set_item_pendiente.%. %.',
                      sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_remito_cpra_set_item_pendiente(integer)
  owner to postgres;
  /*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_lsdoc_facturas_compra()

-- drop function sp_lsdoc_facturas_compra(integer, date, date, varchar, varchar, varchar, varchar, varchar, varchar, varchar);

create or replace function sp_lsdoc_facturas_compra
/*
select * from FacturaCompra

select * from sp_lsdoc_facturas_compra(
1,
'20000101'::date,
'20150101'::date,
'0',
'0',
'0',
'0',
'0',
'0',
'0');
fetch all from rtn;
*/
(
  in p_us_id integer,
  in p_Fini date,
  in p_Ffin date,
  in p_prov_id varchar,
  in p_est_id varchar,
  in p_ccos_id varchar,
  in p_suc_id varchar,
  in p_doc_id varchar,
  in p_cpg_id varchar,
  in p_emp_id varchar,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_prov_id integer;
   v_ccos_id integer;
   v_suc_id integer;
   v_est_id integer;
   v_doc_id integer;
   v_cpg_id integer;
   v_emp_id integer;
   v_ram_id_Proveedor integer;
   v_ram_id_CentroCosto integer;
   v_ram_id_Sucursal integer;
   v_ram_id_Estado integer;
   v_ram_id_Vendedor integer;
   v_ram_id_Documento integer;
   v_ram_id_CondicionPago integer;
   v_ram_id_Empresa integer;
   v_clienteID integer;
   v_IsRaiz smallint;
begin

/*debug
p_us_id := 1;
p_Fini := '20000101'::date;
p_Ffin := '20150101'::date;
p_prov_id := '0';
p_est_id := '0';
p_ccos_id := '0';
p_suc_id := '0';
p_doc_id := '0';
p_cpg_id := '0';
p_emp_id := '0';
end debug*/

   rtn := 'rtn';

   /*- ///////////////////////////////////////////////////////////////////////
    INICIO PRIMERA PARTE DE ARBOLES
   /////////////////////////////////////////////////////////////////////// */

   select * from sp_ArbConvertId(p_prov_id) into v_prov_id, v_ram_id_Proveedor;

   select * from sp_ArbConvertId(p_ccos_id) into v_ccos_id, v_ram_id_CentroCosto;

   select * from  sp_ArbConvertId(p_suc_id) into v_suc_id, v_ram_id_Sucursal;

   select * from  sp_ArbConvertId(p_est_id) into v_est_id, v_ram_id_Estado;

   select * from  sp_ArbConvertId(p_doc_id) into v_doc_id, v_ram_id_Documento;

   select * from  sp_ArbConvertId(p_cpg_id) into v_cpg_id, v_ram_id_CondicionPago;

   select * from  sp_ArbConvertId(p_emp_id) into v_emp_id, v_ram_id_Empresa;

   select * from  sp_GetRptId() into v_clienteID;

   if v_ram_id_Proveedor <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Proveedor, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Proveedor) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Proveedor,
                           v_clienteID);

      end;
      else
         v_ram_id_Proveedor := 0;

      end if;

   end;
   end if;

   if v_ram_id_CentroCosto <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_CentroCosto, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_CentroCosto) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_CentroCosto,
                           v_clienteID);

      end;
      else
         v_ram_id_CentroCosto := 0;

      end if;

   end;
   end if;

   if v_ram_id_Estado <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Estado, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Estado) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Estado,
                           v_clienteID);

      end;
      else
         v_ram_id_Estado := 0;

      end if;

   end;
   end if;

   if v_ram_id_Sucursal <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Sucursal, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Sucursal) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Sucursal,
                           v_clienteID);

      end;
      else
         v_ram_id_Sucursal := 0;

      end if;

   end;
   end if;

   if v_ram_id_Vendedor <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Vendedor, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Vendedor) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Vendedor,
                           v_clienteID);

      end;
      else
         v_ram_id_Vendedor := 0;

      end if;

   end;
   end if;

   if v_ram_id_Documento <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Documento, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Documento) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Documento,
                           v_clienteID);

      end;
      else
         v_ram_id_Documento := 0;

      end if;

   end;
   end if;

   if v_ram_id_CondicionPago <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_CondicionPago, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_CondicionPago) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_CondicionPago,
                           v_clienteID);

      end;
      else
         v_ram_id_CondicionPago := 0;

      end if;

   end;
   end if;

   if v_ram_id_Empresa <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Empresa, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Empresa) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Empresa,
                           v_clienteID);

      end;
      else
         v_ram_id_Empresa := 0;

      end if;

   end;
   end if;

   /*- ///////////////////////////////////////////////////////////////////////
    FIN PRIMERA PARTE DE ARBOLES
   /////////////////////////////////////////////////////////////////////// */

   open rtn for

      select fc_id,
             '' TypeTask,
             fc_numero Numero,
             fc_nrodoc Comprobante,
             prov_nombre Proveedor,
             doc_nombre Documento,
             est_nombre Estado,
             case fc_tipocomprobante
                when 1 then 'Original'
                when 2 then 'Fax'
                when 3 then 'Fotocopia'
                when 4 then 'Duplicado'
             end Tipo_Comprobante,
             fc_fecha Fecha,
             fc_fechaentrega Fecha_de_entrega,
             fc_fechaiva Fecha_IVA,
             fc_neto Neto,
             fc_ivari IVA_RI,
             fc_ivarni IVA_RNI,
             fc_totalotros Otros,
             fc_subtotal Subtotal,
             fc_total Total,
             fc_pendiente Pendiente,
             case fc_firmado
                when 0 then 'No'
                else 'Si'
             end Firmado,
             fc_descuento1 Desc_1,
             fc_descuento2 Desc_2,
             fc_importedesc1 Desc_1,
             fc_importedesc2 Desc_2,
             lp_nombre Lista_de_Precios,
             ld_nombre Lista_de_descuentos,
             cpg_nombre Condicion_de_Pago,
             ccos_nombre Centro_de_costo,
             suc_nombre Sucursal,
             emp_nombre Empresa,
             FacturaCompra.creado,
             FacturaCompra.modificado,
             us_nombre Modifico,
             fc_descrip Observaciones
        from FacturaCompra
        join Documento
          on FacturaCompra.doc_id = Documento.doc_id
        join Empresa
          on Documento.emp_id = Empresa.emp_id
        join CondicionPago
          on FacturaCompra.cpg_id = CondicionPago.cpg_id
        join Estado
          on FacturaCompra.est_id = Estado.est_id
        join Sucursal
          on FacturaCompra.suc_id = Sucursal.suc_id
        join Proveedor
          on FacturaCompra.prov_id = Proveedor.prov_id
        join Usuario
          on FacturaCompra.modifico = Usuario.us_id
        left join CentroCosto
          on FacturaCompra.ccos_id = CentroCosto.ccos_id
        left join ListaPrecio
          on FacturaCompra.lp_id = ListaPrecio.lp_id
        left join ListaDescuento
          on FacturaCompra.ld_id = ListaDescuento.ld_id
        where p_Fini <= fc_fecha
          and p_Ffin >= fc_fecha

        /* -///////////////////////////////////////////////////////////////////////
        INICIO SEGUNDA PARTE DE ARBOLES
        /////////////////////////////////////////////////////////////////////// */

          and ( Proveedor.prov_id = v_prov_id
          or v_prov_id = 0 )
          and ( Estado.est_id = v_est_id
          or v_est_id = 0 )
          and ( Sucursal.suc_id = v_suc_id
          or v_suc_id = 0 )
          and ( Documento.doc_id = v_doc_id
          or v_doc_id = 0 )
          and ( CondicionPago.cpg_id = v_cpg_id
          or v_cpg_id = 0 )
          and ( FacturaCompra.ccos_id = v_ccos_id
          or v_ccos_id = 0
          or exists ( select *
                      from FacturaCompraItem fci
                         where fci.fc_id = FacturaCompra.fc_id
                                 and fci.ccos_id = v_ccos_id ) )
          and ( Empresa.emp_id = v_emp_id
          or v_emp_id = 0 )
          -- Arboles
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 29
                                      and rptarb_hojaid = Proveedor.prov_id ) )
          or ( v_ram_id_Proveedor = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 21
                                      and ( rptarb_hojaid = FacturaCompra.ccos_id
                                      or exists ( select *
                                                  from FacturaCompraItem fci
                                                     where fci.fc_id = FacturaCompra.fc_id
                                                             and fci.ccos_id = rptarb_hojaid ) ) ) )
          or ( v_ram_id_CentroCosto = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 4005
                                      and rptarb_hojaid = Estado.est_id ) )
          or ( v_ram_id_Estado = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 1007
                                      and rptarb_hojaid = Sucursal.suc_id ) )
          or ( v_ram_id_Sucursal = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 4001
                                      and rptarb_hojaid = Documento.doc_id ) )
          or ( v_ram_id_Documento = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 1005
                                      and rptarb_hojaid = CondicionPago.cpg_id ) )
          or ( v_ram_id_CondicionPago = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 1018
                                      and rptarb_hojaid = Empresa.emp_id ) )
          or ( v_ram_id_Empresa = 0 ) )

        order by fc_fecha;

end;
$BODY$
  language plpgsql volatile
  cost 100;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_asiento_get()

-- drop function sp_doc_asiento_get(integer, integer, integer);
/*
select * from sp_doc_asiento_get(1,1,1);
fetch all from rtn;
*/
create or replace function sp_doc_asiento_get
(
  in p_emp_id integer,
  in p_as_id integer,
  in p_us_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_editable integer;
   v_edit_msg varchar(255);
   v_doc_id integer;
   v_ta_mascara varchar(100);
   v_ta_propuesto smallint;
begin

   rtn := 'rtn';

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                             TALONARIO Y ESTADO DE EDICION                                                          //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
   select doc_id into v_doc_id from Asiento where as_id = p_as_id;

   select * from sp_talonario_get_propuesto(v_doc_id) into v_ta_mascara, v_ta_propuesto;

   select * from sp_doc_asiento_editable_get(p_emp_id, p_as_id, p_us_id) into v_editable, v_edit_msg;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                             select                                                                                 //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   open rtn for

      select ast.*,
             doct.doct_nombre || ' ' || ast.as_doc_cliente doc_cliente,
             doc.doc_nombre,
             v_editable editable,
             v_edit_msg editMsg,
             v_ta_mascara ta_mascara,
             v_ta_propuesto ta_propuesto
      from Asiento ast
      join Documento doc
        on ast.doc_id = doc.doc_id
      left join DocumentoTipo doct
        on ast.doct_id_cliente = doct.doct_id
      where ast.as_id = p_as_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_asiento_get(integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_asiento_get_items()

-- drop function sp_doc_asiento_get_items(integer);
/*
select * from sp_doc_asiento_get_items(1);
fetch all from rtn;
fetch all from rtn_serie;
*/
create or replace function sp_doc_asiento_get_items
/*
sp_DocAsientoGetItems 1
*/
(
  in p_as_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
begin

   rtn := 'rtn';

   open rtn for
      select AsientoItem.*,
          cue_nombre,
          ccos.ccos_nombre
      from AsientoItem
      join Cuenta
        on AsientoItem.cue_id = Cuenta.cue_id
      left join CentroCosto ccos
        on AsientoItem.ccos_id = ccos.ccos_id
      where as_id = p_as_id
      order by asi_orden;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_asiento_get_items(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_asiento_save()

-- drop function sp_doc_asiento_save(integer, integer);

create or replace function sp_doc_asiento_save
(
  in p_us_id integer,
  in p_asTMP_id integer
)
  returns setof row_result as
$BODY$
declare
   rtn row_result;

   v_error_msg varchar(255);
   v_error smallint;
   v_cfg_valor varchar(5000);

   v_is_new integer;
   v_orden smallint;

   v_as_id integer;
   v_as_numero integer;
   v_as_nrodoc varchar(50);
   v_as_descrip varchar(5000);
   v_as_fecha date;

   v_asi_id integer;
   v_asi_orden smallint;
   v_asi_descrip varchar(5000);
   v_asi_debe decimal(18,6);
   v_asi_haber decimal(18,6);
   v_asi_origen decimal(18,6);

   v_doc_id integer;
   v_doct_id integer;
   v_ta_id integer;
   v_ccos_id integer;
   v_cue_id integer;
   v_mon_id integer;

   v_creado date;
   v_modificado date;
   v_modifico integer;
   
   v_cue_nombre varchar(255);
   v_cuentas varchar(5000);
   v_error_msg_aux varchar(5000);

   v_ta_propuesto smallint;
   v_ta_tipo smallint;
   v_ta_nrodoc varchar(100);
   dummyChar varchar;
begin

   -- si no existe chau
   --
   if not exists ( select asTMP_id
                   from AsientoTMP
                   where asTMP_id = p_asTMP_id ) then

      return query select * from result_failed;
      return;

   end if;
   
   select sp_cfg_getValor('Compras-General', 'Exigir Centro Costo') into v_cfg_valor;

   v_cfg_valor := coalesce(v_cfg_valor, '0');

   if to_number(v_cfg_valor) <> 0 then

      if exists ( select asi.ccos_id
                  from AsientoItemTMP asi
                  join Cuenta cue
                    on asi.cue_id = cue.cue_id
                  where asi.ccos_id is null
                    and asi.asTMP_id = p_asTMP_id
                    and cue.cue_llevacentrocosto <> 0 ) then

         v_cuentas := '';

         for v_cue_nombre in 
             select distinct cue.cue_nombre
             from AsientoItemTMP asi
             join Cuenta cue
               on asi.cue_id = cue.cue_id
             where asi.ccos_id is null
               and asi.asTMP_id = p_asTMP_id
               and cue.cue_llevacentrocosto <> 0
         loop

               v_cuentas := v_cuentas || v_cue_nombre || ', ';

         end loop;

         if length(v_cuentas) > 0 then
            
            v_cuentas := substr(v_cuentas, 1, length(v_cuentas) - 1);

         end if;

         v_error_msg_aux := 'Debe indicar un centro de costo en cada las cuentas que exigen centro de costo.'
                            || CHR(10) || CHR(10) || 'Cuentas:' || CHR(10) || v_cuentas;

         raise exception '@@ERROR_SP: %', v_error_msg_aux;

      end if;

   end if;

   select as_id,
          as_nrodoc,
          doc_id
     into v_as_id,
          v_as_nrodoc,
          v_doc_id
   from AsientoTMP
   where asTMP_id = p_asTMP_id;

   v_as_id := coalesce(v_as_id, 0);

   set TRANSACTION READ WRITE;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                        insert                                                                      //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   if v_as_id = 0 then

      v_is_new := -1;

      select sp_dbGetNewId('Asiento', 'as_id') into v_as_id;
      select sp_dbGetNewId('Asiento', 'as_numero') into v_as_numero;

      select * from sp_talonario_get_propuesto(v_doc_id) into dummyChar, v_ta_propuesto, v_ta_id, v_ta_tipo;

      if v_ta_propuesto = 0 then
         if v_ta_tipo = 3 then /*Auto Impresor*/

            select sp_talonario_get_next_number(v_ta_id) into v_ta_nrodoc;

            -- con esto evitamos que dos tomen el mismo Numero
            --
            perform sp_talonario_set(v_ta_id, v_ta_nrodoc);

            v_as_nrodoc := v_ta_nrodoc;

         end if;
      end if;

      insert into Asiento
        ( as_id, as_numero, as_nrodoc, as_descrip, as_fecha, doc_id, doct_id, modifico )
        ( select v_as_id,
                 v_as_numero,
                 v_as_nrodoc,
                 as_descrip,
                 as_fecha,
                 doc_id,
                 doct_id,
                 modifico
          from AsientoTMP
          where asTMP_id = p_asTMP_id );

      select doc_id,
             as_nrodoc
        into v_doc_id,
             v_as_nrodoc
      from Asiento
      where as_id = v_as_id;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                        update                                                                      //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
   else

      v_is_new := 0;

      select as_id,
             as_nrodoc,
             as_descrip,
             as_fecha,
             doc_id,
             doct_id,
             modifico,
             modificado
        into v_as_id,
             v_as_nrodoc,
             v_as_descrip,
             v_as_fecha,
             v_doc_id,
             v_doct_id,
             v_modifico,
             v_modificado
      from AsientoTMP
      where asTMP_id = p_asTMP_id;

      update Asiento
         set as_nrodoc = v_as_nrodoc,
             as_descrip = v_as_descrip,
             as_fecha = v_as_fecha,
             doc_id = v_doc_id,
             doct_id = v_doct_id,
             modifico = v_modifico,
             modificado = v_modificado
      where as_id = v_as_id;

   end if;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                        items                                                                       //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
   v_orden := 1;

   while exists(select 1 from AsientoItemTMP where asTMP_id = p_asTMP_id and asi_orden = v_orden)
   loop

         select asi_id,
                asi_orden,
                asi_descrip,
                asi_debe,
                asi_haber,
                asi_origen,
                AsientoItemTMP.cue_id,
                ccos_id,
                mon_id
           into v_asi_id,
                v_asi_orden,
                v_asi_descrip,
                v_asi_debe,
                v_asi_haber,
                v_asi_origen,
                v_cue_id,
                v_ccos_id,
                v_mon_id
         from AsientoItemTMP
         join Cuenta
           on AsientoItemTMP.cue_id = Cuenta.cue_id
         where asTMP_id = p_asTMP_id
           and asi_orden = v_orden;

         if v_is_new <> 0 or v_asi_id = 0 then

            select sp_dbGetNewId('AsientoItem', 'asi_id') into v_asi_id;

            insert into AsientoItem
              ( as_id, asi_id, asi_orden, asi_descrip, asi_debe, asi_haber,
                asi_origen, cue_id, ccos_id, mon_id )
            values ( v_as_id, v_asi_id, v_asi_orden, v_asi_descrip, v_asi_debe, v_asi_haber,
                     v_asi_origen, v_cue_id, v_ccos_id, v_mon_id );

         else

               update AsientoItem
                  set as_id = v_as_id,
                      asi_orden = v_asi_orden,
                      asi_descrip = v_asi_descrip,
                      asi_debe = v_asi_debe,
                      asi_haber = v_asi_haber,
                      asi_origen = v_asi_origen,
                      cue_id = v_cue_id,
                      ccos_id = v_ccos_id,
                      mon_id = v_mon_id
               where as_id = v_as_id
                 and asi_id = v_asi_id;

         end if;

         v_orden := v_orden + 1;

   end loop;

   if v_is_new = 0 then

         delete from AsientoItem
         where exists ( select asi_id
                        from AsientoItemBorradoTMP
                        where as_id = v_as_id
                          and asTMP_id = p_asTMP_id
                          and asi_id = AsientoItem.asi_id );

         delete from AsientoItemBorradoTMP where as_id = v_as_id and asTMP_id = p_asTMP_id;

   end if;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     borrar temporales                                                              //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   delete from AsientoItemTMP where asTMP_ID = p_asTMP_id;
   delete from AsientoTMP where asTMP_ID = p_asTMP_id;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     valido el asiento                                                              //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   select * from sp_doc_asiento_validate(v_as_id) into v_error, v_error_msg;

   if v_error <> 0 then
      raise exception '%', v_error_msg;
   end if;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     talonario                                                                      //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   select ta_id
     into v_ta_id
   from Documento
   where doc_id = v_doc_id;

   perform sp_talonario_set(v_ta_id, v_as_nrodoc);


/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     historial de modificaciones                                                    //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   select modifico into v_modifico from Asiento where as_id = v_as_id;

   if v_is_new <> 0 then
      perform sp_historia_update(19001, v_as_id, v_modifico, 1);
   else
      perform sp_historia_update(19001, v_as_id, v_modifico, 3);
   end if;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                                     fin                                                                            //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

   rtn.type := 'as_id';
   rtn.id := v_as_id;

   return next rtn;

exception
  when others then

   raise exception 'Ha ocurrido un error al grabar el asiento. sp_doc_asiento_save. %. %.',
                   sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_asiento_save(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_asiento_validate()

-- drop function sp_doc_asiento_validate(integer);

create or replace function sp_doc_asiento_validate
(
  in p_as_id integer,
  out p_error integer,
  out p_error_msg varchar
)
  returns record as
$BODY$
declare
   v_debe decimal(18,6);
   v_haber decimal(18,6);
   v_strDebe varchar(255);
   v_strHaber varchar(255);

   v_asi_id integer;
   v_dif decimal(18,6);
begin

   select sum(asi_debe),
          sum(asi_haber)
     into v_debe,
          v_haber
   from AsientoItem
   where as_id = p_as_id;

   v_debe := round(coalesce(v_debe, 0), 2);
   v_haber := round(coalesce(v_haber, 0), 2);

   if v_debe <> v_haber then

      v_strDebe := sqlserver_utilities.convert_('varchar', v_debe, 1);
      v_strHaber := sqlserver_utilities.convert_('varchar', v_haber, 1);
      v_strDebe := substr(v_strDebe, 1, length(v_strDebe) - 4);
      v_strHaber := substr(v_strHaber, 1, length(v_strHaber) - 4);

      p_error := 1;
      p_error_msg := '@@ERROR_SP:El asiento no balancea:;;  Debe : ' || v_strDebe || ';  Haber: ' || v_strHaber || ';;';

   else

      update asientoitem
         set asi_debe = round(asi_debe, 2),
             asi_haber = round(asi_haber, 2)
      where as_id = p_as_id;

      select sum(asi.asi_debe) - sum(asi.asi_haber)
        into v_dif
      from Asiento ast
      join AsientoItem asi
        on ast.as_id = asi.as_id
      group by ast.as_id;

      if v_dif <> 0 then

         if v_dif < 0 then
            select min(asi_id)
              into v_asi_id
            from AsientoItem
            where as_id = p_as_id
              and asi_debe <> 0;

         else
            select min(asi_id)
              into v_asi_id
            from AsientoItem
            where as_id = p_as_id
              and asi_haber <> 0;

         end if;

         if v_asi_id is not null then

            if v_dif < 0 then

               update asientoitem
                  set asi_debe = asi_debe + abs(v_dif)
               where asi_id = v_asi_id;

            else

               update asientoitem
                  set asi_haber = asi_haber + abs(v_dif)
               where asi_id = v_asi_id;

            end if;

         end if;

      end if;

      delete from asientoitem
      where asi_debe = 0
        and asi_haber = 0
        and as_id = p_as_id;

      update asientoitem
         set asi_debe = abs(asi_haber),
             asi_haber = 0
      where asi_haber < 0
        and asi_debe = 0
        and as_id = p_as_id;

      update asientoitem
         set asi_haber = abs(asi_debe),
             asi_debe = 0
      where asi_debe < 0
        and asi_haber = 0
        and as_id = p_as_id;

      p_error := 0;

   end if;

end;
$BODY$
  language plpgsql volatile
  COST 100;
alter function sp_doc_asiento_validate(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_lsdoc_asientos()

-- drop function sp_lsdoc_asientos(integer, date, date, varchar, varchar);

create or replace function sp_lsdoc_asientos
/*
select * from Asiento

select * from sp_lsdoc_asientos(
1,
'20000101'::date,
'20150101'::date,
'0',
'0');
fetch all from rtn;
*/
(
  in p_us_id integer,
  in p_Fini date,
  in p_Ffin date,
  in p_doc_id varchar,
  in p_emp_id varchar,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_doc_id integer;
   v_emp_id integer;
   v_ram_id_Documento integer;
   v_ram_id_empresa integer;
   v_clienteID integer;
   v_IsRaiz smallint;
begin

   rtn := 'rtn';

   /*- ///////////////////////////////////////////////////////////////////////
    INICIO PRIMERA PARTE DE ARBOLES
   /////////////////////////////////////////////////////////////////////// */

   select * from sp_ArbConvertId(p_doc_id) into v_doc_id, v_ram_id_Documento;

   select * from sp_ArbConvertId(p_emp_id) into v_emp_id, v_ram_id_empresa;

   select * from  sp_GetRptId() into v_clienteID;

   if v_ram_id_Documento <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Documento, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Documento) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Documento,
                           v_clienteID);

      end;
      else
         v_ram_id_Documento := 0;

      end if;

   end;
   end if;

   if v_ram_id_empresa <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_empresa, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_empresa) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_empresa,
                           v_clienteID);

      end;
      else
         v_ram_id_empresa := 0;

      end if;

   end;
   end if;

   /*- ///////////////////////////////////////////////////////////////////////
    FIN PRIMERA PARTE DE ARBOLES
   /////////////////////////////////////////////////////////////////////// */

   open rtn for

      select as_id,
             '' TypeTask,
             as_numero N_mero,
             as_nrodoc Comprobante,
             doc_nombre Documento,
             as_fecha Fecha,
             case doct_id_cliente
                when 1  then 'Factura de Venta'
                when 2  then 'Factura de Compra'
                when 7  then 'Nota de Credito Venta'
                when 8  then 'Nota de Credito Compra'
                when 9  then 'Nota de Debito Venta'
                when 10 then 'Nota de Debito Compra'
                when 13 then 'Cobranza'
                when 16 then 'Orden de Pago'
                when 17 then 'Deposito Banco'
                when 26 then 'Movimiento de Fondos'
             end Tipo_Doc,
             as_doc_cliente Documento_Aux,
             emp_nombre Empresa,
             ( select sum(asi_debe)
               from AsientoItem
               where as_id = Asiento.as_id
                 and asi_debe <> 0 ) Total,
             Asiento.creado,
             Asiento.modificado,
             us_nombre Modifico,
             as_descrip Observaciones
        from Asiento
        join Documento
          on Asiento.doc_id = Documento.doc_id
        join Usuario
          on Asiento.modifico = Usuario.us_id
        join Empresa
          on Documento.emp_id = Empresa.emp_id
        where p_Fini <= as_fecha
          and p_Ffin >= as_fecha

        /* -///////////////////////////////////////////////////////////////////////
        INICIO SEGUNDA PARTE DE ARBOLES
        /////////////////////////////////////////////////////////////////////// */
        
          and ( Documento.doc_id = v_doc_id
          or v_doc_id = 0 )
          and ( Empresa.emp_id = v_emp_id
          or v_emp_id = 0 )
          -- Arboles
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 4001
       
                                      and rptarb_hojaid = Documento.doc_id ) )
          or ( v_ram_id_Documento = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 1018
       
                                      and rptarb_hojaid = Empresa.emp_id ) )
          or ( v_ram_id_empresa = 0 ) )
          
        order by as_fecha;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_lsdoc_asientos(integer, date, date, varchar, varchar)
  owner to postgres;

/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cliente_get_info()

-- drop function sp_cliente_get_info(integer, integer);

create or replace function sp_cliente_get_info
/*
    select * from documento where doct_id in (2,8,10);
    select * from sp_cliente_get_info(2,20);
    select * from sp_cliente_get_iva(2,0::smallint);
*/
(
  in p_cli_id integer,
  in p_doc_id integer,

  out p_cpg_id integer,
  out p_cpg_name varchar,
  out p_cpg_eslibre smallint,
  out p_lp_id integer,
  out p_lp_name varchar,
  out p_ld_id integer,
  out p_ld_name varchar,
  out p_bIvari smallint,
  out p_bIvarni smallint
)
  returns record as
$BODY$
declare
      v_cpg_id integer;
      v_cpg_name varchar;
      v_cpg_eslibre integer;
      v_lp_id integer;
      v_lp_name varchar;
      v_ld_id integer;
      v_ld_name varchar;
      v_mon_id integer;
begin


      select lp_id,
             ld_id,
             cpg_id
        into v_lp_id,
             v_ld_id,
             v_cpg_id
      from cliente
      where cli_id = p_cli_id;

      select mon_id into v_mon_id from Documento where doc_id = p_doc_id;

      if v_lp_id is not null then

         if not exists ( select *
                         from ListaPrecio
                         where lp_id = v_lp_id
                           and mon_id = v_mon_id
                           and lp_tipo = 1 ) then
            v_lp_id := null;
         end if;

      end if;

      if v_lp_id is null then

         select min(lp_id)
           into v_lp_id
         from ListaPrecio
         where mon_id = v_mon_id
           and lp_tipo = 1
           and lp_default <> 0;

      end if;

      if v_ld_id is not null then

         if not exists ( select *
                         from ListaDescuento
                         where ld_id = v_ld_id
                           and mon_id = v_mon_id
                           and ld_tipo = 1 ) then

            v_ld_id := null;

         end if;

      end if;

      if v_lp_id is not null then
        select lp_nombre into v_lp_name from listaprecio where lp_id = v_lp_id;
      end if;

      if v_ld_id is not null then
        select ld_nombre into v_ld_name from listadescuento where ld_id = v_ld_id;
      end if;

      if v_cpg_id is not null then
        select cpg_nombre, cpg_eslibre into v_cpg_name, v_cpg_eslibre from condicionpago where cpg_id = v_cpg_id;
      end if;

      select * from sp_cliente_get_iva(p_cli_id) into p_bIvari, p_bIvarni;

      p_lp_id := coalesce(v_lp_id, 0);
      p_lp_name := coalesce(v_lp_name, '');
      p_ld_id := coalesce(v_ld_id, 0);
      p_ld_name := coalesce(v_ld_name, '');
      p_cpg_id := coalesce(v_cpg_id, 0);
      p_cpg_name := coalesce(v_cpg_name, '');
      p_cpg_eslibre := coalesce(v_cpg_eslibre, 0);

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cliente_get_info(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cliente_get_iva()

-- drop function sp_cliente_get_iva(integer);

create or replace function sp_cliente_get_iva
(
  in p_cli_id integer,
  out p_bIvari smallint,
  out p_bIvarni smallint
)
  returns record as
$BODY$
declare
   v_tipoIva smallint;
   v_cli_catfiscal integer;
   v_bIva smallint;
   v_bIvaRni smallint;
   v_bSinIva smallint;
begin

   v_bIva := -1;
   v_bIvaRni := -2;
   v_bSinIva := -3;

   select case cli_catfiscal
            when 1 then v_bIva       --'Inscripto'
            when 2 then v_bIva       -- FALTA VERIFICAR QUE SEA ASI --'Exento'
            when 3 then v_bIvaRni    --'No inscripto'
            when 4 then v_bIva       --'Consumidor Final'
            when 5 then v_bSinIva    --'Extranjero'
            when 6 then v_bIva       --'Mono Tributo'
            when 7 then v_bIva       --'Extranjero Iva'
            when 8 then v_bIva       --'No responsable'
            when 9 then v_bIva       -- FALTA VERIFICAR QUE SEA ASI --'No Responsable exento'
            when 10 then v_bIvaRni   --'No categorizado'
            when 11 then v_bIva      --'InscriptoM'
            else 0                   --'Sin categorizar'
          end,
          cli_catfiscal
     into v_tipoIva,
          v_cli_catfiscal
   from Cliente
   where cli_id = p_cli_id;

   v_tipoIva := coalesce(v_tipoIva, v_bSinIva);

   if v_tipoIva = v_bIva then

      v_bIva := 1;
      v_bIvaRni := 0;

   else

      if v_tipoIva = v_bIvaRni then

         v_bIva := 1;
         v_bIvaRni := 1;

      else

         if v_tipoIva = v_bSinIva then

            v_bIva := 0;
            v_bIvaRni := 0;

         end if;

      end if;

   end if;

   p_bIvaRi := v_bIva;
   p_bIvaRni := v_bIvaRni;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cliente_get_iva(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cliente_get_next_number()

-- drop function sp_cliente_get_next_number(integer, integer);

/*

          select * from documento where doct_id = 8;
          select * from cliente;
          select * from sp_cliente_get_next_number(1, 169);

*/

create or replace function sp_cliente_get_next_number
(
  in p_cli_id integer,
  in p_doc_id integer default null,
  out p_number integer,
  out p_mask varchar,
  out p_enabled integer
)
  returns record as
$BODY$
declare
    v_ta_id integer;
begin

    select sp_cliente_get_talonario(p_cli_id, p_doc_id) into v_ta_id;

    if v_ta_id is not null then

        select ta_ultimonro, ta_mascara, ta_tipo
          into p_number, p_mask, p_enabled
        from talonario
        where ta_id = v_ta_id;

    end if;

    p_number := coalesce(p_number, 0) + 1;
    p_mask := coalesce(p_mask, '');
    p_enabled := coalesce(p_enabled, 0);

    if(p_enabled != 1 /* suggested */) then

        p_enabled := 0;

    end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cliente_get_next_number(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cliente_get_percepciones()

-- drop function sp_cliente_get_percepciones(integer, integer, date);

/*
          select * from sp_cliente_get_percepciones(1,1,'2015-01-01');
          fetch all from rtn;
*/

create or replace function sp_cliente_get_percepciones
(
  in p_cli_id integer,
  in p_emp_id integer,
  in p_fecha date,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
 v_catf_id  integer;
 v_pro_id   integer;
begin

   select cli_catFiscal,
          pro_id
     into v_catf_id,
          v_pro_id
   from Cliente
   where cli_id = p_cli_id;

   rtn := 'rtn';

   open rtn for

   select perc.*,
          perci.*,
          perccatf_base
   from Percepcion perc
   inner join PercepcionItem perci
      on perc.perc_id = perci.perc_id
   inner join PercepcionCategoriaFiscal catf
      on perc.perc_id = catf.perc_id and catf_id = v_catf_id
   where (
          (    exists(select * from PercepcionProvincia where pro_id = v_pro_id and perc_id = perc.perc_id)
           and exists(select * from Configuracion
                      where cfg_grupo = 'Ventas-General'
                       and cfg_aspecto = 'Percepcion'
                       and cfg_valor::integer = perc.perc_id
                     )
           and not exists(select * from ClientePercepcion where cli_id = p_cli_id and perc_id = perc.perc_id)
          )
          or exists(select * from ClientePercepcion
                    where cli_id = p_cli_id
                     and perc_id = perc.perc_id
                     and p_fecha between cliperc_desde and cliperc_hasta
                   )
         )
    and exists(select * from PercepcionEmpresa where emp_id = p_emp_id and perc_id = perc.perc_id);

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cliente_get_percepciones(integer, integer, date)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cliente_get_talonario()

-- drop function sp_cliente_get_talonario(integer, smallint);

/*

          select * from documento where doct_id = 8;
          select * from cliente;
          select * from talonario where ta_id = 10;
          select * from sp_cliente_get_talonario(1, 169);

*/

create or replace function sp_cliente_get_talonario
(
  in p_cli_id integer,
  in p_doc_id integer default null,
  out p_ta_id integer
)
  returns integer as
$BODY$
declare
   v_cli_catfiscal smallint;
   v_doct_id integer;
   v_doct_id_facturavta integer;
   v_doct_id_facturacpra integer;
   v_doct_id_notadebitovta integer;
   v_doct_id_notacreditovta integer;
   v_doct_id_notadebitocpra integer;
   v_doct_id_notacreditocpra integer;
begin

   v_doct_id_facturavta := 1;
   v_doct_id_facturacpra := 2;
   v_doct_id_notadebitovta := 9;
   v_doct_id_notacreditovta := 7;
   v_doct_id_notadebitocpra := 10;
   v_doct_id_notacreditocpra := 8;

   select doct_id
     into v_doct_id
   from Documento
   where doc_id = p_doc_id;

   if v_doct_id in (
                        v_doct_id_facturavta, v_doct_id_facturacpra, v_doct_id_notadebitovta,
                        v_doct_id_notacreditovta, v_doct_id_notadebitocpra, v_doct_id_notacreditocpra ) then

        select cli_catfiscal
          into v_cli_catfiscal
        from Cliente
        where cli_id = p_cli_id;


        select
            case v_cli_catfiscal
                when 1  then ta_id_inscripto--'Inscripto'
                when 2  then ta_id_final--'Exento'
                when 3  then ta_id_final--'No inscripto'
                when 4  then ta_id_final--'Consumidor Final'
                when 5  then ta_id_externo--'Extranjero'
                when 6  then ta_id_final--'Mono Tributo'
                when 7  then ta_id_externo--'Extranjero Iva'
                when 8  then ta_id_final--'No responsable'
                when 9  then ta_id_final--'No Responsable exento'
                when 10 then ta_id_final--'No categorizado'
                when 11 then ta_id_inscriptom--'Inscripto M'
                else -1--'Sin categorizar'
            end ta_id
          into p_ta_id
        from Documento
        where doc_id = p_doc_id;

   else

        select ta_id
          into p_ta_id
        from Documento
        where doc_id = p_doc_id;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cliente_get_talonario(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_codigopostalhelp()

-- drop function sp_codigopostalhelp();

create or replace function sp_codigopostalhelp
(
  in p_emp_id integer,
  in p_us_id integer,
  in p_bForAbm integer,
  in p_bFilterType integer,
  in p_filter varchar default '',
  in p_check integer default 0,
  in ip_cpa_id integer default 0,
  in v_p_filter2 varchar default '',
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   p_cpa_id integer := ip_cpa_id;
   v_altura integer;
   v_n integer;
   v_s varchar(50);
   v_filter varchar(255);
   v_p_filter varchar(2000);
begin

   v_p_filter := p_filter;
   v_altura := 0;

   v_n := LENGTH(v_p_filter);

   while v_n > 0
   loop
      begin
         if SUBSTR(v_p_filter, v_n, 1) = ' ' then
         begin
            v_s := SUBSTR(v_p_filter, v_n, 50);

            if isnumeric(v_s) <> 0 then
            begin
               v_altura := to_number(v_s);

               v_p_filter := SUBSTR(v_p_filter, 1, v_n - 1);

            end;
            end if;

            v_n := 0;

         end;
         end if;

         v_n := v_n - 1;

      end;
   end loop;

   v_filter := lower(f_unaccent(v_p_filter));

   v_filter := sp_HelpGetFilter(p_bFilterType, v_filter);

   --/////////////////////////////////////////////////////////////////////////////////////
   if p_check <> 0 then
   begin
      if p_cpa_id < 0 then
      begin
         select cpa_id
           into p_cpa_id
           from CodigoPostalItem
            where cpai_id = p_cpa_id * -1;

      end;
      end if;

      open rtn for
         select cpa_id,
                cpa_codigo Nombre,
                cpa_codigo Codigo
           from CodigoPostal cpa
            where ( cpa_codigo = v_p_filter )
                    and ( cpa_id = p_cpa_id
                    or p_cpa_id = 0 )
                    and ( p_bForAbm <> 0
                    or cpa.activo <> 0 );

   end;
   else
   begin
   
      rtn := 'rtn';        
      open rtn for

         select -cpai.cpai_id cpa_id,
                cpa.cpa_codigo Codigo_Postal,
                case cpai.cpai_tipo
                    when 1 then cpai.cpai_calle
                    else cpai.cpai_localidad
                end Calle_Localidad,
                cpai.cpai_desde Desde,
                cpai.cpai_hasta Hasta,
                pro.pro_nombre Provincia
           from CodigoPostal cpa
                  join CodigoPostalItem cpai
                   on cpa.cpa_id = cpai.cpa_id
                  join Provincia pro
                   on cpa.pro_id = pro.pro_id
            where ( cpa.cpa_codigo LIKE v_filter
                    or ( lower(f_unaccent(cpai.cpai_calle)) LIKE v_filter
                    and cpai.cpai_tipo = 1 )
                    or ( lower(f_unaccent(cpai.cpai_localidad)) LIKE v_filter
                    and cpai.cpai_tipo = 2 )
                    or v_p_filter is null )
                    and ( ( cpai.cpai_desde <= v_altura
                    and cpai.cpai_hasta >= v_altura )
                    or v_altura = 0 )
                    and ( p_bForAbm <> 0
                    or cpa.activo <> 0 )
           limit 50;

   end;
   end if;
        
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_codigopostalhelp(integer, integer, integer, integer, varchar, integer, integer, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cuenta_get_info()

-- drop function sp_cuenta_get_info(integer);

create or replace function sp_cuenta_get_info
/*
    select * from cuenta
    select * from sp_cuenta_get_info(129);
*/
(
  in p_cue_id integer,

  out p_mon_id integer,
  out p_emp_id integer
)
  returns record as
$BODY$
declare
      v_mon_id integer;
      v_emp_id integer;
begin


      select mon_id,
             emp_id
        into v_mon_id,
             v_emp_id
      from Cuenta
      where cue_id = p_cue_id;

      p_mon_id := coalesce(v_mon_id, 0);
      p_emp_id := coalesce(v_emp_id, 0);

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cuenta_get_info(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cuentahelp()

-- drop function sp_cuentahelp(integer, integer, integer, varchar, integer, integer, varchar);

create or replace function sp_cuentahelp
(
  in p_emp_id integer,
  in p_us_id integer,
  in p_bForAbm integer,
  in p_filter varchar default '',
  in p_check integer default 0,
  in p_cue_id integer default 0,
  in p_filter2 varchar default '',
  out rtn refcursor
)
  returns refcursor as
$BODY$
begin
   
      rtn := sp_cuentaHelpCliente(p_emp_id,
                       p_us_id,
                       p_bForAbm,
                       p_filter,
                       p_check,
                       p_cue_id,
                       p_filter2);        
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cuentahelp(integer, integer, integer, varchar, integer, integer, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cuentahelpcairo()

-- drop function sp_cuentahelpcairo(integer, integer, integer, varchar, integer, integer, varchar);

create or replace function sp_cuentahelpcairo
(
  in p_emp_id integer,
  in p_us_id integer,
  in p_bForAbm integer,
  in p_filter varchar default '',
  in p_check integer default 0,
  in p_cue_id integer default 0,
  in p_filter2 varchar default '',
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_sqlstmt varchar(8000);
begin

   p_filter := lower(f_unaccent(p_filter));

   if p_check <> 0 then
   begin
      v_sqlstmt := 'select  cue_id,
                            cue_nombre as Nombre,
                            cue_codigo as Codigo
                    from Cuenta
                    where (     lower(f_unaccent(cue_nombre)) = ''' || p_filter || ''' or lower(f_unaccent(cue_codigo)) = ''' || p_filter || '''
                            or (lower(f_unaccent(cue_identificacionexterna)) = ''' || p_filter || '''
                                and cue_identificacionexterna <> '''')
                          )
                      and activo <> 0
                      and (cue_id = ' || to_char(p_cue_id) || ' or ' || to_char(p_cue_id) || '=0)';
   end;
   else
   begin
      v_sqlstmt := 'select
                           cue_id,
      		      cue_nombre as Nombre,
      		      cue_codigo as Codigo,
      		      cue_identificacionexterna as Codigo2,
      		      cue_descrip as Descripcion
                    from Cuenta
                    where (lower(f_unaccent(cue_codigo)) like ''%' || p_filter || '%'' or lower(f_unaccent(cue_nombre)) like ''%' || p_filter || '%''
                           or (lower(f_unaccent(cue_identificacionexterna)) like ''%' || p_filter || '%'' and cue_identificacionexterna <> '''')
                           or (lower(f_unaccent(cue_descrip)) like ''%' || p_filter || '%'' and cue_descrip <> ''''))
                      and (' || to_char(p_bForAbm) || ' <> 0 or activo <> 0)';
   end;
   end if;

   if p_filter2 <> '' then
      v_sqlstmt := v_sqlstmt || ' and (' || p_filter2 || ')';
   end if;

   v_sqlstmt := v_sqlstmt || ' limit 50;';
   
   rtn := 'rtn';        
   open rtn for execute v_sqlstmt;

        
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cuentahelpcairo(integer, integer, integer, varchar, integer, integer, varchar)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cuentahelpcliente()

-- drop function sp_cuentahelpcliente(integer, integer, integer, varchar, integer, integer, varchar);

create or replace function sp_cuentahelpcliente
(
  in p_emp_id integer,
  in p_us_id integer,
  in p_bForAbm integer,
  in p_filter varchar default '',
  in p_check integer default 0,
  in p_cue_id integer default 0,
  in p_filter2 varchar default '',
  out rtn refcursor
)
  returns refcursor as
$BODY$
begin
   
  

         rtn := sp_cuentaHelpCairo(p_emp_id,
                                          p_us_id,
                                          p_bForAbm,
                                          p_filter,
                                          p_check,
                                          p_cue_id,
                                          p_filter2);        
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cuentahelpcliente(integer, integer, integer, varchar, integer, integer, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cuentahelpcliente()

-- drop function sp_depositologicohelp(integer, integer, integer, varchar, integer, integer, varchar);
/*
select sp_depositologicohelp(1,1,1,'%a%',0,0); fetch all from rtn;
select sp_depositologicohelp(1,1,0,'casa central',1,1,''); fetch all from rtn;
*/

create or replace function sp_depositologicohelp
(
  in p_emp_id integer,
  in p_us_id integer,
  in p_bForAbm integer,
  in p_filter varchar default '',
  in p_check integer default 0,
  in p_depl_id integer default 0,
  in p_filter2 varchar default '',
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_sqlstmt varchar(5000);
   v_bFilterXEmpresa smallint;
   v_strUsId varchar(10);
   v_permisos varchar(500);
   v_filter varchar(2000);
   v_filter2 varchar(2000);
begin

   p_filter := lower(f_unaccent(p_filter));

   v_filter := p_filter;
   v_filter2 := p_filter2;

   v_filter := replace(v_filter, '''', '''''');

   if instr(v_filter2, '{emp_id=0}') <> 0 then

      v_filter2 := replace(v_filter2, '{emp_id=0}', '');
      v_bFilterXEmpresa := 0;

   else

      v_bFilterXEmpresa := 1;

   end if;

   if instr(v_filter2, 'emp_id = ') <> 0 then

      v_bFilterXEmpresa := 0;

   end if;

   v_strUsId := trim(to_char(p_us_id));

   -- Si el usuario no tiene acceso irestricto sobre los depositos
   --
   if not exists ( select *
                   from Usuario
                   where us_deposito <> 0
                     and us_id = p_us_id ) then

      v_permisos := ' and exists(select * from UsuarioDepositoLogico '
                    || 'where depl_id = depl.depl_id and us_id = '
                    || v_strUsId || ')';

   else

      v_permisos := '';

   end if;

   if p_check <> 0 then

      v_sqlstmt :=              'select depl_id, ';
      v_sqlstmt := v_sqlstmt || '    depl_nombre    as Nombre, ';
      v_sqlstmt := v_sqlstmt || '    depl_codigo    as Codigo ';
      v_sqlstmt := v_sqlstmt || 'from DepositoLogico depl ';
      v_sqlstmt := v_sqlstmt || 'where (depl_id > 0) and (lower(f_unaccent(depl_nombre)) = ''' || v_filter
                             || ''' or lower(f_unaccent(depl_codigo)) = ''' || v_filter || ''') ';

      if p_depl_id <> 0 then

         v_sqlstmt := v_sqlstmt || '  and (depl_id = ' || to_char(p_depl_id) || ') ';

      end if;

      if p_emp_id <> 0 and v_bFilterXEmpresa <> 0 and p_bForAbm = 0 then

         v_sqlstmt := v_sqlstmt || '  and (emp_id = ' || to_char(p_emp_id) || ' or emp_id is null) ';

      end if;

      if p_bForAbm = 0 then

         v_sqlstmt := v_sqlstmt || '  and activo <> 0 ';

      end if;

      if v_filter2 <> '' then

         v_sqlstmt := v_sqlstmt || '  and (' || v_filter2 || ')';

      end if;

   else

      v_sqlstmt :=              'select depl_id, ';
      v_sqlstmt := v_sqlstmt || '       depl_nombre   as Nombre, ';
      v_sqlstmt := v_sqlstmt || '       depl_codigo   as Codigo ';
      v_sqlstmt := v_sqlstmt || 'from DepositoLogico depl ';
      v_sqlstmt := v_sqlstmt || 'where (depl_id > 0 ) and (lower(f_unaccent(depl_codigo)) like ''%' || v_filter
                                || '%'' or lower(f_unaccent(depl_nombre)) like ''%' || v_filter
                                || '%'' or ''' || v_filter || ''' = '''') ';

      if p_emp_id <> 0 and v_bFilterXEmpresa <> 0 and p_bForAbm = 0 then

         v_sqlstmt := v_sqlstmt || '  and (emp_id = ' || to_char(p_emp_id) || ' or emp_id is null) ';

      end if;

      if p_bForAbm = 0 then

         v_sqlstmt := v_sqlstmt || '  and activo <> 0 ';

      end if;

      if v_filter2 <> '' then

         v_sqlstmt := v_sqlstmt || '  and (' || v_filter2 || ')';

      end if;

   end if;

   if p_bForAbm = 0 then

      v_sqlstmt := v_sqlstmt || v_permisos;

   end if;

   rtn := 'rtn';
   open rtn for execute v_sqlstmt;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_depositologicohelp(integer, integer, integer, varchar, integer, integer, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_get_doc_id_for_doct_id()

-- drop function sp_doc_get_doc_id_for_doct_id(integer, integer, integer, integer, integer, integer);

/*
          select * from remitoventa;
          select sp_doc_get_doc_id_for_doct_id(1,1,2,4,1,0);

*/
create or replace function sp_doc_get_doc_id_for_doct_id
(
  in p_emp_id integer,
  in p_us_id integer,
  in p_doct_id integer,
  in p_doct_id_aplic integer,
  in p_id integer,
  in p_idEx integer,  -- -1 Factura de Venta sobre Horas
                      -- -2 Remito de venta basado en boms
  out p_doc_id integer,
  out p_doc_name varchar,
  out p_mon_id integer
)
  returns record as
$BODY$
declare
  v_mon_id integer;
begin

   p_doc_id := 0;
   p_doc_name := '';

   if p_doct_id_aplic = 3 then -- Remitos de Venta

      select doc.mon_id
        into v_mon_id
      from RemitoVenta rv
      join Documento doc
        on rv.doc_id = doc.doc_id
      where rv.rv_id = p_id;

   else
      if p_doct_id_aplic = 4 then -- Remitos de Compra

         select doc.mon_id
           into v_mon_id
         from RemitoCompra rc
         join Documento doc
           on rc.doc_id = doc.doc_id
         where rc.rc_id = p_id;

      end if;
   end if;

   if p_doct_id_aplic = 5 then -- Pedidos de Venta

      select doc.mon_id
        into v_mon_id
      from PedidoVenta pv
      join Documento doc
        on pv.doc_id = doc.doc_id
      where pv.pv_id = p_id;

   else

      if p_doct_id_aplic = 11 then -- Presupuesto de Venta

         select doc.mon_id
           into v_mon_id
         from PresupuestoVenta prv
         join Documento doc
           on prv.doc_id = doc.doc_id
         where prv.prv_id = p_id;

      else

         if p_doct_id_aplic = 35 then -- Ordenes de Compra

            select doc.mon_id
              into v_mon_id
            from OrdenCompra oc
            join Documento doc
              on oc.doc_id = doc.doc_id
            where oc.oc_id = p_id;

         end if;

      end if;

   end if;

   if v_mon_id is null then

      select mon_id
        into v_mon_id
      from Moneda
      where mon_legal <> 0;

   end if;

   /*
      csETFacDirecta = 0
      csETFacPedido = 1
      csETFacRemito = 2
      csETFacPackingList = 3
      csETFacProyecto = 4
      csETFacOrden = 5
   */

   select doc_id, doc_nombre
     into p_doc_id, p_doc_name
   from Documento doc
   where doc.doct_id = p_doct_id
     and doc.mon_id = v_mon_id
     and doc.emp_id = p_emp_id
     and ( ( doc_rv_desde_pv <> 0 and p_doct_id_aplic = 5 and p_doct_id = 3 )
          or ( doc_rv_desde_os <> 0 and p_doct_id_aplic = 42 and p_doct_id = 3 )
          or ( doc_rv_bom <> 0 and p_doct_id_aplic = 5 and p_doct_id = 3 and p_IdEx = -2 )
          or ( doc_pv_desde_prv <> 0 and p_doct_id_aplic = 11 and p_doct_id = 5 )
          or ( doc_rc_desde_oc <> 0 and p_doct_id_aplic = 35 and p_doct_id = 4 )
          or ( doc_tipofactura = 5 and p_doct_id_aplic = 35 and p_doct_id = 2 )
          or ( doc_tipofactura = 2 and p_doct_id_aplic = 4 and p_doct_id = 2 )
          or ( doc_tipofactura = 1 and p_doct_id_aplic = 5 and p_doct_id = 1 )
          or ( doc_tipofactura = 2 and p_doct_id_aplic = 3 and p_doct_id = 1 )
          or ( doc_tipofactura = 3 and p_doct_id_aplic = 21 and p_doct_id = 1 )
          or ( doc_tipofactura = 4 and p_doct_id_aplic = 0 and p_doct_id = 1 and p_IdEx = -1 )
         )
     and exists ( select *
                  from Permiso
                  where pre_id = doc.pre_id_new
                    and ( ( us_id = p_us_id )
                          or exists ( select us_id from UsuarioRol
                                      where us_id = p_us_id
                                        and rol_id = Permiso.rol_id ) ) )
     limit 1;

   select mon_id into p_mon_id from Documento where doc_id = p_doc_id;

   p_mon_id := coalesce(p_mon_id, 0);

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_get_doc_id_for_doct_id(integer, integer, integer, integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_validate_date()

-- drop function sp_doc_validate_date(integer, date);

create or replace function sp_doc_validate_date
/*
          select * from documento
          select * from sp_doc_validate_date(13,'20050430 20:00:00')
*/
(
  in p_doc_id integer,
  in p_fecha date,
  out p_is_valid integer,
  out p_range varchar
)
  returns record as
$BODY$
declare
  v_rango varchar(255);
begin

      if exists ( select fca.fca_id
                  from FechaControlAcceso fca
                  join Documento doc
                    on fca.fca_id = doc.fca_id
                  where doc.doc_id = p_doc_id
                     and p_fecha between fca.fca_fechadesde and fca.fca_fechahasta ) then

         p_is_valid := 1;
         p_range := '';

      else

         select 'Desde el ' || fca.fca_fechadesde::varchar || ' hasta el ' || fca.fca_fechahasta::varchar || ' inclusive.'
           into v_rango
         from FechaControlAcceso fca
         join Documento doc
           on fca.fca_id = doc.fca_id
         where doc.doc_id = p_doc_id;

         p_is_valid := 0;
         p_range := v_rango;

      end if;
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_validate_date(integer, date)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_document_get_next_number()

-- drop function sp_document_get_next_number(integer);

/*

          select * from documento where doct_id = 8;
          select * from proveedor;
          select * from sp_document_get_next_number(1, 169);

*/

create or replace function sp_document_get_next_number
(
  in p_doc_id integer default null,
  out p_number integer,
  out p_mask varchar,
  out p_enabled integer
)
  returns record as
$BODY$
declare
    v_ta_id integer;
begin

    select ta_id from documento where doc_id = p_doc_id into v_ta_id;

    if v_ta_id is not null then

        select ta_ultimonro, ta_mascara, ta_tipo
          into p_number, p_mask, p_enabled
        from talonario
        where ta_id = v_ta_id;

    end if;

    p_number := coalesce(p_number, 0) + 1;
    p_mask := coalesce(p_mask, '');
    p_enabled := coalesce(p_enabled, 0);

    if(p_enabled != 1 /* suggested */) then

        p_enabled := 0;

    end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_document_get_next_number(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_documentohelp()

-- drop function sp_documentohelp(integer, integer, integer, varchar, integer, integer, varchar);

create or replace function sp_documentohelp
/*
          select * from sp_documentohelp(1, 1, 0, '', 0, 0);
          fetch all from rtn;
          select * from sp_documentohelp(2, 1, 0, 'Factura Dolar s/Packing List -cc', 1, 0, 'doct_id = 1 or doct_id = 7');
          fetch all from rtn;
          select * from sp_documentohelp(2, 1, 0, '', 0, 0, 'doct_id = 1 or doct_id = 7');
          fetch all from rtn;
          select * from sp_documentohelp(1, 1, 0, 'factur', 0, 0, 'doct_id = 2 or doct_id = 8 or doct_id = 10');
          fetch all from rtn;
          
          select * from empresa
          
*/
(
  in p_emp_id integer,
  in p_us_id integer,
  in p_bForAbm integer,
  in p_filter varchar default '',
  in p_check integer default 0,
  in p_doc_id integer default 0,
  in p_filter2 varchar default '',
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_sqlstmt varchar(8000);
   v_bFilterXEmpresa smallint;
   v_strUsId varchar(10);
   v_permisos varchar(1000);
begin

 /*------------------------------------------
           Este codigo es el que se asigna a @permiso.
           Se asigna en una sola linea para que sea mas rapida la sentencia
           and exists( select * from Permiso
                       where pre_id = Documento.pre_id_list
                         and (
                                  us_id = @@us_id
                              or
                                  exists(select * from UsuarioRol where us_id = @@us_id and rol_id = Permiso.rol_id)
                              )
                    )
	*/

   p_filter := lower(f_unaccent(p_filter));

   if instr(p_filter2, '{emp_id=0}') <> 0 then
      p_filter2 := replace(p_filter2, '{emp_id=0}', '');
      v_bFilterXEmpresa := 0;
   else
      v_bFilterXEmpresa := 1;
   end if;

   if instr(p_filter2, 'emp_id = ') <> 0 then
      v_bFilterXEmpresa := 0;
   end if;

   v_strUsId := p_us_id::varchar;

   v_permisos := ' and exists(select * from Permiso	where pre_id = Documento.pre_id_list and (us_id = ' 
                || v_strUsId
                || ' or exists(select * from UsuarioRol where us_id = ' || v_strUsId
                || ' and rol_id = Permiso.rol_id))) ';

   /*-----------------------------------------*/
   if p_check <> 0 then
      v_sqlstmt := 'select doc_id, '
                || 'doc_nombre as Nombre, '
                || 'doc_codigo as Codigo '
                || 'from Documento '
                || 'where (lower(f_unaccent(doc_nombre)) = ''' || p_filter
                || ''' or lower(f_unaccent(doc_codigo)) = ''' || p_filter || ''') ';

      if p_doc_id <> 0 then
         v_sqlstmt := v_sqlstmt || 'and (doc_id = ' || CAST(p_doc_id as varchar(20)) || ') ';
      end if;

      if p_emp_id <> 0 and v_bFilterXEmpresa <> 0 and p_bForAbm = 0 then
         v_sqlstmt := v_sqlstmt || 'and (emp_id = ' || CAST(p_emp_id as varchar(20)) || ') ';
      end if;

      if p_bForAbm = 0 then
         v_sqlstmt := v_sqlstmt || 'and activo <> 0 ';
      end if;

      if p_filter2 <> '' then
         v_sqlstmt := v_sqlstmt || 'and (' || p_filter2 || ') ';
      end if;

   else

      v_sqlstmt := 'select doc_id, '
                || 'doc_nombre   as Nombre, '
                || 'doc_codigo   as Codigo '
                || 'from Documento '
                || 'where (lower(f_unaccent(doc_codigo)) like ''%' || p_filter
                || '%'' or lower(f_unaccent(doc_nombre)) like ''%' || p_filter
                || '%'' or ''' || p_filter || ''' = '''') ';

      if p_emp_id <> 0 and v_bFilterXEmpresa <> 0 and p_bForAbm = 0 then
         v_sqlstmt := v_sqlstmt || 'and (emp_id = ' || CAST(p_emp_id as varchar(20)) || ') ';
      end if;

      if p_bForAbm = 0 then
         v_sqlstmt := v_sqlstmt || 'and activo <> 0 ';
      end if;

      if p_filter2 <> '' then
         v_sqlstmt := v_sqlstmt || 'and (' || p_filter2 || ') ';
      end if;

   end if;

   if p_bForAbm = 0 then
      v_sqlstmt := v_sqlstmt || v_permisos;
   end if;

   rtn := 'rtn';
      open rtn for execute v_sqlstmt;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_documentohelp(integer, integer, integer, varchar, integer, integer, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_productoventahelp()

-- drop function sp_help_get_filter(integer, varchar);

create or replace function sp_help_get_filter
(
  in p_bFilterType integer,
  in p_filter varchar
)
  returns varchar as
$BODY$
begin

  /*
  HelpFilterBeginLike = 1
  HelpFilterHaveTo = 2
  HelpFilterWildcard = 3
  HelpFilterEndLike = 4
  HelpFilterIsLike = 5
  */
   case p_bFilterType 
      when 1 then p_filter := p_filter || '%';
      when 3 then p_filter := replace(p_filter, '*', '%');
      when 4 then p_filter := '%' || p_filter;
      when 5 then p_filter := p_filter;
      -- Default
      -- case 2 then '%' + @@filter + '%'
      else p_filter := '%' || p_filter || '%';
   end case;

   return p_filter;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_help_get_filter(integer, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_ld_get_descuento()

-- drop function sp_ld_get_descuento(integer, integer, decimal);

create or replace function sp_ld_get_descuento
/*
    select * from listadescuento
    select * from listadescuentoitem
    select * from sp_ld_get_descuento(4,167,10)
*/
(
  in p_ld_id integer,
  in p_pr_id integer,
  inout p_precio decimal(18,6)
)
  returns decimal(18,6) as
$BODY$
declare
   v_ldi_id integer;
   v_ld_porcentaje decimal(18,6);
   v_ld_porcGlobal decimal(18,6);
   v_importe decimal(18,6);
   v_precio decimal(18,6);
   v_ld_id integer;
begin

   v_precio := p_precio;

   -- Valido si me pasaron una lista de descuento
   if p_ld_id is not null then

       if exists ( select ld_id from ListaDescuento where ld_id = p_ld_id ) then

           v_ld_id := p_ld_id;
           v_ld_porcGlobal := 0;

           select ldi_id,
                  ldi_importe,
                  ldi_porcentaje
             into v_ldi_id,
                  v_importe,
                  v_ld_porcentaje
           from ListaDescuentoItem
           where ld_id = v_ld_id
             and pr_id = p_pr_id;

           select ld_porcentaje
             into v_ld_porcGlobal
           from ListaDescuento
           where ld_id = v_ld_id;

           v_ld_porcGlobal := coalesce(v_ld_porcGlobal, 0);
           v_ld_porcentaje := coalesce(v_ld_porcentaje, 0);
           v_importe := coalesce(v_importe, 0);

           v_precio := v_precio - (v_precio * v_ld_porcGlobal / 100);
           v_precio := v_precio - v_importe;
           v_precio := v_precio - (v_precio * v_ld_porcentaje / 100);

           select ld_id_padre
             into v_ld_id
           from ListaDescuento
           where ld_id = v_ld_id;

           if v_ld_id is not null then

              select sp_ld_get_descuento(v_ld_id, p_pr_id, v_precio) into v_precio;

           end if;
       end if;
   end if;

   p_precio := v_precio;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_ld_get_descuento(integer, integer, decimal)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_ld_get_descuento_str()

-- drop function sp_ld_get_descuento_str(integer, integer, varchar);

create or replace function sp_ld_get_descuento_str
/*
    select * from listadescuento
    select * from listadescuentoitem
    select * from sp_ld_get_descuento_str(4,167,'')
*/
(
  in p_ld_id integer,
  in p_pr_id integer,
  inout p_descuento varchar
)
  returns varchar as
$BODY$
declare
   v_ldi_id integer;
   v_ld_porcentaje decimal(18,6);
   v_ld_porcGlobal decimal(18,6);
   v_importe decimal(18,6);
   v_ld_id integer;
   v_descuento varchar(255);
begin

    v_descuento := p_descuento;

    -- Valido si me pasaron una lista de descuento
    if p_ld_id is not null then

        if exists ( select ld_id from ListaDescuento where ld_id = p_ld_id ) then

            v_ld_id := p_ld_id;
            v_ld_porcGlobal := 0;

            -- Busco un descuento
            select ldi_id,
                   ldi_importe,
                   ldi_porcentaje
             into v_ldi_id,
                  v_importe,
                  v_ld_porcentaje
            from ListaDescuentoItem
            where ld_id = v_ld_id
              and pr_id = p_pr_id;

            select ld_porcentaje
             into v_ld_porcGlobal
            from ListaDescuento
            where ld_id = v_ld_id;

            v_ld_porcGlobal := coalesce(v_ld_porcGlobal, 0);
            v_ld_porcentaje := coalesce(v_ld_porcentaje, 0);
            v_importe := coalesce(v_importe, 0);

            if v_ld_porcGlobal > 0 then
              v_descuento := v_descuento || ' +' || CAST(v_ld_porcGlobal as decimal(18,4))::varchar || '%';
            end if;

            if v_importe > 0 then
              v_descuento := v_descuento || ' + $' || CAST(v_importe as decimal(18,4))::varchar;
            end if;

            if v_ld_porcentaje > 0 then
              v_descuento := v_descuento || ' +' || CAST(v_ld_porcentaje as decimal(18,4))::varchar || '%';
            end if;

            if v_ld_porcGlobal < 0 then
              v_descuento := v_descuento || ' - ' || CAST(v_ld_porcGlobal as decimal(18,4))::varchar || '%';
            end if;

            if v_importe < 0 then
              v_descuento := v_descuento || ' -' || CAST(v_importe as decimal(18,4))::varchar;
            end if;

            if v_ld_porcentaje < 0 then
              v_descuento := v_descuento || ' -' || CAST(v_ld_porcentaje as decimal(18,4))::varchar || '%';
            end if;

            select ld_id_padre
             into v_ld_id
            from ListaDescuento
            where ld_id = v_ld_id;

            if v_ld_id is null then

              select sp_ld_get_descuento_str(v_ld_id, p_pr_id, v_descuento) into v_descuento;

            end if;
        end if;
   end if;

   p_descuento := v_descuento;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_ld_get_descuento_str(integer, integer, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_lista_precio_save_auto()

-- drop function sp_lista_precio_save_auto(integer, integer, integer, date);

create or replace function sp_lista_precio_save_auto
(
  in p_doc_id integer,
  in p_doct_id integer,
  in p_is_new integer,
  in p_fecha date
)
  returns void as
$BODY$
declare
  v_us_id integer;
  v_lp_id integer;
  v_lpi_id integer;
  v_pr_id integer;
  v_precio decimal(18,6);
  v_cotiz decimal(18,6);
  v_doc_fecha date;
  v_mon_id_precio integer;
  v_mon_id_legal integer;
  v_mon_id_lista integer;

  c_items refcursor;
  c_listas refcursor;
begin

   if p_doct_id in ( 1,2,3,4 ) then

      if p_doct_id in ( 1,3 ) then

         open c_listas for
            select lp_id
            from ListaPrecio
            where lp_tipo = 1
              and lp_autoXcompra <> 0;

      end if;

      if p_doct_id in ( 2,4 ) then

         open c_listas for
            select lp_id
            from ListaPrecio
            where lp_tipo in ( 2,3 )
              and lp_autoXcompra <> 0;

      end if;

      if p_is_new <> 0 then

         if p_doct_id = 1 then

            select modifico
              into v_us_id
            from FacturaVenta
            where fv_id = p_doc_id;

            open c_items for
               select fvi.pr_id,
                      fvi.fvi_precio,
                      fv.fv_cotizacion,
                      fv.mon_id,
                      fv.fv_fecha
               from FacturaVentaItem fvi
               join FacturaVenta fv
                 on fvi.fv_id = fv.fv_id
               where fvi.fv_id = p_doc_id
                 and round(fvi.fvi_precio, 2) <> 0;

         end if;

         if p_doct_id = 2 then

            select modifico
              into v_us_id
            from FacturaCompra
            where fc_id = p_doc_id;

            open c_items for
               select fci.pr_id,
                      fci.fci_precio,
                      fc.fc_cotizacion,
                      fc.mon_id,
                      fc.fc_fecha
               from FacturaCompraItem fci
               join FacturaCompra fc
                 on fci.fc_id = fc.fc_id
               where fci.fc_id = p_doc_id
                 and round(fci.fci_precio, 2) <> 0;

         end if;

         if p_doct_id = 3 then

            select modifico
              into v_us_id
            from RemitoVenta
            where rv_id = p_doc_id;

            open c_items for
               select rvi.pr_id,
                      rvi.rvi_precio,
                      rv.rv_cotizacion,
                      doc.mon_id,
                      rv.rv_fecha
               from RemitoVentaItem rvi
               join RemitoVenta rv
                 on rvi.rv_id = rv.rv_id
               join Documento doc
                 on rv.doc_id = doc.doc_id
               where rvi.rv_id = p_doc_id
                 and round(rvi.rvi_precio, 2) <> 0;

         end if;

         if p_doct_id = 4 then

            select modifico
              into v_us_id
            from RemitoCompra
            where rc_id = p_doc_id;

            open c_items for
               select rci.pr_id,
                      rci.rci_precio,
                      rc.rc_cotizacion,
                      doc.mon_id,
                      rc.rc_fecha
               from RemitoCompraItem rci
               join RemitoCompra rc
                 on rci.rc_id = rc.rc_id
               join Documento doc
                 on rc.doc_id = doc.doc_id
               where rci.rc_id = p_doc_id
                 and round(rci.rci_precio, 2) <> 0;

         end if;

      else

         if p_doct_id = 1 then

            select modifico
              into v_us_id
            from FacturaVenta
            where fv_id = p_doc_id;

            open c_items for
               select fvi2.pr_id,
                      fvi2.fvi_precio,
                      fv.fv_cotizacion,
                      fv.mon_id,
                      fv.fv_fecha
               from FacturaVentaItem fvi2
               join FacturaVenta fv
                 on fvi2.fv_id = fv.fv_id
               where fvi2.fv_id = p_doc_id
                 and round(fvi2.fvi_precio, 2) <> 0
                 and not exists ( select fv.fv_id
                                  from FacturaVentaItem fvi
                                  join FacturaVenta fv
                                    on fvi.fv_id = fv.fv_id
                                  where fv.fv_id <> p_doc_id
                                    and fvi.fv_fecha > p_fecha
                                    and fvi.pr_id = fvi2.pr_id );

         end if;

         if p_doct_id = 2 then

            select modifico
              into v_us_id
            from FacturaCompra
            where fc_id = p_doc_id;

            open c_items for
               select fci2.pr_id,
                      fci2.fci_precio,
                      fc.fc_cotizacion,
                      fc.mon_id,
                      fc.fc_fecha
               from FacturaCompraItem fci2
               join FacturaCompra fc
                 on fci2.fc_id = fc.fc_id
               where fci2.fc_id = p_doc_id
                 and round(fci2.fci_precio, 2) <> 0
                 and not exists ( select fc.fc_id
                                  from FacturaCompraItem fci
                                  join FacturaCompra fc
                                    on fci.fc_id = fc.fc_id
                                  where fc.fc_id <> p_doc_id
                                    and fc.fc_fecha > p_fecha
                                    and fci.pr_id = fci2.pr_id );

         end if;

         if p_doct_id = 3 then

            select modifico
              into v_us_id
            from RemitoVenta
            where rv_id = p_doc_id;

            open c_items for
               select rvi2.pr_id,
                      rvi2.rvi_precio,
                      rv.rv_cotizacion,
                      doc.mon_id,
                      rv.rv_fecha
               from RemitoVentaItem rvi2
               join RemitoVenta rv
                 on rvi2.rv_id = rv.rv_id
               join Documento doc
                 on rv.doc_id = doc.doc_id
               where rvi2.rv_id = p_doc_id
                 and round(rvi2.rvi_precio, 2) <> 0
                 and not exists ( select rv.rv_id
                                  from RemitoVentaItem rvi
                                  join RemitoVenta rv
                                    on rvi.rv_id = rv.rv_id
                                  where rv.rv_id <> p_doc_id
                                    and rvi.rv_fecha > p_fecha
                                    and rvi.pr_id = rvi2.pr_id );

         end if;

         if p_doct_id = 4 then

            select modifico
              into v_us_id
            from RemitoCompra
            where rc_id = p_doc_id;

            open c_items for
               select rci2.pr_id,
                      rci2.rci_precio,
                      rc.rc_cotizacion,
                      doc.mon_id,
                      rc.rc_fecha
               from RemitoCompraItem rci2
               join RemitoCompra rc
                 on rci2.rc_id = rc.rc_id
               join Documento doc
                 on rc.doc_id = doc.doc_id
               where rci2.rc_id = p_doc_id
                 and round(rci2.rci_precio, 2) <> 0
                 and not exists ( select rc.rc_id
                                  from RemitoCompraItem rci
                                  join RemitoCompra rc
                                    on rci.rc_id = rc.rc_id
                                  where rc.rc_id <> p_doc_id
                                    and rci.rc_fecha > p_fecha
                                    and rci.pr_id = rci2.pr_id );

         end if;

      end if;

      select mon_id
        into v_mon_id_legal
      from Moneda
      where mon_legal <> 0;

      loop

         fetch c_listas into v_lp_id;
         exit when not found;

         select mon_id
           into v_mon_id_lista
         from ListaPrecio
         where lp_id = v_lp_id;

         loop

            fetch c_items into v_pr_id,v_precio,v_cotiz,v_mon_id_precio,v_doc_fecha;
            exit when not found;

            -- calculo el precio segun su moneda y cotizacion
            --
            if v_mon_id_precio <> v_mon_id_lista then

               if v_mon_id_lista = v_mon_id_legal then

                  v_precio := v_precio * v_cotiz;

               else

                  if v_mon_id_precio = v_mon_id_legal then

                     v_cotiz := 0;
                     select sp_moneda_get_cotizacion(v_mon_id_lista, v_doc_fecha) into v_cotiz;

                     if v_cotiz is null then
                        v_cotiz := 0;
                     end if;

                     -- precio en moneda extranjera
                     --
                     if v_cotiz = 0 then
                        v_precio := 0;
                     else
                        v_precio := v_precio / v_cotiz;
                     end if;

                  else

                     -- paso a moneda legal el precio del documento
                     --
                     v_cotiz := 0;

                     select sp_moneda_get_cotizacion(v_mon_id_precio, v_doc_fecha) into v_cotiz;

                     if v_cotiz is null then
                        v_cotiz := 0;
                     end if;

                     -- precio en moneda legal
                     --
                     v_precio := v_precio * v_cotiz;

                     -- paso a la moneda de la lista de precios el precio en moneda legal
                     --
                     v_cotiz := 0;

                     select sp_moneda_get_cotizacion(v_mon_id_lista, v_doc_fecha) into v_cotiz;

                     if v_cotiz is null then
                        v_cotiz := 0;
                     end if;

                     -- precio en moneda extranjera
                     --
                     if v_cotiz = 0 then
                        v_precio := 0;
                     else
                        v_precio := v_precio / v_cotiz;
                     end if;

                  end if;

               end if;

            end if;

            -- actualizo el precio
            --
            v_lpi_id := null;

            select lpi_id
              into v_lpi_id
            from ListaPrecioItem
            where lp_id = v_lp_id
              and pr_id = v_pr_id;

            if v_lpi_id is null then

               select sp_dbGetNewId('ListaPrecioItem', 'lpi_id') into v_lpi_id;

               insert into ListaPrecioItem ( lp_id, lpi_id, lpi_precio, pr_id, modifico )
               values ( v_lp_id, v_lpi_id, v_precio, v_pr_id, v_us_id );

            else

               update ListaPrecioItem
                  set lpi_precio = v_precio,
                      modifico = v_us_id
               where lpi_id = v_lpi_id;

            end if;

         end loop;

         close c_items;

      end loop;

      close c_listas;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_lista_precio_save_auto(integer, integer, integer, date)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_lp_get_precio()

-- drop function sp_lp_get_precio(integer, integer, integer, integer, integer, integer, integer, integer);

create or replace function sp_lp_get_precio
/*
          select * from listapreciolista where lp_id_padre = 5
          select pr_id,* from listaprecioitem where lp_id = 49
          select * from listaprecio where lp_id in (5,49,31)
          select * from listaprecioitem where pr_id = 19
          select * from sp_lp_get_precio(49,19)
*/
(
  in p_lp_id integer,
  in p_pr_id integer,

  /*
    this function is recursive
    all the parameters below must be
    provided only by a recursive call
    NONE external call to this function
    can use this parameters
  */

  in p_createTable integer default 1,
  in p_lp_id_padre integer default 0,
  in p_n integer default 0,
  in p_noUseCache integer default 0,
  in ip_lp_id_lpc integer default 0,
  in p_isForCompra integer default 0,
  out p_precio decimal(18,6)
)
  returns decimal(18,6) as
$BODY$
declare
   p_lp_id_lpc integer := ip_lp_id_lpc; -- Este Id de lista de precios
   v_lpi_porcentaje decimal(18,6);
   v_lp_porcglobal decimal(18,6);
   v_precio decimal(18,6);
   v_lp_id integer;
   v_mon_id integer;
   v_mon_id_base integer;
   v_mon_default smallint;
   v_lp_porcentaje decimal(18,6);
   v_lp_enCache smallint;
   v_cfg_valor varchar(5000);
   v_cotiz decimal(18,6);
   v_cotiz2 decimal(18,6);

   v_lpm_id integer; -- lpm_id mencionado en la solapa precios de una lista hija

   v_lpm_id_lista integer; -- lmp_id mencionado en la solapa general de una lista hija

   v_lpm_id_precio integer; -- lpm_id mencionado en la solapa precios de la misma lista

   -- que estoy procesando
   v_fecha date;

   -- Si es la primera llamada a la lista
   -- analizo el uso de ListaPrecioConfig
   --
   v_checkListaPrecioConfig smallint;

   v_isForCompra integer;
   v_n integer;
   v_createTable integer;
begin

   v_isForCompra := p_isForCompra;
   v_n := p_n;
   v_createTable := p_createTable;

   select mon_id,
          lp_porcentaje,
          lp_encache
     into v_mon_id,
          v_lp_porcentaje,
          v_lp_enCache
   from ListaPrecio
   where lp_id = p_lp_id
     and activo <> 0;

   v_fecha := CURRENT_TIMESTAMP;

   if v_n = 0 then
      v_checkListaPrecioConfig := 1;
   else
      v_checkListaPrecioConfig := 0;
   end if;

   -- Si es la primera llamada compruebo si se trata de una lista de compras
   --
   if v_n = 0 then

      if exists ( select *
                  from ListaPrecio
                  where lp_id = p_lp_id
                    and lp_tipo = 2 ) then

         v_isForCompra := 1;
      end if;
   end if;

   v_n := v_n + 1;

   -- Si la lista no existe devuelvo precio 0
   --
   if p_lp_id is null then

      v_precio := 0;

   else

      -- Si la lista no existe devuelvo precio 0
      --
      if not exists ( select lp_id
                      from ListaPrecio
                      where lp_id = p_lp_id
                        and activo <> 0 ) then
         v_precio := 0;

      else
       declare
         v_fromCache smallint;
       begin
         v_fromCache := 0;

         if p_noUseCache = 0 then
            if v_lp_enCache <> 0 then
             declare
               v_cacheActivo integer;
             begin

               select sp_cfg_getValor('Ventas-General', 'Utilizar Cache de Precios') into v_cfg_valor;

               if isnumeric(v_cfg_valor) = 0 then
                  v_cacheActivo := 0;
               else
                  v_cacheActivo := to_number(v_cfg_valor);
               end if;

               if v_cacheActivo <> 0 then
                  v_fromCache := 1;

                  select coalesce(lpp_precio, 0)
                    into v_precio
                  from ListaPrecioPrecio
                  where pr_id = p_pr_id
                    and lp_id = p_lp_id;

               end if;

             end;
            end if;
         end if;

         if v_fromCache = 0 then

            -- Si es la primera llamada a la lista
            -- analizo el uso de ListaPrecioConfig
            --
            if v_checkListaPrecioConfig <> 0 then

               -- Solo si la lista principal no tiene un precio fijo
               --
               if not exists ( select *
                               from ListaPrecioItem
                               where lp_id = p_lp_id
                                 and pr_id = p_pr_id ) then

                  -- Si existen listas definidas para este producto
                  --
                  if exists ( select * from ListaPrecioConfig where pr_id = p_pr_id ) then

                     -- Si existen precios en las listas definidas para este producto
                     --
                     if exists ( select *
                                 from ListaPrecioItem lpi
                                 where pr_id = p_pr_id
                                   and exists ( select *
                                                from ListaPrecioConfig
                                                where pr_id = p_pr_id
                                                  and lp_id = lpi.lp_id )) then
                      declare
                        -- Cargo en una temporal todas las listas
                        -- (la principal y todo sus ancestros)
                        --
                        v_k integer := 1;
                      begin

                        create temporary table tt_listas_padre
                        (
                          lp_id integer,
                          k integer
                        ) on commit drop;

                        -- La lista principal
                        --
                        insert into tt_listas_padre( lp_id, k ) values ( p_lp_id, 0 );

                        -- La lista padre de la principal (viejo esquema)
                        --
                        insert into tt_listas_padre( lp_id, k )
                          ( select lp_id_padre,
                                   v_k
                            from ListaPrecio
                            where lp_id = p_lp_id
                              and lp_id_padre is not null );

                        -- Las listas padre de la principal (nuevo viejo esquema)
                        --
                        insert into tt_listas_padre( lp_id, k )
                          ( select lp_id_padre,
                                   v_k
                            from ListaPrecioLista lp
                            where lp_id = p_lp_id
                              and lp_id_padre is not null
                              and not exists ( select *
                                               from tt_listas_padre
                                               where lp_id = lp.lp_id_padre ));

                        loop

                            if not exists ( select *
                                            from ListaPrecioLista lp
                                            join tt_listas_padre p
                                              on lp.lp_id = p.lp_id
                                             and p.k = v_k ) then
                               exit;
                            end if;

                            -- La lista padre de los padres (viejo esquema)
                            --
                            insert into tt_listas_padre( lp_id, k )
                            ( select lp.lp_id_padre,
                                     v_k + 1
                              from ListaPrecio lp
                              join tt_listas_padre p
                                on lp.lp_id = p.lp_id
                               and p.k = v_k
                              where lp.lp_id_padre is not null
                                and not exists ( select *
                                                 from tt_listas_padre
                                                 where lp_id = lp.lp_id_padre ));

                            -- Las listas padre de los padres (nuevo viejo esquema)
                            --
                            insert into tt_listas_padre( lp_id, k )
                            ( select lp.lp_id_padre,
                                     v_k + 1
                              from ListaPrecioLista lp
                              join tt_listas_padre p
                                on lp.lp_id = p.lp_id
                               and p.k = v_k
                              where lp.lp_id_padre is not null
                                and not exists ( select *
                                                 from tt_listas_padre
                                                 where lp_id = lp.lp_id_padre ));

                            v_k := v_k + 1;

                        end loop;

                        -- Cargo en una temporal todas las listas
                        -- (la principal y todo sus ancestros)
                        --
                        -- Ahora verifico que almenos una de estas listas
                        -- asociadas al producto en ListaPrecioConfig
                        -- tambien este asociada a la lista principal
                        -- o a uno de sus ancestros
                        --
                        -- Si existen precios en las listas definidas para este producto
                        --

                        if exists ( select 1
                                    from ListaPrecioItem lpi
                                    where pr_id = p_pr_id
                                      and exists ( select 1
                                                   from ListaPrecioConfig lpc
                                                   join tt_listas_padre p
                                                      on lpc.lp_id = p.lp_id
                                                   where lpc.pr_id = p_pr_id
                                                     and lpc.lp_id = lpi.lp_id )) then
                         declare
                           v_lpc_orden integer;
                         begin
                           select min(lpc.lpc_orden)
                             into v_lpc_orden
                           from ListaPrecioConfig lpc
                           join tt_listas_padre p
                             on lpc.lp_id = p.lp_id
                           where lpc.pr_id = p_pr_id
                             and exists ( select *
                                          from ListaPrecioItem lpi
                                          where pr_id = p_pr_id
                                            and lp_id = lpc.lp_id );

                           select lp_id
                             into p_lp_id_lpc
                           from ListaPrecioConfig i
                           where pr_id = p_pr_id
                             and lpc_orden = v_lpc_orden;

                           p_lp_id_lpc := coalesce(p_lp_id_lpc, 0);

                         end;
                        end if;

                      end;
                     end if;

                  end if;

               end if;
            end if;

            -- Busco un precio en esta lista
            --
            select lpi_precio, lpm_id
              into v_precio, v_lpm_id_precio
            from ListaPrecioItem
            where lp_id = p_lp_id
              and pr_id = p_pr_id
              and ( lp_id = p_lp_id_lpc or p_lp_id_lpc = 0 );

            -- Si tengo una lista de marcado
            --
            if coalesce(v_precio, 0) <> 0
               and v_lpm_id_precio is not null
               and v_isForCompra = 0
            then

               select sp_lp_get_precio_marcado(v_lpm_id_precio, v_mon_id) into v_precio;

            end if;

            -- Sino hay precio
            --
            if coalesce(v_precio, 0) = 0 then
               -- Si es la primear llamada creo las tablas
               --
               if v_createTable <> 0 then

                    create temporary table tt_precios
                    (
                      lpi_precio decimal(18,6),
                      lpi_porcentaje decimal(18,6),
                      lp_id_padre integer,
                      lp_id integer,
                      lpm_id integer
                    ) on commit drop;

                    create temporary table tt_listas
                    (
                      lp_id integer  not null,
                      lp_porcglobal decimal(18,6),
                      N integer,
                      mon_id integer,
                      lpm_id integer
                    ) on commit drop;

                  v_createTable := 0;
               end if;

               -- inserto el porcentaje si lo hay
               -- sobre este articulo
               --
               insert into tt_precios( lpi_precio, lpi_porcentaje, lp_id_padre, lp_id, lpm_id )
                 ( select 0,
                          lpi_porcentaje,
                          p_lp_id_padre,
                          p_lp_id,
                          lpm_id
                   from ListaPrecioItem
                   where lp_id = p_lp_id
                     and pr_id = p_pr_id );

               -------------------------------------------------------------------------------
               -- inserto todas las listas bases de esta lista
               --
               -- viejo esquema
               --
               insert into tt_listas( lp_id, lp_porcglobal, N, mon_id )
                 ( select lp_id,
                          v_lp_porcentaje,
                          v_n,
                          mon_id
                   from ListaPrecio lp
                   where exists ( select *
                                  from ListaPrecio
                                  where lp_id = p_lp_id
                                    and lp_id_padre = lp.lp_id )
                     and activo <> 0 );

               -- nuevo esquema
               --
               insert into tt_listas( lp_id, lp_porcglobal, N, mon_id, lpm_id )
                 ( select lpl.lp_id_padre,
                          lpl.lpl_porcentaje,
                          v_n,
                          lp.mon_id,
                          lpl.lpm_id
                   from ListaPrecioLista lpl
                   join ListaPrecio lp
                     on lpl.lp_id_padre = lp.lp_id
                   where lpl.lp_id = p_lp_id
                     and lp.activo <> 0 );

               loop

                 if not exists ( select * from tt_listas where n = v_n ) then
                   exit;
                 end if;

                 v_lpm_id := null;
                 v_lpm_id_lista := null;
                 v_mon_id_base := null;
                 v_lpi_porcentaje := 0;
                 v_lp_porcglobal := 0;

                 -- Obtengo la primera lista base
                 --
                 select min(lp_id) into v_lp_id from tt_listas where n = v_n;

                 -- obtengo el porcentaje global y el porcentaje sobre articulo para esta lista base
                 --
                 select lpi_porcentaje, lpm_id
                   into v_lpi_porcentaje, v_lpm_id
                 from tt_precios
                 where lp_id = p_lp_id;

                 select lp_porcglobal, mon_id, lpm_id
                   into v_lp_porcglobal, v_mon_id_base, v_lpm_id_lista
                 from tt_listas
                 where lp_id = v_lp_id;

                 -- La saco de la bolsa de listas pendientes
                 --
                 delete from tt_listas where lp_id = v_lp_id;

                 select sp_lp_get_precio(
                              v_lp_id,
                              p_pr_id,
                              0,
                              p_lp_id,
                              v_n,
                              p_noUseCache,
                              p_lp_id_lpc,
                              v_isForCompra)
                 into v_precio;

                 -- Si tengo un precio
                 --
                 if v_precio <> 0 then
                    -- Le aplico los porcentajes
                    --
                    v_precio := v_precio
                                + (v_precio * coalesce(v_lp_porcglobal, 0) / 100)
                                + (v_precio * coalesce(v_lpi_porcentaje, 0) / 100);

                    -- Si tengo una lista de marcado sobre el articulo
                    --
                    if v_lpm_id is not null then

                       select sp_lp_get_precio_marcado(v_lpm_id, v_mon_id_base) into v_precio;

                    end if;

                    -- Si tengo una lista de marcado sobre la lista
                    --
                    if v_lpm_id_lista is not null then

                       select sp_lp_get_precio_marcado(v_lpm_id_lista, v_mon_id_base) into v_precio;

                    end if;

                    -- Si la moneda de la lista es distinta
                    -- a la de la base (es decir a la del precio)
                    --
                    if v_mon_id <> v_mon_id_base then

                       -- Si la moneda de la lista es la moneda default
                       --
                       select mon_legal
                         into v_mon_default
                       from Moneda
                       where mon_id = v_mon_id;

                       -- Voy a tener que pasar a pesos el precio
                       -- de la base ya que encontre un precio en dolares u otra moneda
                       -- distinta a pesos (obvio el ejemplo es pa Argentina che)
                       --
                       if v_mon_default <> 0 then

                          -- Obtengo la cotizacion de la lista base
                          --
                          select sp_moneda_get_cotizacion(v_mon_id_base, v_fecha) into v_cotiz;

                          -- Paso a Pesos el precio (sigo en argentino pue)
                          --
                          v_precio := v_precio * v_cotiz;

                       -- Ahora bien si la moneda de la lista no es la moneda default
                       -- (pesos pa los argentinos {quien sabe por cuanto tiempo no :) })
                       --
                       else

                          -- Veamos si la lista base esta en pesos
                          --
                          select mon_legal
                            into v_mon_default
                          from Moneda
                          where mon_id = v_mon_id_base;

                          if v_mon_default <> 0 then

                             -- Ok la base esta en pesos asi que obtengo la cotizacion de la lista
                             -- para la que se me pidio el precio
                             --
                             select sp_moneda_get_cotizacion(v_mon_id, v_fecha) into v_cotiz;

                             -- Si hay cotizacion, divido el precio y guala, tengo
                             -- el precio expresado en dolares o yerbas similares
                             --
                             if v_cotiz <> 0 then

                                v_precio := v_precio / v_cotiz;

                             else

                                v_precio := 0;-- :( sin cotizacion no hay precio

                             end if;

                          else

                             -- Ok, al chango se le ocurrio comprar en dolares y vender en reales
                             -- entonces paso los dolares a pesos y luego los pesos a reales y listo
                             --
                             select sp_moneda_get_cotizacion(v_mon_id_base, v_fecha) into v_cotiz;

                             select sp_moneda_get_cotizacion(v_mon_id, v_fecha) into v_cotiz2;

                             v_precio := v_precio * v_cotiz;

                             -- Si hay cotizacion, divido el precio y guala, tengo
                             -- el precio expresado en dolares o yerbas similares
                             --
                             if v_cotiz2 <> 0 then

                                v_precio := v_precio / v_cotiz2;

                             else

                                v_precio := 0;-- :( sin cotizacion no hay precio

                             end if;

                          end if;

                       end if;

                    end if;

                    if not exists(select 1 from tt_precios where lp_id = v_lp_id) then

                       insert into tt_precios( lpi_precio, lpi_porcentaje, lp_id_padre, lp_id, lpm_id )
                                      values ( v_precio, 0, p_lp_id, 0, 0 );

                    else
                       -- Aplico al precio de la lista base el porcentaje global y el porcentaje sobre articulo
                       --
                       update tt_precios set lpi_precio = v_precio where lp_id = v_lp_id;

                    end if;

                 end if;
               end loop;

               -----------------------------------------------------------------------------------------
               -- while

               -- Si no encontre precios en esta lista devuelvo 0
               --
               if not exists( select 1 from tt_precios where lpi_precio <> 0) then

                  v_precio := 0;

               else

                  select min(lpi_precio)
                    into v_precio
                  from tt_precios
                  where lp_id_padre = p_lp_id
                    and lpi_precio > 0;

               end if;

            end if;

            --if IsNull(@precio,0) = 0 begin
            -- Ahora aplico las condiciones de redondeo de la lista
            -- solo si estoy en la primera llamada
            --
            if v_n = 1 and v_precio <> 0 then
             declare
               v_pr_noredondeo smallint;
             begin
               select pr_noredondeo
                 into v_pr_noredondeo
               from Producto
               where pr_id = p_pr_id;

               if v_pr_noredondeo = 0 then
                declare
                  v_bRedondear integer;
                begin

                  -- Veo si hay que redondear
                  --
                  select sp_cfg_getValor('Ventas-General', 'Redondear Decimales en Precios') into v_cfg_valor;

                  if isnumeric(v_cfg_valor) = 0 then
                     v_bRedondear := 0;
                  else
                     v_bRedondear := to_number(v_cfg_valor);
                  end if;

                  if v_bRedondear <> 0 and v_isForCompra = 0 then
                   declare
                     v_decimales integer;
                     v_precio_entero integer;
                   begin
                     -- Obtengo la cantidad de decimales
                     --
                     select sp_cfg_getValor('Ventas-General', 'Decimales en Precios') into v_cfg_valor;

                     if isnumeric(v_cfg_valor) <> 0 then
                        v_decimales := to_number(v_cfg_valor);
                     else
                        v_decimales := 0;
                     end if;

                     v_precio := round(v_precio, v_decimales);

                     v_precio_entero := v_precio;

                     -- Solo si el precio es entero
                     --
                     if v_precio_entero = v_precio then
                      declare
                        v_centavos decimal(18,6);
                      begin

                        -- Veo cuantos centavos le quiere restar
                        -- a los importes enteros
                        --
                        select sp_cfg_getValor('Ventas-General', 'Restar a precios enteros') into v_cfg_valor;

                        if isnumeric(v_cfg_valor) <> 0 then
                           v_centavos := to_number(v_cfg_valor);
                        else
                           v_centavos := 0;
                        end if;

                        if v_centavos <> 0 then

                           v_precio := v_precio - v_centavos;

                        end if;

                      end;
                     end if;

                   end;
                  end if;

                end;
               end if;

             end;
            end if;

         end if;

       end;
      end if;

   end if;

   p_precio := coalesce(v_precio, 0);

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_lp_get_precio(integer, integer, integer, integer, integer, integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_lp_get_precioMarcado()

-- drop function sp_lp_get_precioMarcado(integer, integer, integer, varchar, integer, integer, varchar);
/*
          select * from listapreciomarcado
          select * from sp_lp_get_precioMarcado(1,1);
*/
create or replace function sp_lp_get_precioMarcado
(
  in p_lpm_id integer,
  in p_mon_id integer,
  out p_precio decimal(18,6)
)
  returns decimal(18,6) as
$BODY$
declare
   v_mon_default smallint;
   v_cotiz decimal(18,6);
   v_cotiz2 decimal(18,6);
   v_saltos decimal(18,6);
   v_precio2 decimal(18,6);
   v_lpm_base decimal(18,6);
   v_lpm_porcentaje decimal(18,6);
   v_lpm_salto decimal(18,6);
   v_lpm_decremento decimal(18,6);
   v_lpm_porcminimo decimal(18,6);
   v_lpm_porcmaximo decimal(18,6);
   v_lpm_montominimo decimal(18,6);
   v_mon_id_marcado integer;
   v_lpm_activo smallint;
   v_fecha date;
begin

   v_fecha := CURRENT_TIMESTAMP;

   select lpm_base,
          lpm_porcentaje,
          lpm_salto,
          lpm_decremento,
          lpm_porcminimo,
          lpm_porcmaximo,
          lpm_montominimo,
          mon_id,
          activo
     into v_lpm_base,
          v_lpm_porcentaje,
          v_lpm_salto,
          v_lpm_decremento,
          v_lpm_porcminimo,
          v_lpm_porcmaximo,
          v_lpm_montominimo,
          v_mon_id_marcado,
          v_lpm_activo
   from ListaPrecioMarcado
   where lpm_id = p_lpm_id;

   -- Solo operamos si hay salto
   --
   if v_lpm_salto > 0 and v_lpm_activo <> 0 then

      --------------------------------------------------------------------------------
      -- Tratamiento de Monedas entre Listas
      --
      --
      -- Si la moneda de la lista es distinta
      -- a la del marcado de la base (es decir a la del precio)
      --
      if p_mon_id <> v_mon_id_marcado then

         -- Si la moneda de la lista es la moneda default
         --
         select mon_legal
           into v_mon_default
         from Moneda
         where mon_id = p_mon_id;

         -- Voy a tener que pasar a pesos el precio
         -- de la base ya que encontre un precio en dolares u otra moneda
         -- distinta a pesos (obvio el ejemplo es pa Argentina che)
         --
         if v_mon_default <> 0 then

            -- Obtengo la cotizacion de la lista base
            --
            select sp_moneda_get_cotizacion(v_mon_id_marcado, v_fecha) into v_cotiz;

            -- Paso a Pesos el precio (sigo en argentino pue)
            --
            v_lpm_montominimo := v_lpm_montominimo * v_cotiz;

            v_lpm_base := v_lpm_base * v_cotiz;

         -- Ahora bien si la moneda de la lista no es la moneda default
         -- (pesos pa los argentinos {quien sabe por cuanto tiempo no :) })
         --
         else

            -- Veamos si la lista base esta en pesos
            --
            select mon_legal
              into v_mon_default
            from Moneda
            where mon_id = v_mon_id_marcado;

            if v_mon_default <> 0 then

               -- Ok la base esta en pesos asi que obtengo la cotizacion de la lista
               -- para la que se me pidio el precio
               --
               select sp_moneda_get_cotizacion(p_mon_id, v_fecha) into v_cotiz;

               -- Si hay cotizacion, divido el precio y guala, tengo
               -- el precio expresado en dolares o yerbas similares
               --
               if v_cotiz <> 0 then

                  v_lpm_montominimo := v_lpm_montominimo / v_cotiz;
                  v_lpm_base := v_lpm_base / v_cotiz;

               else

                  v_lpm_montominimo := 0;-- :( sin cotizacion no hay precio
                  v_lpm_base := 0;

               end if;

            else

               -- Ok, al chango se le ocurrio comprar en dolares y vender en reales
               -- entonces paso los dolares a pesos y luego los pesos a reales y listo
               --
               select sp_moneda_get_cotizacion(v_mon_id_marcado, v_fecha) into v_cotiz;
               select sp_moneda_get_cotizacion(p_mon_id, v_fecha) into v_cotiz2;

               v_lpm_montominimo := v_lpm_montominimo * v_cotiz;
               v_lpm_base := v_lpm_base * v_cotiz;

               -- Si hay cotizacion, divido el precio y guala, tengo
               -- el precio expresado en dolares o yerbas similares
               --
               if v_cotiz2 <> 0 then

                  v_lpm_montominimo := v_lpm_montominimo / v_cotiz2;
                  v_lpm_base := v_lpm_base / v_cotiz2;

               else

                  v_lpm_montominimo := 0;-- :( sin cotizacion no hay precio
                  v_lpm_base := 0;

               end if;
            end if;
         end if;
      end if;

      --
      -- FIN Tratamiento de Monedas entre Listas
      --------------------------------------------------------------------------------

      -- Obtenemos y aplicamos el porcentaje
      --
      v_saltos := (p_precio - v_lpm_base) / v_lpm_salto;

      v_lpm_porcentaje := v_lpm_porcentaje - (v_lpm_decremento * v_saltos);

      if v_lpm_porcentaje < v_lpm_porcminimo then

         v_lpm_porcentaje := v_lpm_porcminimo;

      end if;

      v_precio2 := p_precio * (1 + v_lpm_porcentaje / 100);

      -- Monto Minimo y Porcentaje Maximo
      --
      if (v_precio2 - p_precio) < v_lpm_montominimo then

         v_precio2 := p_precio + v_lpm_montominimo;

      end if;

      if (((v_precio2 / p_precio) - 1) * 100) > v_lpm_porcmaximo then

         v_precio2 := p_precio * (1 + v_lpm_porcmaximo / 100);

      end if;

      -- Finalmente devolvemos el precio
      --
      p_precio := v_precio2;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_lp_get_precioMarcado(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_moneda_get_cotizacion()

-- drop function sp_moneda_get_cotizacion(integer, date);
-- select * from monedaitem
-- select sp_moneda_get_cotizacion(3,'20041231', 0::smallint);
create or replace function sp_moneda_get_cotizacion
(
  in p_mon_id integer,
  in p_fecha date,
  out p_cotiz decimal(18,6)
)
  returns decimal as
$BODY$
declare
      v_cfg_valor varchar(5000);
begin


   if not exists ( select mon_id
                   from Moneda
                   where mon_id = p_mon_id
                     and mon_legal <> 0 ) then

      select sp_cfg_getValor('General', 'Decimales Cotización') into v_cfg_valor;

      v_cfg_valor := coalesce(v_cfg_valor, '3');

      if isnumeric(v_cfg_valor) = 0 then
         v_cfg_valor := '3';
      end if;

      select *
        into p_cotiz
      from ( select moni_precio
             from MonedaItem
             where mon_id = p_mon_id
               and moni_fecha <= p_fecha
             order by moni_fecha desc ) t
      limit 1;

   end if;

   p_cotiz := coalesce(p_cotiz, 0);

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_moneda_get_cotizacion(integer, date)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_movimiento_caja_get_caja_for_user()

-- drop function sp_movimiento_caja_get_caja_for_user(integer, integer);

/*
          select * from sp_movimiento_caja_get_caja_for_user(1,2);
          fetch all from rtn;

*/

create or replace function sp_movimiento_caja_get_caja_for_user
(
  in p_us_id integer,
  in p_emp_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_cj_id integer;
begin

   rtn := 'rtn';

   if exists ( select cj.cj_id
                from CajaCajero cjc
                join Caja cj
                  on cjc.cj_id = cj.cj_id
                where cjc.us_id = p_us_id
                  and cj.emp_id = p_emp_id
                  and cj.activo <> 0 ) then

      select min(cj_id)
        into v_cj_id
      from MovimientoCaja mcj
      where mcj_tipo = 1
        and cj_id in ( select cc.cj_id
                       from CajaCajero cc
                       inner join Caja cj on cc.cj_id = cj.cj_id
                       where cc.us_id = p_us_id
                         and cj.emp_id = p_emp_id
                     )
        and not exists ( select *
                         from MovimientoCaja
                         where cj_id = mcj.cj_id
                           and mcj_id > mcj.mcj_id
                           and mcj_tipo = 2 );

      if v_cj_id is null then
         open rtn for
            select 0 success,
                   '' info,
                   'El usuario esta configurado como cajero, pero no existe ninguna caja en estado "Abierta" asociada a este cajero. Debe abrir la caja para poder operar.' warning,
                   v_cj_id cj_id,
                   '' cj_nombre,
                   '' cj_codigo;

      else
         open rtn for
            select 0 success,
                   'Estas operaciones de venta trabajar n con la caja: ' || cj_nombre || ' [' || cj_codigo || '].' info,
                   '' warning,
                   v_cj_id cj_id,
                   cj_nombre,
                   cj_codigo
            from Caja
            where cj_id = v_cj_id;

      end if;

   else

      open rtn for
         select 1 success,
                '' info,
                '' warning,
                null cj_id,
                '' cj_nombre,
                '' cj_codigo;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_movimiento_caja_get_caja_for_user(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_productocomprahelp()

-- drop function sp_productocomprahelp(integer, integer, integer, varchar, integer, integer, varchar, integer);

create or replace function sp_productocomprahelp
/*
          select * from sp_ProductoCompraHelp(1,1,1,'hp%',0,0); fetch all from rtn;
          select * from sp_ProductoCompraHelp(1,1,0,'Impresora Deskjet 450ci',1,26); fetch all from rtn;
*/
(
  in p_emp_id integer,
  in p_us_id integer,
  in p_bForAbm integer,
  in p_filter varchar default '',
  in p_check integer default 0,
  in p_pr_id integer default 0,
  in p_filter2 varchar default '',
  in p_prhc_id integer default 0,
  out rtn refcursor
)
  returns refcursor as
$BODY$
begin

   p_filter := lower(f_unaccent(p_filter));

   rtn := 'rtn';

   if p_check <> 0 then

      open rtn for
         select pr_id,
                pr_nombrecompra Nombre,
                pr_codigo Codigo
         from Producto
         where ( lower(f_unaccent(pr_nombrecompra)) = p_filter
                or lower(f_unaccent(pr_codigo)) = p_filter )
           and ( activo <> 0 or p_bForAbm <> 0 )
           and ( pr_id = p_pr_id or p_pr_id = 0 )
           and pr_secompra <> 0;

   else

      open rtn for
         select pr_id,
                pr_nombrecompra Nombre,
                pr_descripcompra Observaciones,
                pr_codigo Codigo
         from Producto
         where ( lower(f_unaccent(pr_codigo)) like '%' || p_filter || '%'
                 or lower(f_unaccent(pr_nombrecompra)) like '%' || p_filter || '%'
                 or lower(f_unaccent(pr_descripcompra)) like '%' || p_filter || '%'
                 or p_filter is null )
           and ( activo <> 0 or p_bForAbm <> 0 )
           and pr_secompra <> 0
         limit 50;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_productocomprahelp(integer, integer, integer, varchar, integer, integer, varchar, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_producto_get()

-- drop function sp_producto_get(integer);

create or replace function sp_producto_get
(
  in p_pr_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
begin

   rtn := 'rtn';

   begin
      open rtn for
         select Producto.*,

                tiric.ti_nombre as ti_name_ri_compra,
                tiriv.ti_nombre as ti_name_ri_venta,

                tirnic.ti_nombre as rnic,
                tirniv.ti_nombre as rniv,

                tic.ti_nombre as ti_name_int_compra,
                tiv.ti_nombre as ti_name_int_venta,

                tuc.un_nombre as un_name_compra,
                tuv.un_nombre as un_name_venta,
                tus.un_nombre as un_name_stock,

                tup.un_nombre as un_name_peso,

                tcc.cueg_nombre as cueg_name_compra,
                tcv.cueg_nombre as cueg_name_venta,

                marc_nombre,
                ibc_nombre,
                rub_nombre,

                rti1.rubti_nombre rubti_name1,
                rti2.rubti_nombre rubti_name2,
                rti3.rubti_nombre rubti_name3,
                rti4.rubti_nombre rubti_name4,
                rti5.rubti_nombre rubti_name5,
                rti6.rubti_nombre rubti_name6,
                rti7.rubti_nombre rubti_name7,
                rti8.rubti_nombre rubti_name8,
                rti9.rubti_nombre rubti_name9,
                rti10.rubti_nombre rubti_name10,

                embl_nombre,
                egp.egp_nombre,
                efm.efm_nombre,
                tas.ta_nombre as ta_name_kit_serie,
                tal.ta_nombre as ta_name_kit_lote,

                ley.ley_nombre,

                ccosc.ccos_nombre as ccos_name_compra,
                ccosv.ccos_nombre as ccos_name_venta,

                cur.cur_nombre,

                rptcompra.rpt_nombre as rpt_name_compra,
                rptventa.rpt_nombre as rpt_name_venta,
                rptfactura.rpt_nombre as rpt_name_factura,
                rptweb.rpt_nombre as rpt_name_web,
                rptimg.rpt_nombre as rpt_name_img,
                rptimgalt.rpt_nombre as rpt_name_img_alt,

                ticomexgan.ti_nombre as ti_name_comex_ganancias,
                ticomexigb.ti_nombre as ti_name_comex_igb,
                ticomexiva.ti_nombre as ti_name_comex_iva,
                prwebpadre.pr_nombrecompra as pr_nombre_web_padre,

                poar.poar_nombre

           from Producto
                  left join RubroTablaItem rti1
                   on Producto.rubti_id1 = rti1.rubti_id
                  left join RubroTablaItem rti2
                   on Producto.rubti_id2 = rti2.rubti_id
                  left join RubroTablaItem rti3
                   on Producto.rubti_id3 = rti3.rubti_id
                  left join RubroTablaItem rti4
                   on Producto.rubti_id4 = rti4.rubti_id
                  left join RubroTablaItem rti5
                   on Producto.rubti_id5 = rti5.rubti_id
                  left join RubroTablaItem rti6
                   on Producto.rubti_id6 = rti6.rubti_id
                  left join RubroTablaItem rti7
                   on Producto.rubti_id7 = rti7.rubti_id
                  left join RubroTablaItem rti8
                   on Producto.rubti_id8 = rti8.rubti_id
                  left join RubroTablaItem rti9
                   on Producto.rubti_id9 = rti9.rubti_id
                  left join RubroTablaItem rti10
                   on Producto.rubti_id10 = rti10.rubti_id
                  left join Unidad tuv
                   on Producto.un_id_venta = tuv.un_id
                  left join Unidad tuc
                   on Producto.un_id_compra = tuc.un_id
                  left join Unidad tus
                   on Producto.un_id_stock = tus.un_id
                  left join Unidad tup
                   on Producto.un_id_peso = tup.un_id
                  left join TasaImpositiva tiric
                   on Producto.ti_id_ivaricompra = tiric.ti_id
                  left join TasaImpositiva tiriv
                   on Producto.ti_id_ivariventa = tiriv.ti_id
                  left join TasaImpositiva tirnic
                   on Producto.ti_id_ivarnicompra = tirnic.ti_id
                  left join TasaImpositiva tirniv
                   on Producto.ti_id_ivarniventa = tirniv.ti_id
                  left join TasaImpositiva tic
                   on Producto.ti_id_internosc = tic.ti_id
                  left join TasaImpositiva tiv
                   on Producto.ti_id_internosv = tiv.ti_id
                  left join CuentaGrupo tcv
                   on Producto.cueg_id_venta = tcv.cueg_id
                  left join CuentaGrupo tcc
                   on Producto.cueg_id_compra = tcc.cueg_id
                  left join IngresosBrutosCategoria
                   on Producto.ibc_id = IngresosBrutosCategoria.ibc_id
                  left join Rubro
                   on Producto.rub_id = Rubro.rub_id
                  left join Marca
                   on Producto.marc_id = Marca.marc_id
                  left join Embalaje
                   on Producto.embl_id = Embalaje.embl_id
                  left join ExpoGrupoPrecio egp
                   on Producto.egp_id = egp.egp_id
                  left join ExpoFamilia efm
                   on Producto.efm_id = efm.efm_id
                  left join Talonario tas
                   on Producto.ta_id_kitSerie = tas.ta_id
                  left join Talonario tal
                   on Producto.ta_id_kitLote = tal.ta_id
                  left join Leyenda ley
                   on Producto.ley_id = ley.ley_id
                  left join CentroCosto ccosc
                   on Producto.ccos_id_compra = ccosc.ccos_id
                  left join CentroCosto ccosv
                   on Producto.ccos_id_venta = ccosv.ccos_id
                  left join Curso cur
                   on Producto.cur_id = cur.cur_id
                  left join Reporte rptcompra
                   on Producto.rpt_id_nombrecompra = rptcompra.rpt_id
                  left join Reporte rptventa
                   on Producto.rpt_id_nombreventa = rptventa.rpt_id
                  left join Reporte rptfactura
                   on Producto.rpt_id_nombrefactura = rptfactura.rpt_id
                  left join Reporte rptweb
                   on Producto.rpt_id_nombreweb = rptweb.rpt_id
                  left join Reporte rptimg
                   on Producto.rpt_id_nombreimg = rptimg.rpt_id
                  left join Reporte rptimgalt
                   on Producto.rpt_id_nombreimgalt = rptimgalt.rpt_id
                  left join TasaImpositiva ticomexgan
                   on Producto.ti_id_comex_ganancias = ticomexgan.ti_id
                  left join TasaImpositiva ticomexigb
                   on Producto.ti_id_comex_igb = ticomexigb.ti_id
                  left join TasaImpositiva ticomexiva
                   on Producto.ti_id_comex_iva = ticomexiva.ti_id
                  left join PosicionArancel poar
                   on Producto.poar_id = poar.poar_id
                  left join Producto prwebpadre
                   on Producto.pr_id_webpadre = prwebpadre.pr_id
            where Producto.pr_id = p_pr_id;

   end;
end;

$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_producto_get(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_producto_get_cue_id()

-- drop function sp_producto_get_cue_id(integer, integer, integer);

create or replace function sp_producto_get_cue_id
/*
	select * from cliente
	select * from Producto
	select * from cuenta where cue_id = 129
	select * from sp_producto_get_cue_id(6,null,12);
*/
(
  in p_cli_id integer,
  in p_prov_id integer,
  in p_pr_id integer,
  out p_cue_id integer
)
  returns integer as
$BODY$
declare
    v_cue_id integer;
begin

    if p_cli_id is not null then
    
        -- Obtengo la cuenta de ventas
        --
        select ClienteCuentaGrupo.cue_id
        into v_cue_id
        from ClienteCuentaGrupo
        join Producto
          on ClienteCuentaGrupo.cueg_id = Producto.cueg_id_venta
        where cli_id = p_cli_id
          and pr_id = p_pr_id;

        -- Saco la cuenta de CuentaGrupo
        --
        if v_cue_id is null then

           select CuentaGrupo.cue_id
           into v_cue_id
           from CuentaGrupo
           join Producto
            on CuentaGrupo.cueg_id = Producto.cueg_id_venta
           where Producto.pr_id = p_pr_id;

        end if;
    
    else

        -- Obtengo la cuenta de compras
        --
        select ProveedorCuentaGrupo.cue_id
        into v_cue_id
        from ProveedorCuentaGrupo
        join Producto
          on ProveedorCuentaGrupo.cueg_id = Producto.cueg_id_compra
        where prov_id = p_prov_id
          and pr_id = p_pr_id;

        -- Saco la cuenta de CuentaGrupo
        --
        if v_cue_id is null then

           select CuentaGrupo.cue_id
           into v_cue_id
           from CuentaGrupo
           join Producto
            on CuentaGrupo.cueg_id = Producto.cueg_id_compra
           where Producto.pr_id = p_pr_id;

        end if;
    
    end if;
    
    p_cue_id := v_cue_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_producto_get_cue_id(integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_producto_get_proveedores()

-- drop function sp_producto_get_proveedores(integer);

create or replace function sp_producto_get_proveedores
(
  in p_pr_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   -- Obtengo que precio es el preferido en ListaPrecioConfig
   --
   v_lp_id_top integer;
   v_orden numeric(3,0);
   v_tran_id integer;
begin

    --------------------------------------------------------------------
    
    create TEMP table t_producto_proveedor
    (
      prov_id integer,
      lp_id integer,
      lpi_id integer,
      lpi_precio decimal(18,6),
      lpi_top integer,
      lpi_fecha date,
      tran_id integer  not null
    ) on commit drop;
    
    v_tran_id := nextval('t_producto_proveedor_seq');
    
    --------------------------------------------------------------------
   
   insert into t_producto_proveedor
     ( prov_id, lp_id, lpi_id, lpi_precio, lpi_top, lpi_fecha, tran_id )
     ( select DISTINCT lpprov.prov_id,
                       lpi.lp_id,
                       lpi.lpi_id,
                       lpi.lpi_precio,
                       0,
                       lpi.lpi_fecha,
                       v_tran_id
       from ListaPrecioItem lpi
              left join ListaPrecioProveedor lpprov
               on lpi.lp_id = lpprov.lp_id
          where lpi.pr_id = p_pr_id );

   select min(lpc_orden)
     into v_orden
     from ListaPrecioConfig
      where pr_id = p_pr_id
              and lp_id in ( select lp_id
                             from t_producto_proveedor  );

   select lp_id
     into v_lp_id_top
     from ListaPrecioConfig
      where pr_id = p_pr_id
              and lpc_orden = v_orden;

   update t_producto_proveedor
      set lpi_top = 1
      where tran_id = v_tran_id and lp_id = v_lp_id_top;

   rtn := 'rtn';

   open rtn for
      ----------------------------------------------------------------------------------------------
      select prprov.prprov_id,
                     prprov.prprov_codigo,
                     prprov.prprov_codigobarra,
                     prprov.prprov_fabricante,
                     prprov.prprov_nombre,
                     prprov.activo,
                     prprov.creado,
                     prprov.modificado,
                     prprov.modifico,
                     prprov.pa_id,
                     prprov.pr_id,
                     prov.prov_id,
                     prov_nombre,
                     pa_nombre,
                     lp_nombre,
                     t.lp_id,
                     t.lpi_id,
                     t.lpi_precio,
                     t.lpi_fecha,
                     t.lpi_top
        from ProductoProveedor prprov
               left join Proveedor prov
                on prprov.prov_id = prov.prov_id
               left join Pais pa
                on prprov.pa_id = pa.pa_id
               left join t_producto_proveedor t
                on prprov.prov_id = t.prov_id
                  and t.tran_id = v_tran_id
               left join ListaPrecio lp
                on t.lp_id = lp.lp_id
         where prprov.pr_id = p_pr_id
      union all
      select -1 prprov_id,-- Si es un registro virtual lo identifico con un -1

             prprov.prprov_codigo,
             prprov.prprov_codigobarra,
             prprov.prprov_fabricante,
             prprov.prprov_nombre,
             prprov.activo,
             prprov.creado,
             prprov.modificado,
             prprov.modifico,
             prprov.pa_id,
             prprov.pr_id,
             prov.prov_id,
             prov_nombre,
             pa_nombre,
             lp_nombre,
             t.lp_id,
             t.lpi_id,
             t.lpi_precio,
             t.lpi_fecha,
             t.lpi_top

        from t_producto_proveedor t
               left join ProductoProveedor prprov
                on 1 = 2
               left join Proveedor prov
                on t.prov_id = prov.prov_id
               left join Pais pa
                on 1 = 2
               left join ListaPrecio lp
                on t.lp_id = lp.lp_id

        where t.tran_id = v_tran_id
           and not exists ( select *
                            from ProductoProveedor
                               where pr_id = p_pr_id
                                       and prov_id = t.prov_id )
        order by prov_nombre;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_producto_get_proveedores(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_producto_get_tasas()

-- drop function sp_producto_get_tasas(integer, integer, integer, varchar, integer, integer, varchar);

create or replace function sp_producto_get_tasas
/*
 select * from sp_producto_get_tasas(3);
 fetch all from rtn;
*/
(
  in p_pr_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
begin

    rtn := 'rtn';

    open rtn for
         select pr.ti_id_ivaricompra,
                pr.ti_id_ivarnicompra,
                tiric.ti_porcentaje as ti_ri_porc_compra,
                tirnic.ti_porcentaje as ti_rni_porc_compra,
                tiric.cue_id as cue_id_ri_compra,
                tirnic.cue_id as cue_id_rni_compra,

                pr.ti_id_ivariventa,
                pr.ti_id_ivarniventa,
                tiriv.ti_porcentaje as ti_ri_porc_venta,
                tirniv.ti_porcentaje as ti_rni_porc_venta,
                tiriv.cue_id as cue_id_ri_venta,
                tirniv.cue_id as cue_id_rni_venta,

                pr.ti_id_internosc,
                pr.ti_id_internosv,
                tiintc.ti_porcentaje as ti_int_porc_compra,
                tiintv.ti_porcentaje as ti_int_porc_venta,

                pr.pr_porcinternoc,
                pr.pr_porcinternov
         from Producto pr
         left join TasaImpositiva tiric  on pr.ti_id_ivaricompra = tiric.ti_id
         left join TasaImpositiva tirnic on pr.ti_id_ivarnicompra = tirnic.ti_id
         left join TasaImpositiva tiriv  on pr.ti_id_ivariventa = tiriv.ti_id
         left join TasaImpositiva tirniv on pr.ti_id_ivarniventa = tirniv.ti_id
         left join TasaImpositiva tiintc on pr.ti_id_internosc = tiintc.ti_id
         left join TasaImpositiva tiintv on pr.ti_id_internosv = tiintv.ti_id
         where pr.pr_id = p_pr_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_producto_get_tasas(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012    Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.    See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_producto_kit_lleva_serie()

-- drop function sp_producto_kit_lleva_serie(integer, smallint, integer);

create or replace function sp_producto_kit_lleva_serie
/*
          select * from Producto where pr_eskit <> 0;
          select * from sp_producto_kit_lleva_serie(45);
*/
(
    in ip_pr_id integer,
    in p_bCreateTable smallint default 1,
    in ip_prfk_id integer default null,
    out p_bResult smallint
)
    returns smallint as
$BODY$
declare
    p_prfk_id integer := ip_prfk_id;
    p_pr_id integer := ip_pr_id;
    v_nivel integer;
begin

    p_bResult := 0;

    if p_prfk_id is null then
        select prfk_id
         into p_prfk_id
        from ProductoFormulaKit
        where pr_id = p_pr_id
          and prfk_default <> 0;

    end if;

    -- Averiguo si este producto lleva numero de serie
    if exists ( select pr_id
                from Producto
                where pr_id = p_pr_id
                  and pr_llevanroserie <> 0 ) then

        p_bResult := 1;

    else

    begin
        -- Solo se crea la tabla en la primera llamada
        if p_bCreateTable <> 0 then
            create temporary table tt_KitItems
              (
                 pr_id integer    not null,
                 nivel integer    not null
              ) on commit drop;
        end if;

        -- Agrego los items de este kit
        select max(nivel)
         into v_nivel
        from tt_KitItems ;

        v_nivel := coalesce(v_nivel, 0) + 1;

        insert into tt_KitItems
         ( pr_id, nivel )
         ( select pr_id_item,
                  v_nivel
           from ProductoKit
           where prfk_id = p_prfk_id );

        loop

            if not exists ( select *
                            from tt_KitItems
                            where nivel = v_nivel ) then
              exit;
            end if;

            select min(pr_id)
             into p_pr_id
            from tt_KitItems
            where nivel = v_nivel;

            select sp_producto_kit_lleva_serie(p_pr_id, 0) into p_bResult;

            if p_bResult <> 0 then

            RETURN;

            end if;

            -- Este ya lo procese asi que lo borro
            delete from tt_KitItems where pr_id = p_pr_id;

        end loop;

    end;
    end if;

end;
$BODY$
    language plpgsql volatile
    cost 100;
alter function sp_producto_kit_lleva_serie(integer, smallint, integer)
    owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_producto_stock_get_data()

-- drop function sp_producto_stock_get_data(integer, integer, integer);

create or replace function sp_producto_stock_get_data
/*
          select * from producto where pr_llevastock <> 0;
          select * from proveedor;
          select * from sp_producto_stock_get_data(4, null, 1);
          fetch all from rtn;
*/
(
  in p_pr_id integer,
  in p_cli_id integer,
  in p_prov_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_cue_id_compra integer;
   v_cue_id_venta integer;
begin

   select * from sp_producto_get_cue_id(
                       p_cli_id,
                       null,
                       p_pr_id)
                       into v_cue_id_venta;

   select * from sp_producto_get_cue_id(
                       null,
                       p_prov_id,
                       p_pr_id)
                       into v_cue_id_compra;

   rtn := 'rtn';

   -- Si es un kit la cosa se pone mas complicada ya que hay que fijarse
   -- si las componentes del kit llevan stock y numero de serie
   --
   if exists ( select pr_id
               from Producto
               where pr_id = p_pr_id
                 and pr_eskit <> 0 ) then
       declare
          v_bLlevaNroSerie smallint;
          v_unidad varchar(255);
          -- Esto lo hacemos asi, por que si bien solo puede
          -- haber una formula por defecto esta regla esta impuesta
          -- por codigo y no por el motor y en consecuencia puede fallar :)
          v_prfk_id integer;
       begin

          select * from sp_producto_kit_lleva_serie(p_pr_id) into v_bLlevaNroSerie;

          select max(prfk_id)
          into v_prfk_id
          from ProductoFormulaKit
          where pr_id = p_pr_id
            and prfk_default <> 0;

          open rtn for
             SELECT
                uns.un_nombre un_name_stock,-- La unidad de los kits es de ventas
                unv.un_nombre un_name_venta,
                unc.un_nombre un_name_compra,
                v_bLlevaNroSerie pr_llevanroserie,
                prfk.pr_llevanrolote,
                prfk.pr_lotefifo,
                prfk.pr_eskit,
                prfk.rub_id,
                v_cue_id_compra cue_id_compra,
                v_cue_id_venta cue_id_venta,
                prfk.prfk_id,
                prfk.prfk_nombre,
                prfk.pr_kitResumido,
                prfk.pr_kitIdentidad,
                case
                    when exists (
                            select pka.prka_id
                            from ProductoKitItemA pka
                            join ProductoKit pk
                              on pka.prk_id = pk.prk_id
                             and pka.prfk_id = prfk.prfk_id ) then 1
                    else 0
                end tiene_alternativas,
                prfk.ccos_id_compra,
                prfk.ccos_id_venta,
                ccosc.ccos_nombre ccos_name_compra,
                ccosv.ccos_nombre ccos_name_venta

             from Producto
             left join Unidad uns
               on Producto.un_id_stock = uns.un_id
             left join Unidad unv
               on Producto.un_id_venta = unv.un_id
             left join Unidad unc
               on Producto.un_id_compra = unc.un_id
             left join ProductoFormulaKit prfk
               on Producto.pr_id = prfk.pr_id
              and prfk.prfk_id = v_prfk_id
             left join CentroCosto ccosc
               on Producto.ccos_id_compra = ccosc.ccos_id
             left join CentroCosto ccosv
               on Producto.ccos_id_venta = ccosv.ccos_id
             where Producto.pr_id = p_pr_id;

       end;
   else

      open rtn for
         select uns.un_nombre un_name_stock,
                unv.un_nombre un_name_venta,
                unc.un_nombre un_name_compra,
                pr_llevanroserie,
                pr_llevanrolote,
                pr_lotefifo,
                pr_eskit,
                rub_id,
                v_cue_id_compra cue_id_compra,
                v_cue_id_venta cue_id_venta,
                ccos_id_compra,
                ccos_id_venta,
                ccosc.ccos_nombre ccos_name_compra,
                ccosv.ccos_nombre ccos_name_venta
           from Producto
           left join Unidad uns
             on Producto.un_id_stock = uns.un_id
           left join Unidad unv
             on Producto.un_id_venta = unv.un_id
           left join Unidad unc
             on Producto.un_id_compra = unc.un_id
           left join CentroCosto ccosc
             on Producto.ccos_id_compra = ccosc.ccos_id
           left join CentroCosto ccosv
             on Producto.ccos_id_venta = ccosv.ccos_id
           where pr_id = p_pr_id;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_producto_stock_get_data(integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_productoventahelp()

-- drop function sp_productoventahelp(integer, integer, integer, integer, varchar, integer, integer, varchar, integer);

create or replace function sp_productoventahelp
/*
          select * from sp_ProductoventaHelp(1,1,1,'hp%',0,0); fetch all from rtn;
          select * from sp_ProductoventaHelp(1,1,0,0,'Impresora Deskjet 450ci',1); fetch all from rtn;
          select * from sp_productoventahelp(1,1,0,1,'Impresora', 0); fetch all from rtn;
*/
(
  in p_emp_id integer,
  in p_us_id integer,
  in p_bForAbm integer,
  in p_filterType integer default 0,  
  in p_filter varchar default '',
  in p_check integer default 0,
  in p_pr_id integer default 0,
  in p_filter2 varchar default '',
  in p_prhc_id integer default 0,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_filter varchar(255);
   v_prhc_atributo smallint;
   v_prhc_codigo varchar(255);
   v_timeCode date;
begin

   rtn := 'rtn';

   p_filter := lower(f_unaccent(p_filter));

   -- check
   --
   if p_check <> 0 then

      open rtn for
         select pr_id,
                pr_nombreventa Nombre,
                pr_codigo Codigo
         from Producto
         where ( lower(f_unaccent(pr_nombreventa)) = p_filter or lower(f_unaccent(pr_codigo)) = p_filter )
           and ( activo <> 0 or p_bForAbm <> 0 )
           and ( pr_id = p_pr_id or p_pr_id = 0 )
           and pr_sevende <> 0;

   else

      select sp_help_get_filter(p_filterType, p_filter) into v_filter;
   
      if p_prhc_id <> 0 then

         select prhc_valor_codigo,
                prhc_atributo_indice
           into v_prhc_codigo,
                v_prhc_atributo
         from ProductoHelpConfig
         where prhc_id = p_prhc_id;

         v_timeCode := CURRENT_TIMESTAMP;

         perform sp_str_string_to_table(v_timeCode, v_prhc_codigo, ',');

         if v_prhc_atributo = 1 then
            insert into tt_t_help_rubro
              ( select rubti.rubti_id
                from RubroTablaItem rubti
                join Rubro rub
                  on rubti.rubt_id = rub.rubt_id1
                join TmpStringToTable
                  on rubti.rubti_codigo = TmpStringToTable.tmpstr2tbl_campo
                where tmpstr2tbl_id = v_timeCode );

         else
            if v_prhc_atributo = 2 then
               insert into tt_t_help_rubro
                 ( select rubti.rubti_id
                   from RubroTablaItem rubti
                   join Rubro rub
                     on rubti.rubt_id = rub.rubt_id2
                   join TmpStringToTable
                     on rubti.rubti_codigo = TmpStringToTable.tmpstr2tbl_campo
                   where tmpstr2tbl_id = v_timeCode );

            else
               if v_prhc_atributo = 3 then
                  insert into tt_t_help_rubro
                    ( select rubti.rubti_id
                      from RubroTablaItem rubti
                      join Rubro rub
                        on rubti.rubt_id = rub.rubt_id3
                      join TmpStringToTable
                        on rubti.rubti_codigo = TmpStringToTable.tmpstr2tbl_campo
                      where tmpstr2tbl_id = v_timeCode );

               else
                  if v_prhc_atributo = 4 then
                     insert into tt_t_help_rubro
                       ( select rubti.rubti_id
                         from RubroTablaItem rubti
                         join Rubro rub
                           on rubti.rubt_id = rub.rubt_id4
                         join TmpStringToTable
                           on rubti.rubti_codigo = TmpStringToTable.tmpstr2tbl_campo
                         where tmpstr2tbl_id = v_timeCode );

                  else
                     if v_prhc_atributo = 5 then
                        insert into tt_t_help_rubro
                          ( select rubti.rubti_id
                            from RubroTablaItem rubti
                            join Rubro rub
                              on rubti.rubt_id = rub.rubt_id5
                            join TmpStringToTable
                              on rubti.rubti_codigo = TmpStringToTable.tmpstr2tbl_campo
                            where tmpstr2tbl_id = v_timeCode );

                     else
                        if v_prhc_atributo = 6 then
                           insert into tt_t_help_rubro
                             ( select rubti.rubti_id
                               from RubroTablaItem rubti
                               join Rubro rub
                                 on rubti.rubt_id = rub.rubt_id6
                               join TmpStringToTable
                                 on rubti.rubti_codigo = TmpStringToTable.tmpstr2tbl_campo
                               where tmpstr2tbl_id = v_timeCode );

                        else
                           if v_prhc_atributo = 7 then
                              insert into tt_t_help_rubro
                                ( select rubti.rubti_id
                                  from RubroTablaItem rubti
                                  join Rubro rub
                                    on rubti.rubt_id = rub.rubt_id7
                                  join TmpStringToTable
                                    on rubti.rubti_codigo = TmpStringToTable.tmpstr2tbl_campo
                                  where tmpstr2tbl_id = v_timeCode );

                           else
                              if v_prhc_atributo = 8 then
                                 insert into tt_t_help_rubro
                                   ( select rubti.rubti_id
                                     from RubroTablaItem rubti
                                     join Rubro rub
                                       on rubti.rubt_id = rub.rubt_id8
                                     join TmpStringToTable
                                       on rubti.rubti_codigo = TmpStringToTable.tmpstr2tbl_campo
                                     where tmpstr2tbl_id = v_timeCode );

                              else
                                 if v_prhc_atributo = 9 then
                                    insert into tt_t_help_rubro
                                      ( select rubti.rubti_id
                                        from RubroTablaItem rubti
                                        join Rubro rub
                                          on rubti.rubt_id = rub.rubt_id9
                                        join TmpStringToTable
                                          on rubti.rubti_codigo = TmpStringToTable.tmpstr2tbl_campo
                                        where tmpstr2tbl_id = v_timeCode );

                                 else
                                    if v_prhc_atributo = 10 then
                                       insert into tt_t_help_rubro
                                         ( select rubti.rubti_id
                                           from RubroTablaItem rubti
                                           join Rubro rub
                                             on rubti.rubt_id = rub.rubt_id10
                                           join TmpStringToTable
                                             on rubti.rubti_codigo = TmpStringToTable.tmpstr2tbl_campo
                                           where tmpstr2tbl_id = v_timeCode );

                                    end if;

                                 end if;

                              end if;

                           end if;

                        end if;

                     end if;

                  end if;

               end if;

            end if;

         end if;

         open rtn for
         
            select pr_id,
                   pr_nombreventa Nombre,
                   pr_descripventa Observaciones,
                   pr_codigo Codigo
            from Producto
            where ( lower(f_unaccent(pr_codigo)) like v_filter
                  or lower(f_unaccent(pr_nombreventa)) like v_filter
                  or lower(f_unaccent(pr_descripventa)) like v_filter
                  or p_filter is null )
              and ( activo <> 0 or p_bForAbm <> 0 )
              and pr_sevende <> 0
              and (   ( v_prhc_atributo = 1  and rubti_id1  in ( select rubti_id from tt_t_help_rubro  ) )
                   or ( v_prhc_atributo = 2  and rubti_id2  in ( select rubti_id from tt_t_help_rubro  ) )
                   or ( v_prhc_atributo = 3  and rubti_id3  in ( select rubti_id from tt_t_help_rubro  ) )
                   or ( v_prhc_atributo = 4  and rubti_id4  in ( select rubti_id from tt_t_help_rubro  ) )
                   or ( v_prhc_atributo = 5  and rubti_id5  in ( select rubti_id from tt_t_help_rubro  ) )
                   or ( v_prhc_atributo = 6  and rubti_id6  in ( select rubti_id from tt_t_help_rubro  ) )
                   or ( v_prhc_atributo = 7  and rubti_id7  in ( select rubti_id from tt_t_help_rubro  ) )
                   or ( v_prhc_atributo = 8  and rubti_id8  in ( select rubti_id from tt_t_help_rubro  ) )
                   or ( v_prhc_atributo = 9  and rubti_id9  in ( select rubti_id from tt_t_help_rubro  ) )
                   or ( v_prhc_atributo = 10 and rubti_id10 in ( select rubti_id from tt_t_help_rubro  ) )
                  )
              limit 50;

      else

         open rtn for
            --//////////////////////////////////////////////////////////////////
            --
            -- select COMUN
            --
            --//////////////////////////////////////////////////////////////////
            select pr_id,
                   pr_nombreventa Nombre,
                   pr_descripventa Observaciones,
                   pr_codigo Codigo
            from Producto
            where (    lower(f_unaccent(pr_codigo)) like v_filter
                    or lower(f_unaccent(pr_nombreventa)) like v_filter
                    or lower(f_unaccent(pr_descripventa)) like v_filter
                    or p_filter is null )
              and ( activo <> 0 or p_bForAbm <> 0 )
              and pr_sevende <> 0
            limit 50;

      end if;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_productoventahelp(integer, integer, integer, integer, varchar, integer, integer, varchar, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_proveedor_get_info()

-- drop function sp_proveedor_get_info(integer, integer);

create or replace function sp_proveedor_get_info
/*
    select * from documento where doct_id in (2,8,10);
    select * from sp_proveedor_get_info(2,20);
    select * from sp_proveedor_get_iva(2,0::smallint);
*/
(
  in p_prov_id integer,
  in p_doc_id integer,

  out p_cpg_id integer,
  out p_cpg_name varchar,
  out p_cpg_eslibre smallint,
  out p_lp_id integer,
  out p_lp_name varchar,
  out p_ld_id integer,
  out p_ld_name varchar,
  out p_bIvari smallint,
  out p_bIvarni smallint
)
  returns record as
$BODY$
declare
      v_cpg_id integer;
      v_cpg_name varchar;
      v_cpg_eslibre integer;
      v_lp_id integer;
      v_lp_name varchar;
      v_ld_id integer;
      v_ld_name varchar;
      v_mon_id integer;
begin


      select lp_id,
             ld_id,
             cpg_id
        into v_lp_id,
             v_ld_id,
             v_cpg_id
      from Proveedor
      where prov_id = p_prov_id;

      select mon_id into v_mon_id from Documento where doc_id = p_doc_id;

      if v_lp_id is not null then

         if not exists ( select *
                         from ListaPrecio
                         where lp_id = v_lp_id
                           and mon_id = v_mon_id
                           and lp_tipo in ( 2,3 ) ) then
            v_lp_id := null;
         end if;

      end if;

      if v_lp_id is null then

         select min(lp_id)
           into v_lp_id
         from ListaPrecio
         where mon_id = v_mon_id
           and lp_tipo in ( 2,3 )
           and lp_default <> 0;

      end if;

      if v_ld_id is not null then

         if not exists ( select *
                         from ListaDescuento
                         where ld_id = v_ld_id
                           and mon_id = v_mon_id
                           and ld_tipo = 2 ) then

            v_ld_id := null;

         end if;

      end if;

      if v_lp_id is not null then
        select lp_nombre into v_lp_name from listaprecio where lp_id = v_lp_id;
      end if;

      if v_ld_id is not null then
        select ld_nombre into v_ld_name from listadescuento where ld_id = v_ld_id;
      end if;

      if v_cpg_id is not null then
        select cpg_nombre, cpg_eslibre into v_cpg_name, v_cpg_eslibre from condicionpago where cpg_id = v_cpg_id;
      end if;

      select * from sp_proveedor_get_iva(p_prov_id) into p_bIvari, p_bIvarni;

      p_lp_id := coalesce(v_lp_id, 0);
      p_lp_name := coalesce(v_lp_name, '');
      p_ld_id := coalesce(v_ld_id, 0);
      p_ld_name := coalesce(v_ld_name, '');
      p_cpg_id := coalesce(v_cpg_id, 0);
      p_cpg_name := coalesce(v_cpg_name, '');
      p_cpg_eslibre := coalesce(v_cpg_eslibre, 0);

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_proveedor_get_info(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_proveedor_get_iva()

-- drop function sp_proveedor_get_iva(integer, smallint);

create or replace function sp_proveedor_get_iva
(
  in p_prov_id integer,
  out p_bIvari smallint,
  out p_bIvarni smallint
)
  returns record as
$BODY$
declare
   v_tipoIva smallint;
   v_bIva smallint;
   v_bIvaRni smallint;
   v_bSinIva smallint;
begin

   v_bIva := -1;
   v_bIvaRni := -2;
   v_bSinIva := -3;

   select case prov_catfiscal
             when 1 then v_bIva      --'Inscripto'
             when 2 then v_bSinIva   --'Exento'
             when 3 then v_bSinIva   --'No inscripto'
             when 4 then v_bIva      --'Consumidor Final'
             when 5 then v_bSinIva   --'Extranjero'
             when 6 then v_bSinIva   --'Mono Tributo'
             when 7 then v_bIva      --'Extranjero Iva'
             when 8 then v_bIva      --'No responsable'
             when 9 then v_bIva      --'No Responsable exento'
             when 10 then v_bIvaRni  --'No categorizado'
             when 11 then v_bIva     --'Inscripto M'
             else 0                  --'Sin categorizar'
          end
     into v_tipoIva
   from Proveedor
   where prov_id = p_prov_id;

   v_tipoIva := coalesce(v_tipoIva, v_bSinIva);

   if v_tipoIva = v_bIva then

      v_bIva := 1;
      v_bIvaRni := 0;

   else

      if v_tipoIva = v_bIvaRni then

         v_bIva := 1;
         v_bIvaRni := 1;

      else

         if v_tipoIva = v_bSinIva then

            v_bIva := 0;
            v_bIvaRni := 0;

         end if;

      end if;

   end if;

   p_bIvaRi := v_bIva;
   p_bIvaRni := v_bIvaRni;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_proveedor_get_iva(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_proveedor_get_next_number()

-- drop function sp_proveedor_get_next_number(integer, integer);

/*

          select * from documento where doct_id = 8;
          select * from proveedor;
          select * from sp_proveedor_get_next_number(1, 169);

*/

create or replace function sp_proveedor_get_next_number
(
  in p_prov_id integer,
  in p_doc_id integer default null,
  out p_number integer,
  out p_mask varchar,
  out p_enabled integer
)
  returns record as
$BODY$
declare
    v_ta_id integer;
begin

    select sp_proveedor_get_talonario(p_prov_id, p_doc_id) into v_ta_id;

    if v_ta_id is not null then

        select ta_ultimonro, ta_mascara, ta_tipo
          into p_number, p_mask, p_enabled
        from talonario
        where ta_id = v_ta_id;

    end if;

    p_number := coalesce(p_number, 0) + 1;
    p_mask := coalesce(p_mask, '');
    p_enabled := coalesce(p_enabled, 0);

    if(p_enabled != 1 /* suggested */) then

        p_enabled := 0;

    end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_proveedor_get_next_number(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_proveedor_get_talonario()

-- drop function sp_proveedor_get_talonario(integer, smallint);

/*

          select * from documento where doct_id = 8;
          select * from proveedor;
          select * from talonario where ta_id = 10;
          select * from sp_proveedor_get_talonario(1, 169);

*/

create or replace function sp_proveedor_get_talonario
(
  in p_prov_id integer,
  in p_doc_id integer default null,
  out p_ta_id integer
)
  returns integer as
$BODY$
declare
   v_prov_catfiscal smallint;
   v_doct_id integer;
   v_doct_id_facturavta integer;
   v_doct_id_facturacpra integer;
   v_doct_id_notadebitovta integer;
   v_doct_id_notacreditovta integer;
   v_doct_id_notadebitocpra integer;
   v_doct_id_notacreditocpra integer;
begin

   v_doct_id_facturavta := 1;
   v_doct_id_facturacpra := 2;
   v_doct_id_notadebitovta := 9;
   v_doct_id_notacreditovta := 7;
   v_doct_id_notadebitocpra := 10;
   v_doct_id_notacreditocpra := 8;

   select doct_id
     into v_doct_id
   from Documento
   where doc_id = p_doc_id;

   if v_doct_id in (
                        v_doct_id_facturavta, v_doct_id_facturacpra, v_doct_id_notadebitovta,
                        v_doct_id_notacreditovta, v_doct_id_notadebitocpra, v_doct_id_notacreditocpra ) then

        select prov_catfiscal
          into v_prov_catfiscal
        from Proveedor
        where prov_id = p_prov_id;


        select
            case v_prov_catfiscal
                when 1  then ta_id_inscripto--'Inscripto'
                when 2  then ta_id_final--'Exento'
                when 3  then ta_id_final--'No inscripto'
                when 4  then ta_id_final--'Consumidor Final'
                when 5  then ta_id_externo--'Extranjero'
                when 6  then ta_id_final--'Mono Tributo'
                when 7  then ta_id_externo--'Extranjero Iva'
                when 8  then ta_id_final--'No responsable'
                when 9  then ta_id_final--'No Responsable exento'
                when 10 then ta_id_final--'No categorizado'
                when 11 then ta_id_inscriptom--'Inscripto M'
                else -1--'Sin categorizar'
            end ta_id
          into p_ta_id
        from Documento
        where doc_id = p_doc_id;

   else

        select ta_id
          into p_ta_id
        from Documento
        where doc_id = p_doc_id;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_proveedor_get_talonario(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_proveedorhelp()

-- drop function sp_proveedorhelp(integer, integer, integer, varchar, integer, integer, varchar);

create or replace function sp_proveedorhelp
/*
  select sp_proveedorhelp(1,1,1,'hp%',0,0); fetch all from rtn;
  select sp_proveedorhelp(1,1,0,?, 1, ?, ?, ?)
*/
(
  in p_emp_id integer,
  in p_us_id integer,
  in p_bForAbm integer,
  in p_filter varchar default '',
  in p_check integer default 0,
  in p_prov_id integer default 0,
  in p_filter2 varchar default '',
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_us_EmpresaEx numeric(3,0);
   v_us_EmpXDpto numeric(3,0);
begin

   select us_empresaex,
          us_empxdpto
     into v_us_EmpresaEx,
          v_us_EmpXDpto
     from Usuario
      where us_id = p_us_id;

   p_filter := lower(f_unaccent(p_filter));

   rtn := 'rtn';

   if v_us_EmpresaEx <> 0 then
   begin
      if p_check <> 0 then
      begin
         open rtn for
            select prov_id,
                   prov_nombre Nombre,
                   prov_codigo Codigo
            from Proveedor
            where ( lower(f_unaccent(prov_nombre)) = p_filter
                   or lower(f_unaccent(prov_codigo)) = p_filter )
                   and ( activo <> 0
                   or p_bForAbm <> 0 )
                   and ( prov_id = p_prov_id
                   or p_prov_id = 0 )
                   and ( p_bForAbm <> 0
                   or ( ( exists ( select *
                                   from EmpresaProveedor
                                      where prov_id = Proveedor.prov_id
                                              and emp_id = p_emp_id ) )
                   and ( exists ( select *
                                  from UsuarioEmpresa
                                     where prov_id = Proveedor.prov_id
                                             and us_id = p_us_id )
                   or p_us_id = 1 ) ) );

      end;
      else
      begin
         open rtn for
            select prov_id,
                   prov_nombre Nombre,
                   prov_razonsocial as "R. Social",
                   prov_cuit CUIT,
                   prov_codigo Codigo,
                   case prov_catfiscal
                    when 1 then 'Inscripto'
                    when 2 then 'Exento'
                    when 3 then 'No inscripto'
                    when 4 then 'Consumidor Final'
                    when 5 then 'Extranjero'
                    when 6 then 'Mono Tributo'
                    when 7 then 'Extranjero Iva'
                    when 8 then 'No responsable'
                    when 9 then 'No Responsable exento'
                    when 10 then 'No categorizado'
                    else 'Sin categorizar'
                   end as "Cat. Fiscal"
            from Proveedor
            where ( lower(f_unaccent(prov_codigo)) LIKE '%' || p_filter || '%'
                       or lower(f_unaccent(prov_nombre)) LIKE '%' || p_filter || '%'
                       or lower(f_unaccent(prov_razonsocial)) LIKE '%' || p_filter || '%'
                       or prov_cuit LIKE '%' || p_filter || '%'
                       or p_filter is null )
                       and ( p_bForAbm <> 0
                       or ( ( exists ( select *
                                       from EmpresaProveedor
                                          where prov_id = Proveedor.prov_id
                                                  and emp_id = p_emp_id ) )
                       and ( exists ( select *
                                      from UsuarioEmpresa
                                         where prov_id = Proveedor.prov_id
                                                 and us_id = p_us_id )
                       or p_us_id = 1 )
                       and activo <> 0 ) )
            limit 50;

      end;
      end if;

   end;
   else
   begin
      if v_us_EmpXDpto <> 0 then
      begin
         if p_check <> 0 then
         begin
            open rtn for
               select prov_id,
                      prov_nombre Nombre,
                      prov_codigo Codigo
               from Proveedor
               where ( lower(f_unaccent(prov_nombre)) = p_filter
                          or lower(f_unaccent(prov_codigo)) = p_filter )
                          and ( activo <> 0
                          or p_bForAbm <> 0 )
                          and ( prov_id = p_prov_id
                          or p_prov_id = 0 )
                          and ( p_bForAbm <> 0
                          or ( ( exists ( select *
                                          from EmpresaProveedor
                                             where prov_id = Proveedor.prov_id
                                                     and emp_id = p_emp_id ) )
                          and ( exists ( select *
                                         from DepartamentoProveedor dc
                                                join UsuarioDepartamento ud
                                                 on dc.dpto_id = ud.dpto_id
                                            where dc.prov_id = Proveedor.prov_id
                                                    and ud.us_id = p_us_id )
                          or p_us_id = 1 ) ) );

         end;
         else
         begin
            open rtn for
               select prov_id,
                      prov_nombre Nombre,
                      prov_razonsocial as "R. Social",
                      prov_cuit CUIT,
                      prov_codigo Codigo,
                      case prov_catfiscal
                        when 1 then 'Inscripto'
                        when 2 then 'Exento'
                        when 3 then 'No inscripto'
                        when 4 then 'Consumidor Final'
                        when 5 then 'Extranjero'
                        when 6 then 'Mono Tributo'
                        when 7 then 'Extranjero Iva'
                        when 8 then 'No responsable'
                        when 9 then 'No Responsable exento'
                        when 10 then 'No categorizado'
                        else 'Sin categorizar'
                      end as "Cat. Fiscal"
               from Proveedor
               where ( lower(f_unaccent(prov_codigo)) LIKE '%' || p_filter || '%'
                          or lower(f_unaccent(prov_nombre)) LIKE '%' || p_filter || '%'
                          or lower(f_unaccent(prov_razonsocial)) LIKE '%' || p_filter || '%'
                          or prov_cuit LIKE '%' || p_filter || '%'
                          or p_filter is null )
                          and ( p_bForAbm <> 0
                          or ( ( exists ( select *
                                          from EmpresaProveedor
                                             where prov_id = Proveedor.prov_id
                                                     and emp_id = p_emp_id ) )
                          and ( exists ( select *
                                         from DepartamentoProveedor dc
                                                join UsuarioDepartamento ud
                                                 on dc.dpto_id = ud.dpto_id
                                            where dc.prov_id = Proveedor.prov_id
                                                    and ud.us_id = p_us_id )
                          or p_us_id = 1 )
                          and activo <> 0 ) )
               limit 50;

         end;
         end if;

      end;
      else
      begin
         if p_check <> 0 then
         begin
            open rtn for
               select prov_id,
                      prov_nombre Nombre,
                      prov_codigo Codigo
               from Proveedor
               where ( lower(f_unaccent(prov_nombre)) = p_filter
                          or lower(f_unaccent(prov_codigo)) = p_filter )
                          and ( activo <> 0
                          or p_bForAbm <> 0 )
                          and ( prov_id = p_prov_id
                          or p_prov_id = 0 )
                          and ( p_bForAbm <> 0
                          or ( exists ( select *
                                        from EmpresaProveedor
                                           where prov_id = Proveedor.prov_id
                                                   and emp_id = p_emp_id ) ) );

         end;
         else
         begin
            open rtn for
               select prov_id,
                      prov_nombre Nombre,
                      prov_razonsocial as "R. Social",
                      prov_cuit CUIT,
                      prov_codigo Codigo,
                      case prov_catfiscal
                        when 1 then 'Inscripto'
                        when 2 then 'Exento'
                        when 3 then 'No inscripto'
                        when 4 then 'Consumidor Final'
                        when 5 then 'Extranjero'
                        when 6 then 'Mono Tributo'
                        when 7 then 'Extranjero Iva'
                        when 8 then 'No responsable'
                        when 9 then 'No Responsable exento'
                        when 10 then 'No categorizado'
                        else 'Sin categorizar'
                      end as "Cat. Fiscal"
               from Proveedor
               where ( lower(f_unaccent(prov_codigo)) LIKE '%' || p_filter || '%'
                          or lower(f_unaccent(prov_nombre)) LIKE '%' || p_filter || '%'
                          or lower(f_unaccent(prov_razonsocial)) LIKE '%' || p_filter || '%'
                          or prov_cuit LIKE '%' || p_filter || '%'
                          or p_filter is null )
                          and ( p_bForAbm <> 0
                          or ( exists ( select *
                                        from EmpresaProveedor
                                           where prov_id = Proveedor.prov_id
                                                   and emp_id = p_emp_id )
                          and activo <> 0 ) )
               limit 50;

         end;
         end if;

      end;
      end if;

   end;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_proveedorhelp(integer, integer, integer, varchar, integer, integer, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_proveedor_update_credito()

-- drop function sp_proveedor_update_credito(integer, integer);

/*
          select sp_proveedor_update_credito(1,1);
*/

create or replace function sp_proveedor_update_credito
(
  in p_prov_id integer,
  in p_emp_id integer
)
  returns void as
$BODY$
declare
   v_deuda_cta_cte_anterior decimal(18,6);
   v_deuda_cta_cte decimal(18,6);
   v_credito_cta_cte decimal(18,6);
   v_deuda_doc_anterior decimal(18,6);
   v_deuda_doc decimal(18,6);
   v_emp_provd_id integer;
   
   v_doct_factura_cpra integer := 2;
   v_doct_orden_pago integer := 16;
   v_doct_orden_pago_chq integer := 1016;
begin

   -- Deuda en el cache
   --
   select sum(provcc_importe)
     into v_deuda_cta_cte
   from ProveedorCacheCredito
   where doct_id = v_doct_factura_cpra
     and prov_id = p_prov_id;

   -- Credito en el cache
   --
   select sum(provcc_importe)
     into v_credito_cta_cte
   from ProveedorCacheCredito
   where doct_id = v_doct_orden_pago
     and prov_id = p_prov_id;

   -- Deuda en el proveedor
   --
   select prov_DeudaCtaCte
     into v_deuda_cta_cte_anterior
   from Proveedor
   where prov_id = p_prov_id;

   update Proveedor
      set prov_DeudaCtaCte = coalesce(v_deuda_cta_cte, 0) - coalesce(v_credito_cta_cte, 0),
          prov_deudaTotal = prov_deudaTotal - coalesce(v_deuda_cta_cte_anterior, 0)
                            + (coalesce(v_deuda_cta_cte, 0) - coalesce(v_credito_cta_cte, 0))
   where prov_id = p_prov_id;

   -- Actualizo la deuda en la tabla EmpresaProveedorDeuda
   --
   v_deuda_cta_cte := 0;
   v_deuda_cta_cte_anterior := 0;
   v_credito_cta_cte := 0;

   -- Deuda en el cache para la empresa del documento modificado
   --
   select sum(provcc_importe)
     into v_deuda_cta_cte
   from ProveedorCacheCredito
   where doct_id = v_doct_factura_cpra
     and prov_id = p_prov_id
     and emp_id = p_emp_id;

   -- Credito en el cache para la empresa del documento modificado
   --
   select sum(provcc_importe)
     into v_credito_cta_cte
   from ProveedorCacheCredito
   where doct_id = v_doct_orden_pago
     and prov_id = p_prov_id
     and emp_id = p_emp_id;

   select empprovd_id
     into v_emp_provd_id
   from EmpresaProveedorDeuda
   where prov_id = p_prov_id
     and emp_id = p_emp_id;

   if coalesce(v_emp_provd_id, 0) <> 0 then

      select empprovd_DeudaCtaCte
        into v_deuda_cta_cte_anterior
      from EmpresaProveedorDeuda
      where empprovd_id = v_emp_provd_id;

      update EmpresaProveedorDeuda
         set empprovd_DeudaCtaCte = coalesce(v_deuda_cta_cte, 0) - coalesce(v_credito_cta_cte, 0),
             empprovd_deudaTotal = empprovd_deudaTotal - coalesce(v_deuda_cta_cte_anterior, 0) + (coalesce(v_deuda_cta_cte, 0) - coalesce(v_credito_cta_cte, 0))
      where empprovd_id = v_emp_provd_id;

   else

      select sp_dbGetNewId('EmpresaProveedorDeuda', 'empprovd_id') into v_emp_provd_id;

      insert into EmpresaProveedorDeuda
        ( empprovd_id, emp_id, prov_id, empprovd_deudaCtaCte, empprovd_deudaTotal )
        values ( v_emp_provd_id, p_emp_id, p_prov_id, coalesce(v_deuda_cta_cte, 0),
                coalesce(v_deuda_cta_cte, 0) - coalesce(v_credito_cta_cte, 0) );

   end if;

   -- Deuda en el cache
   --
   select sum(provcc_importe)
     into v_deuda_doc
   from ProveedorCacheCredito
   where doct_id = v_doct_orden_pago_chq
     and prov_id = p_prov_id;

   -- Deuda en el Proveedor
   --
   select prov_deudaDoc
     into v_deuda_doc_anterior
   from Proveedor
   where prov_id = p_prov_id;

   update Proveedor
      set prov_deudaDoc = coalesce(v_deuda_doc, 0),
          prov_deudaTotal = prov_deudaTotal - coalesce(v_deuda_doc_anterior, 0) + coalesce(v_deuda_doc, 0)
   where prov_id = p_prov_id;

   -- Actualizo la deuda en la tabla EmpresaProveedorDeuda
   --
   v_deuda_doc := 0;
   v_deuda_doc_anterior := 0;

   -- Deuda en el cache para la empresa del documento modificado
   --
   select sum(provcc_importe)
     into v_deuda_doc
   from ProveedorCacheCredito
   where doct_id = v_doct_orden_pago_chq
     and prov_id = p_prov_id
     and emp_id = p_emp_id;

   v_emp_provd_id := null;

   select empprovd_id
     into v_emp_provd_id
   from EmpresaProveedorDeuda
   where prov_id = p_prov_id
     and emp_id = p_emp_id;

   if coalesce(v_emp_provd_id, 0) <> 0 then

      select empprovd_DeudaDoc
        into v_deuda_doc_anterior
      from EmpresaProveedorDeuda
      where empprovd_id = v_emp_provd_id;

      update EmpresaProveedorDeuda
         set empprovd_DeudaDoc = coalesce(v_deuda_doc, 0),
             empprovd_deudaTotal = empprovd_deudaTotal - coalesce(v_deuda_doc_anterior, 0) + coalesce(v_deuda_doc, 0)
      where empprovd_id = v_emp_provd_id;

   else

      select sp_dbGetNewId('EmpresaProveedorDeuda', 'empprovd_id') into v_emp_provd_id;

      insert into EmpresaProveedorDeuda( empprovd_id, prov_id, emp_id, empprovd_deudaDoc, empprovd_deudaTotal )
      values ( v_emp_provd_id, p_prov_id, p_emp_id, coalesce(v_deuda_doc, 0), coalesce(v_deuda_doc, 0) );

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_proveedor_update_credito(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_proveedor_update_orden_cpra_credito()

-- drop function sp_proveedor_update_orden_cpra_credito(integer, integer);

create or replace function sp_proveedor_update_orden_cpra_credito
(
  in p_prov_id integer,
  in p_emp_id integer
)
  returns void as
$BODY$
declare
   v_deudaOrdenAnterior decimal(18,6);
   v_deudaOrden decimal(18,6);
   v_empprovd_id integer;
   v_doct_Ordencompra integer := 35;
begin

   -- deuda en el cache
   --
   select sum(provcc_importe)
     into v_deudaOrden
   from ProveedorCacheCredito
   where doct_id = v_doct_Ordencompra
     and prov_id = p_prov_id;

   -- deuda en el proveedor
   --
   select prov_deudaOrden
     into v_deudaOrdenAnterior
   from Proveedor
   where prov_id = p_prov_id;

   update Proveedor
      set prov_deudaOrden = coalesce(v_deudaOrden, 0),
          prov_deudaTotal = prov_deudaTotal - coalesce(v_deudaOrdenAnterior, 0) + coalesce(v_deudaOrden, 0)
   where prov_id = p_prov_id;

   -- actualizo la deuda en la tabla EmpresaProveedorDeuda
   --
   v_deudaOrden := 0;
   v_deudaOrdenAnterior := 0;

   -- deuda en el cache para la empresa del documento modificado
   --
   select sum(provcc_importe)
     into v_deudaOrden
   from ProveedorCacheCredito
   where doct_id = v_doct_Ordencompra
     and prov_id = p_prov_id
     and emp_id = p_emp_id;

   select empprovd_id
     into v_empprovd_id
   from EmpresaProveedorDeuda
   where prov_id = p_prov_id
     and emp_id = p_emp_id;

   if coalesce(v_empprovd_id, 0) <> 0 then

      select empprovd_deudaOrden
        into v_deudaOrdenAnterior
      from EmpresaProveedorDeuda
      where empprovd_id = v_empprovd_id;

      update EmpresaProveedorDeuda
         set empprovd_deudaOrden = coalesce(v_deudaOrden, 0),
             empprovd_deudaTotal = empprovd_deudaTotal - coalesce(v_deudaOrdenAnterior, 0) + coalesce(v_deudaOrden, 0)
      where empprovd_id = v_empprovd_id;

   else

      select sp_dbGetNewId('EmpresaProveedorDeuda', 'empprovd_id') into v_empprovd_id;

      insert into EmpresaProveedorDeuda( empprovd_id, emp_id, prov_id, empprovd_deudaOrden, empprovd_deudaTotal )
        values ( v_empprovd_id, p_emp_id, p_prov_id, coalesce(v_deudaOrden, 0), coalesce(v_deudaOrden, 0) );

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_proveedor_update_orden_cpra_credito(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_proveedor_update_remito_credito()

-- drop function sp_proveedor_update_remito_credito(integer, integer);

create or replace function sp_proveedor_update_remito_credito
(
  in p_prov_id integer,
  in p_emp_id integer
)
  returns void as
$BODY$
declare
   v_deudaRemitoAnterior decimal(18,6);
   v_deudaRemito decimal(18,6);
   v_empprovd_id integer;
   v_doct_remitocompra integer := 4;
begin

   -- deuda en el cache
   --
   select sum(provcc_importe)
     into v_deudaRemito
   from ProveedorCacheCredito
   where doct_id = v_doct_remitocompra
     and prov_id = p_prov_id;

   -- deuda en el proveedor
   --
   select prov_deudaRemito
     into v_deudaRemitoAnterior
   from Proveedor
   where prov_id = p_prov_id;

   update Proveedor
      set prov_deudaRemito = coalesce(v_deudaRemito, 0),
          prov_deudaTotal = prov_deudaTotal - coalesce(v_deudaRemitoAnterior, 0) + coalesce(v_deudaRemito, 0)
   where prov_id = p_prov_id;

   -- actualizo la deuda en la tabla empresaproveedordeuda
   --
   v_deudaRemito := 0;
   v_deudaRemitoAnterior := 0;

   -- deuda en el cache para la empresa del documento modificado
   --
   select sum(provcc_importe)
     into v_deudaRemito
   from ProveedorCacheCredito
   where doct_id = v_doct_remitocompra
     and prov_id = p_prov_id
     and emp_id = p_emp_id;

   select empprovd_id
     into v_empprovd_id
   from EmpresaProveedorDeuda
   where prov_id = p_prov_id
     and emp_id = p_emp_id;

   if coalesce(v_empprovd_id, 0) <> 0 then

      select empprovd_deudaRemito
        into v_deudaRemitoAnterior
      from EmpresaProveedorDeuda
      where empprovd_id = v_empprovd_id;

      update EmpresaProveedorDeuda
         set empprovd_deudaRemito = coalesce(v_deudaRemito, 0),
             empprovd_deudaTotal = empprovd_deudaTotal - coalesce(v_deudaRemitoAnterior, 0) + coalesce(v_deudaRemito, 0)
      where empprovd_id = v_empprovd_id;

   else
      select sp_dbGetNewId('EmpresaProveedorDeuda', 'empprovd_id') into v_empprovd_id;

      insert into EmpresaProveedorDeuda( empprovd_id, emp_id, prov_id, empprovd_deudaRemito, empprovd_deudaTotal )
      values ( v_empprovd_id, p_emp_id, p_prov_id, coalesce(v_deudaRemito, 0), coalesce(v_deudaRemito, 0) );

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_proveedor_update_remito_credito(integer, integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_talonario_get_propuesto()

-- drop function sp_talonario_get_propuesto(integer, integer, integer);

create or replace function sp_talonario_get_propuesto
/*
*/
(
  in p_doc_id integer,
  in p_cli_id integer default 0,
  in p_prov_id integer default 0,
  out p_ta_Mascara varchar,
  out p_ta_Propuesto smallint,
  out p_ta_id int,
  out p_ta_tipo smallint
)
  returns record as
$BODY$
declare
   v_ta_id integer;
   v_doct_id integer;
   v_cli_catfiscal integer;
   v_prov_catfiscal integer;
begin

   if coalesce(p_doc_id, 0) = 0 then
       begin
          p_ta_Mascara := '';

          p_ta_Propuesto := 0;

          p_ta_tipo := 0;

          p_ta_id := null;

       end;
   else
       begin
          select ta_id,
                 doct_id
            into v_ta_id,
                 v_doct_id
          from Documento
          where doc_id = p_doc_id;

          if v_doct_id in (
                  1   --   Factura de Venta
                  ,2  --   Factura de Compra
                  ,7  --   Nota de Credito Venta
                  ,8  --   Nota de Credito Compra
                  ,9  --   Nota de Debito Venta
                  ,10 --   Nota de Debito Compra
          ) then

          begin
             if v_doct_id in ( 1--   Factura de Venta
             ,7--   Nota de Credito Venta
             ,9 ) then--   Nota de Debito Venta

             begin
                select cli_catfiscal
                  into v_cli_catfiscal
                  from Cliente
                   where cli_id = p_cli_id;

                select case v_cli_catfiscal
                    when 1 then ta_id_inscripto--'Inscripto'

                    when 2 then ta_id_final--'Exento'

                    when 3 then ta_id_inscripto--'No inscripto'

                    when 4 then ta_id_final--'Consumidor Final'

                    when 5 then ta_id_externo--'Extranjero'

                    when 6 then ta_id_final--'Mono Tributo'

                    when 7 then ta_id_externo--'Extranjero Iva'

                    when 8 then ta_id_final--'No responsable'

                    when 9 then ta_id_final--'No Responsable exento'

                    when 10 then ta_id_final--'No categorizado'

                    when 11 then ta_id_inscripto--'Inscripto M'

                    else -1--'Sin categorizar'

                  end
                  into v_ta_id
                from Documento
                where doc_id = p_doc_id;

             end;
             else
             begin
                select prov_catfiscal
                  into v_prov_catfiscal
                from Proveedor
                where prov_id = p_prov_id;

                --2,--   Factura de Compra
                --8,--   Nota de Credito Compra
                --10--   Nota de Debito Compra
                select case v_prov_catfiscal
                     when 1 then ta_id_inscripto--'Inscripto'

                     when 2 then ta_id_final--'Exento'

                     when 3 then ta_id_final--'No inscripto'

                     when 4 then ta_id_final--'Consumidor Final'

                     when 5 then ta_id_externo--'Extranjero'

                     when 6 then ta_id_final--'Mono Tributo'

                     when 7 then ta_id_externo--'Extranjero Iva'

                     when 8 then ta_id_final--'No responsable'

                     when 9 then ta_id_final--'No Responsable exento'

                     when 10 then ta_id_final--'No categorizado'

                     when 11 then ta_id_inscriptom--'Inscripto M'

                     else -1--'Sin categorizar'

                  end
                  into v_ta_id
                from Documento
                where doc_id = p_doc_id;

             end;
             end if;

          end;
          end if;

          if coalesce(v_ta_id, 0) = 0 then
              begin
                 p_ta_Mascara := '';

                 p_ta_Propuesto := 0;

                 p_ta_tipo := 0;

                 p_ta_id := null;

              end;
          else
              begin
                 select ta_mascara,
                        ta_tipo,
                        ta_tipo
                   into p_ta_Mascara,
                        p_ta_Propuesto,
                        p_ta_tipo
                 from Talonario
                 where ta_id = v_ta_id;

                 if coalesce(p_ta_Propuesto, 0) <> 1 then
                    p_ta_Propuesto := 0;

                 else
                    p_ta_Propuesto := 1;

                 end if;

                 p_ta_Mascara := coalesce(p_ta_Mascara, '');

                 p_ta_id := v_ta_id;

              end;
          end if;

       end;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_talonario_get_propuesto(integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_talonario_set()

-- drop function sp_talonario_set(integer, integer);

create or replace function sp_talonario_set
/*
 select * from talonario where ta_id = 2;
 select sp_talonario_set(2,'x-0001-00054083');
*/
(
  in p_ta_id integer,
  in p_ta_numero varchar
)
 returns void as
$BODY$
declare
  v_numero integer;
  v_c varchar(1);
  v_n smallint;
  v_ultimoNumero integer;
begin
   
      v_n := length(p_ta_numero);

      v_c := substr(p_ta_numero, v_n, 1);

      while instr('1234567890', v_c) <> 0
      loop
        v_n := v_n - 1;

        if v_n <= 0 then
           exit;
        end if;

        v_c := substr(p_ta_numero, v_n, 1);
      end loop;

      v_n := v_n + 1;

      v_numero := to_number(substr(p_ta_numero, v_n, length(p_ta_numero)));

      select ta_ultimoNro
        into v_ultimoNumero
      from Talonario
      where ta_id = p_ta_id;

      if v_ultimoNumero < v_numero then

         update Talonario
            set ta_ultimoNro = v_numero
         where ta_id = p_ta_id;

      end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_talonario_set(integer, varchar)
  owner to postgres;
  /*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: dc_csc_aud_0010(integer)

-- drop function dc_csc_aud_0010(integer);

create or replace function dc_csc_aud_0010(in p_us_id integer, out rtn refcursor)
  returns refcursor as
$BODY$
declare
begin

   rtn := 'rtn';

   open rtn for
      select as_id comp_id,
             doct_id doct_id,
             as_fecha Fecha,
             as_nrodoc Comprobante
        from Asiento
         where as_fecha > CURRENT_TIMESTAMP
      union all
      select os_id comp_id,
             doct_id doct_id,
             os_fecha Fecha,
             os_nrodoc Comprobante
        from OrdenServicio
         where os_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select rv_id comp_id,
             doct_id doct_id,
             rv_fecha Fecha,
             rv_nrodoc Comprobante
        from RemitoVenta
         where rv_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select fv_id comp_id,
             doct_id doct_id,
             fv_fecha Fecha,
             fv_nrodoc Comprobante
        from FacturaVenta
         where fv_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select pv_id comp_id,
             doct_id doct_id,
             pv_fecha Fecha,
             pv_nrodoc Comprobante
        from PedidoVenta
         where pv_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select cobz_id comp_id,
             doct_id doct_id,
             cobz_fecha Fecha,
             cobz_nrodoc Comprobante
        from Cobranza
         where cobz_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select opg_id comp_id,
             doct_id doct_id,
             opg_fecha Fecha,
             opg_nrodoc Comprobante
        from OrdenPago
         where opg_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select rc_id comp_id,
             doct_id doct_id,
             rc_fecha Fecha,
             rc_nrodoc Comprobante
        from RemitoCompra
         where rc_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select fc_id comp_id,
             doct_id doct_id,
             fc_fecha Fecha,
             fc_nrodoc Comprobante
        from FacturaCompra
         where fc_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select pc_id comp_id,
             doct_id doct_id,
             pc_fecha Fecha,
             pc_nrodoc Comprobante
        from PedidoCompra
         where pc_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select oc_id comp_id,
             doct_id doct_id,
             oc_fecha Fecha,
             oc_nrodoc Comprobante
        from OrdenCompra
         where oc_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select mf_id comp_id,
             doct_id doct_id,
             mf_fecha Fecha,
             mf_nrodoc Comprobante
        from MovimientoFondo
         where mf_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select dbco_id comp_id,
             doct_id doct_id,
             dbco_fecha Fecha,
             dbco_nrodoc Comprobante
        from DepositoBanco
         where dbco_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select rs_id comp_id,
             doct_id doct_id,
             rs_fecha Fecha,
             rs_nrodoc Comprobante
        from RecuentoStock
         where rs_fecha > CURRENT_TIMESTAMP
      union all
      select ppk_id comp_id,
             doct_id doct_id,
             ppk_fecha Fecha,
             ppk_nrodoc Comprobante
        from ParteProdKit
         where ppk_fecha > CURRENT_TIMESTAMP
      union all
      select st_id comp_id,
             doct_id doct_id,
             st_fecha Fecha,
             st_nrodoc Comprobante
        from Stock
         where st_fecha > CURRENT_TIMESTAMP
      union all
      select dcup_id comp_id,
             doct_id doct_id,
             dcup_fecha Fecha,
             dcup_nrodoc Comprobante
        from DepositoCupon
         where dcup_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select rcup_id comp_id,
             doct_id doct_id,
             rcup_fecha Fecha,
             rcup_nrodoc Comprobante
        from ResolucionCupon
         where rcup_fecha > CURRENT_TIMESTAMP
                 and est_id <> 7
      union all
      select stcli_id comp_id,
             doct_id doct_id,
             stcli_fecha Fecha,
             stcli_nrodoc Comprobante
        from StockCliente
         where stcli_fecha > CURRENT_TIMESTAMP
      union all
      select stprov_id comp_id,
             doct_id doct_id,
             stprov_fecha Fecha,
             stprov_nrodoc Comprobante
        from StockProveedor
         where stprov_fecha > CURRENT_TIMESTAMP;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function dc_csc_aud_0010(integer)
  owner to postgres;
  /*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: dc_csc_com_0010(integer, date, date, character varying, character varying, character varying, character varying, smallint, character varying, smallint, smallint, smallint)

-- drop function dc_csc_com_0010(integer, date, date, character varying, character varying, character varying, character varying, smallint, character varying, smallint, smallint, smallint);

create or replace function dc_csc_com_0010(in p_us_id integer, in p_fini date, in p_ffin date, in p_prov_id character varying, in p_suc_id character varying, in p_cue_id character varying, in p_cico_id character varying, in p_solodeudores smallint, in p_emp_id character varying, in p_ntipo smallint, in p_conremito smallint, in p_saldominimo smallint, out rtn refcursor)
  returns refcursor as
$BODY$
declare
   v_prov_id integer;
   v_suc_id integer;
   v_cue_id integer;
   v_cico_id integer;
   v_emp_id integer;
   v_ram_id_Proveedor integer;
   v_ram_id_Sucursal integer;
   v_ram_id_Cuenta integer;
   v_ram_id_circuitocontable integer;
   v_ram_id_Empresa integer;
   v_clienteID integer;
   v_IsRaiz smallint;
   v_cta_acreedor numeric(3,0);
   v_cta_acreedoropg numeric(3,0);
begin

   rtn = 'rtn';
   
        create temporary table tt_dc_csc_com_0010
        (
          prov_id integer not null,
          cue_id integer,
          emp_id integer not null,
          suc_id integer not null,
          neto decimal(18,6) 
           default (0) not null,
          descuento decimal(18,6) 
           default (0) not null,
          subtotal decimal(18,6) 
           default (0) not null,
          iva decimal(18,6) 
           default (0) not null,
          total decimal(18,6) 
           default (0) not null,
          pago decimal(18,6) 
           default (0) not null,
          pendiente decimal(18,6)  not null
        ) on commit drop;

   select sp_ArbConvertId(p_prov_id) into v_prov_id, v_ram_id_Proveedor;
/*
   select sp_ArbConvertId(p_suc_id) into v_suc_id, v_ram_id_Sucursal;

   select sp_ArbConvertId(p_cue_id) into v_cue_id, v_ram_id_Cuenta;

   select sp_ArbConvertId(p_cico_id) into v_cico_id, v_ram_id_circuitocontable;

   select sp_ArbConvertId(p_emp_id) into v_emp_id, v_ram_id_Empresa;

   select sp_GetRptId(v_clienteID);

   if v_ram_id_Proveedor <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Proveedor, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Proveedor) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         select sp_ArbGetAllHojas(v_ram_id_Proveedor,
                           v_clienteID);

      end;
      else
         v_ram_id_Proveedor := 0;

      end if;

   end;
   end if;

   if v_ram_id_Sucursal <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Sucursal, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Sucursal) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         select sp_ArbGetAllHojas(v_ram_id_Sucursal,
                           v_clienteID);

      end;
      else
         v_ram_id_Sucursal := 0;

      end if;

   end;
   end if;

   if v_ram_id_Cuenta <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Cuenta, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Cuenta) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         select sp_ArbGetAllHojas(v_ram_id_Cuenta,
                           v_clienteID);

      end;
      else
         v_ram_id_Cuenta := 0;

      end if;

   end;
   end if;

   if v_ram_id_circuitocontable <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_circuitocontable, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_circuitocontable) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         select sp_ArbGetAllHojas(v_ram_id_circuitocontable,
                           v_clienteID);

      end;
      else
         v_ram_id_circuitocontable := 0;

      end if;

   end;
   end if;

   if v_ram_id_Empresa <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Empresa, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Empresa) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         select sp_ArbGetAllHojas(v_ram_id_Empresa,
                           v_clienteID);

      end;
      else
         v_ram_id_Empresa := 0;

      end if;

   end;
   end if;

   v_cta_acreedor := 2;

   v_cta_acreedoropg := 5;

   --/////////////////////////////////////////////////////////////////////////
   --
   --	Saldos Iniciales
   --
   --/////////////////////////////////////////////////////////////////////////
   

   --//////////////////////////////////////////
   -- Ordenes de Pago
   --//////////////////////////////////////////
   insert into tt_dc_csc_com_0010
     ( prov_id, cue_id, emp_id, suc_id, pago, pendiente )
     ( select opg.prov_id,
              ( select min(cue_id)
                from OrdenPagoItem
                   where opg_id = opg.opg_id
                           and opgi_tipo = 5 ),
              doc.emp_id,
              opg.suc_id,
              opg.opg_total,
              case
                   when p_nTipo = 0 then -opg.opg_pendiente
              else -opg.opg_total - coalesce(( select SUM(fcopg.fcopg_importe)
                                          from FacturaCompraOrdenPago fcopg
                                                 join FacturaCompra fc
                                                  on fcopg.fc_id = fc.fc_id
                                                 join Documento doc
                                                  on fc.doc_id = doc.doc_id
                                             where fcopg.opg_id = opg.opg_id
                                                     and fc.est_id <> 7
                                                     and ( doc.cico_id = v_cico_id
                                                     or v_cico_id = 0 )
                                                     and ( doc.emp_id = v_emp_id
                                                     or v_emp_id = 0 )
                                                     and ( ( fc.fc_fecha <= p_Fini
                                                     and p_nTipo <> 3 )
                                                     or ( fc.fc_fecha <= p_Ffin
                                                     and p_nTipo = 3 ) ) ), 0)
                 end col
       from OrdenPago opg
              join Documento doc
               on opg.doc_id = doc.doc_id
          where ( ( opg.opg_fecha < p_Fini
                  and p_nTipo = 0 )
                  or ( opg.opg_fecha <= p_Fini
                  and p_nTipo in ( 1,2 ) )
                  or ( opg.opg_fecha >= p_Fini
                  and opg.opg_fecha <= p_Ffin
                  and p_nTipo = 3 ) )
                  and opg.est_id <> 7
                  and ( exists ( select *
                                      from EmpresaUsuario
                                         where emp_id = doc.emp_id
                                                 and us_id = p_us_id )
                  or ( p_us_id = 1 ) )
/ * -///////////////////////////////////////////////////////////////////////
		
		INICIO SEGUNDA PARTE DE ARBOLES
		
/////////////////////////////////////////////////////////////////////// * /
                  and ( opg.prov_id = v_prov_id
                  or v_prov_id = 0 )
                  and ( opg.suc_id = v_suc_id
                  or v_suc_id = 0 )
                  and ( doc.cico_id = v_cico_id
                  or v_cico_id = 0 )
                  and ( exists ( select *
                                 from OrdenPagoItem
                                    where opg_id = opg.opg_id
                                            and opgi_tipo = v_cta_acreedoropg
                                            and cue_id = v_cue_id )
                  or v_cue_id = 0 )
                  and ( doc.emp_id = v_emp_id
                  or v_emp_id = 0 )
                  -- Arboles
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 29
                                              and rptarb_hojaid = opg.prov_id ) )
                  or ( v_ram_id_Proveedor = 0 ) )
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 1007
                                              and rptarb_hojaid = opg.suc_id ) )
                  or ( v_ram_id_Sucursal = 0 ) )
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 17
                                              and ( exists ( select *
                                                             from OrdenPagoItem
                                                                where opg_id = opg.opg_id
                                                                        and opgi_tipo = v_cta_acreedoropg
                                                                        and cue_id = rptarb_hojaid ) ) ) )
                  or ( v_ram_id_Cuenta = 0 ) )
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 1016
                                              and rptarb_hojaid = doc.cico_id ) )
                  or ( v_ram_id_circuitocontable = 0 ) )
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 1018
                                              and rptarb_hojaid = doc.emp_id ) )
                  or ( v_ram_id_Empresa = 0 ) ) );

   --//////////////////////////////////////////
   -- Facturas y Notas de Credito
   --//////////////////////////////////////////
   insert into tt_dc_csc_com_0010
     ( prov_id, cue_id, emp_id, suc_id, neto, descuento, subtotal, iva, total, pago, pendiente )
     ( select fc.prov_id,
              ai.cue_id,
              doc.emp_id,
              fc.suc_id,
              case fc.doct_id
                             when 8 then -fc.fc_neto
              else fc.fc_neto
                 end Neto,
              case fc.doct_id
                             when 8 then -coalesce(fc.fc_importedesc1, 0) + coalesce(fc.fc_importedesc2, 0)
              else coalesce(fc.fc_importedesc1, 0) + coalesce(fc.fc_importedesc2, 0)
                 end Descuento,
              case fc.doct_id
                             when 8 then -fc.fc_subtotal
              else fc.fc_subtotal
                 end Sub_Total,
              case fc.doct_id
                             when 8 then -coalesce(fc.fc_ivari, 0) + coalesce(fc.fc_ivarni, 0)
              else coalesce(fc.fc_ivari, 0) + coalesce(fc.fc_ivarni, 0)
                 end Iva,
              case fc.doct_id
                             when 8 then -fc.fc_total
              else fc.fc_total
                 end Total,
              case
                   when fc.fc_totalcomercial = 0
                     and fc.fc_fechavto < CURRENT_TIMESTAMP
                     and fc.fc_fechavto < p_Ffin
                     and fc.doct_id = 8 then -fc.fc_total
                   when fc.fc_totalcomercial = 0
                     and fc.fc_fechavto < CURRENT_TIMESTAMP
                     and fc.fc_fechavto < p_Ffin
                     and fc.doct_id <> 8 then fc.fc_total
              else 0
                 end Pagos,
              case
                   when p_nTipo = 0
                     and fc.doct_id = 8 then -fc.fc_pendiente
                   when p_nTipo = 0 then fc.fc_pendiente
                   when fc.doct_id = 8 then -fc.fc_total - coalesce(( select SUM(fcnc.fcnc_importe)
                                                                 from FacturaCompraNotaCredito fcnc
                                                                        join FacturaCompra fc2
                                                                         on fcnc.fc_id_factura = fc2.fc_id
                                                                        join Documento doc
                                                                         on fc2.doc_id = doc.doc_id
                                                                    where fcnc.fc_id_notacredito = fc.fc_id
                                                                            and fc2.est_id <> 7
                                                                            and ( doc.cico_id = v_cico_id
                                                                            or v_cico_id = 0 )
                                                                            and ( doc.emp_id = v_emp_id
                                                                            or v_emp_id = 0 )
                                                                            and ( ( fc2.fc_fecha <= p_Fini
                                                                            and p_nTipo <> 3 )
                                                                            or ( fc2.fc_fecha <= p_Ffin
                                                                            and p_nTipo = 3 ) ) ), 0)
              else (fc.fc_total - coalesce(( select SUM(fcnc.fcnc_importe)
                                        from FacturaCompraNotaCredito fcnc
                                               join FacturaCompra nc
                                                on fcnc.fc_id_notacredito = nc.fc_id
                                               join Documento doc
                                                on nc.doc_id = doc.doc_id
                                           where fcnc.fc_id_factura = fc.fc_id
                                                   and nc.est_id <> 7
                                                   and ( doc.cico_id = v_cico_id
                                                   or v_cico_id = 0 )
                                                   and ( doc.emp_id = v_emp_id
                                                   or v_emp_id = 0 )
                                                   and ( ( nc.fc_fecha <= p_Fini
                                                   and p_nTipo <> 3 )
                                                   or ( nc.fc_fecha <= p_Ffin
                                                   and p_nTipo = 3 ) ) ), 0) - coalesce(( select SUM(fcopg.fcopg_importe)
                                                                                      from FacturaCompraOrdenPago fcopg
                                                                                             join OrdenPago opg
                                                                                              on fcopg.opg_id = opg.opg_id
                                                                                             join Documento doc
                                                                                              on opg.doc_id = doc.doc_id
                                                                                         where fcopg.fc_id = fc.fc_id
                                                                                                 and opg.est_id <> 7
                                                                                                 and ( doc.cico_id = v_cico_id
                                                                                                 or v_cico_id = 0 )
                                                                                                 and ( opg.emp_id = v_emp_id
                                                                                                 or v_emp_id = 0 )
                                                                                                 and ( ( opg.opg_fecha <= p_Fini
                                                                                                 and p_nTipo <> 3 )
                                                                                                 or ( opg.opg_fecha <= p_Ffin
                                                                                                 and p_nTipo = 3 ) ) ), 0))
                 end Pendiente
       from FacturaCompra fc
              join Documento doc
               on fc.doc_id = doc.doc_id
              left join AsientoItem ai
               on fc.as_id = ai.as_id
              and ai.asi_tipo = v_cta_acreedor
          where ( ( fc.fc_fecha < p_Fini
                  and p_nTipo = 0 )
                  or ( fc.fc_fecha <= p_Fini
                  and p_nTipo in ( 1,2 ) )
                  or ( fc.fc_fecha >= p_Fini
                  and fc.fc_fecha <= p_Ffin
                  and p_nTipo = 3 ) )
                  and fc.est_id <> 7
                  and fc.fc_totalcomercial <> 0
                  and ( exists ( select *
                                      from EmpresaUsuario
                                         where emp_id = doc.emp_id
                                                 and us_id = p_us_id )
                  or ( p_us_id = 1 ) )
/ * -///////////////////////////////////////////////////////////////////////
		
		INICIO SEGUNDA PARTE DE ARBOLES
		
/////////////////////////////////////////////////////////////////////// * /
                  and ( fc.prov_id = v_prov_id
                  or v_prov_id = 0 )
                  and ( fc.suc_id = v_suc_id
                  or v_suc_id = 0 )
                  and ( ai.cue_id = v_cue_id
                  or v_cue_id = 0 )
                  and ( doc.cico_id = v_cico_id
                  or v_cico_id = 0 )
                  and ( doc.emp_id = v_emp_id
                  or v_emp_id = 0 )
                  -- Arboles
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 29
                                              and rptarb_hojaid = fc.prov_id ) )
                  or ( v_ram_id_Proveedor = 0 ) )
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 1007
                                              and rptarb_hojaid = fc.suc_id ) )
                  or ( v_ram_id_Sucursal = 0 ) )
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 17
                                              and rptarb_hojaid = ai.cue_id ) )
                  or ( v_ram_id_Cuenta = 0 ) )
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 1016
                                              and rptarb_hojaid = doc.cico_id ) )
                  or ( v_ram_id_circuitocontable = 0 ) )
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 1018
                                              and rptarb_hojaid = doc.emp_id ) )
                  or ( v_ram_id_Empresa = 0 ) ) );

   insert into tt_dc_csc_com_0010
     ( prov_id, cue_id, emp_id, suc_id, neto, descuento, subtotal, iva, total, pago, pendiente )
     ( select fc.prov_id,
              ai.cue_id,
              doc.emp_id,
              fc.suc_id,
              case fc.doct_id
                             when 8 then -fc.fc_neto
              else fc.fc_neto
                 end Neto,
              case fc.doct_id
                             when 8 then -coalesce(fc.fc_importedesc1, 0) + coalesce(fc.fc_importedesc2, 0)
              else coalesce(fc.fc_importedesc1, 0) + coalesce(fc.fc_importedesc2, 0)
                 end Descuento,
              case fc.doct_id
                             when 8 then -fc.fc_subtotal
              else fc.fc_subtotal
                 end Sub_Total,
              case fc.doct_id
                             when 8 then -coalesce(fc.fc_ivari, 0) + coalesce(fc.fc_ivarni, 0)
              else coalesce(fc.fc_ivari, 0) + coalesce(fc.fc_ivarni, 0)
                 end Iva,
              case fc.doct_id
                             when 8 then -fc.fc_total
              else fc.fc_total
                 end Total,
              case
                   when fc.fc_totalcomercial = 0
                     and fc.fc_fechavto < CURRENT_TIMESTAMP
                     and fc.fc_fechavto < p_Ffin
                     and fc.doct_id = 8 then -fc.fc_total
                   when fc.fc_totalcomercial = 0
                     and fc.fc_fechavto < CURRENT_TIMESTAMP
                     and fc.fc_fechavto < p_Ffin
                     and fc.doct_id <> 8 then fc.fc_total
              else 0
                 end Pagos,
              case
                   when fc.fc_totalcomercial = 0
                     and fc.fc_fechavto < CURRENT_TIMESTAMP
                     and fc.fc_fechavto < p_Ffin then 0
                   when fc.fc_totalcomercial = 0
                     and ( fc.fc_fechavto >= CURRENT_TIMESTAMP
                     or fc.fc_fechavto >= p_Ffin )
                     and fc.doct_id = 8 then -fc.fc_total
                   when fc.fc_totalcomercial = 0
                     and ( fc.fc_fechavto >= CURRENT_TIMESTAMP
                     or fc.fc_fechavto >= p_Ffin )
                     and fc.doct_id <> 8 then fc.fc_total   end Pendiente
       from FacturaCompra fc
              join Documento doc
               on fc.doc_id = doc.doc_id
              left join AsientoItem ai
               on fc.as_id = ai.as_id
              and ai.asi_tipo = v_cta_acreedor
          where ( ( fc.fc_fecha < p_Fini
                  and p_nTipo = 0 )
                  or ( fc.fc_fecha <= p_Fini
                  and p_nTipo in ( 1,2 ) )
                  or ( fc.fc_fecha >= p_Fini
                  and fc.fc_fecha <= p_Ffin
                  and p_nTipo = 3 ) )
                  and fc.est_id <> 7
                  and fc.fc_totalcomercial = 0
                  and (CASE
                                 when fc.fc_totalcomercial = 0
                                   and fc.fc_fechavto < CURRENT_TIMESTAMP
                                   and fc.fc_fechavto < p_Ffin then 0
                                 / * aca no importa si es fc o nc, sino que sea <> 0 * /
                                 when fc.fc_totalcomercial = 0
                                   and ( fc.fc_fechavto >= CURRENT_TIMESTAMP
                                   or fc.fc_fechavto >= p_Ffin ) then -fc.fc_total   end) <> 0
                  and ( exists ( select *
                                      from EmpresaUsuario
                                         where emp_id = doc.emp_id
                                                 and us_id = p_us_id )
                  or ( p_us_id = 1 ) )
/ * -///////////////////////////////////////////////////////////////////////
		
		INICIO SEGUNDA PARTE DE ARBOLES
		
/////////////////////////////////////////////////////////////////////// * /
                  and ( fc.prov_id = v_prov_id
                  or v_prov_id = 0 )
                  and ( fc.suc_id = v_suc_id
                  or v_suc_id = 0 )
                  and ( ai.cue_id = v_cue_id
                  or v_cue_id = 0 )
                  and ( doc.cico_id = v_cico_id
                  or v_cico_id = 0 )
                  and ( doc.emp_id = v_emp_id
                  or v_emp_id = 0 )
                  -- Arboles
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 29
                                              and rptarb_hojaid = fc.prov_id ) )
                  or ( v_ram_id_Proveedor = 0 ) )
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 1007
                                              and rptarb_hojaid = fc.suc_id ) )
                  or ( v_ram_id_Sucursal = 0 ) )
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 17
                                              and rptarb_hojaid = ai.cue_id ) )
                  or ( v_ram_id_Cuenta = 0 ) )
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 1016
                                              and rptarb_hojaid = doc.cico_id ) )
                  or ( v_ram_id_circuitocontable = 0 ) )
                  and ( ( exists ( select rptarb_hojaid
                                   from rptArbolRamaHoja
                                      where rptarb_cliente = v_clienteID
                                              and tbl_id = 1018
                                              and rptarb_hojaid = doc.emp_id ) )
                  or ( v_ram_id_Empresa = 0 ) ) );

   if p_conRemito <> 0 then
   begin
      -- Remitos
      --
      insert into tt_dc_csc_com_0010
        ( prov_id, cue_id, emp_id, suc_id, neto, descuento, subtotal, iva, total, pago, pendiente )
        ( select rc.prov_id,
                 null,
                 doc.emp_id,
                 rc.suc_id,
                 case rc.doct_id
                                when 25 then -rc.rc_neto
                 else rc.rc_neto
                    end Neto,
                 case rc.doct_id
                                when 25 then -coalesce(rc.rc_importedesc1, 0) + coalesce(rc.rc_importedesc2, 0)
                 else coalesce(rc.rc_importedesc1, 0) + coalesce(rc.rc_importedesc2, 0)
                    end Descuento,
                 case rc.doct_id
                                when 25 then -rc.rc_subtotal
                 else rc.rc_subtotal
                    end Sub_Total,
                 case rc.doct_id
                                when 25 then -coalesce(rc.rc_ivari, 0) + coalesce(rc.rc_ivarni, 0)
                 else coalesce(rc.rc_ivari, 0) + coalesce(rc.rc_ivarni, 0)
                    end Iva,
                 case rc.doct_id
                                when 25 then -rc.rc_total
                 else rc.rc_total
                    end Total,
                 0 Pagos,
                 case rc.doct_id
                                when 25 then -rc.rc_pendiente
                 else rc.rc_pendiente
                    end Pendiente
          from RemitoCompra rc
                 join Documento doc
                  on rc.doc_id = doc.doc_id
                 and p_conRemito <> 0
             where ( ( rc.rc_fecha < p_Fini
                     and p_nTipo = 0 )
                     or ( rc.rc_fecha <= p_Fini
                     and p_nTipo in ( 1,2 ) )
                     or ( rc.rc_fecha >= p_Fini
                     and rc.rc_fecha <= p_Ffin
                     and p_nTipo = 3 ) )
                     and rc.est_id <> 7
                     and p_conRemito <> 0
                     and ( exists ( select *
                                         from EmpresaUsuario
                                            where emp_id = doc.emp_id
                                                    and us_id = p_us_id )
                     or ( p_us_id = 1 ) )
/ * -///////////////////////////////////////////////////////////////////////
			
			INICIO SEGUNDA PARTE DE ARBOLES
			
/////////////////////////////////////////////////////////////////////// * /
                     and ( rc.prov_id = v_prov_id
                     or v_prov_id = 0 )
                     and ( rc.suc_id = v_suc_id
                     or v_suc_id = 0 )
                     and ( doc.cico_id = v_cico_id
                     or v_cico_id = 0 )
                     and ( doc.emp_id = v_emp_id
                     or v_emp_id = 0 )
                     -- Arboles
                     and ( ( exists ( select rptarb_hojaid
                                      from rptArbolRamaHoja
                                         where rptarb_cliente = v_clienteID
                                                 and tbl_id = 29
                                                 and rptarb_hojaid = rc.prov_id ) )
                     or ( v_ram_id_Proveedor = 0 ) )
                     and ( ( exists ( select rptarb_hojaid
                                      from rptArbolRamaHoja
                                         where rptarb_cliente = v_clienteID
                                                 and tbl_id = 1007
                                                 and rptarb_hojaid = rc.suc_id ) )
                     or ( v_ram_id_Sucursal = 0 ) )
                     and ( ( exists ( select rptarb_hojaid
                                      from rptArbolRamaHoja
                                         where rptarb_cliente = v_clienteID
                                                 and tbl_id = 1016
                                                 and rptarb_hojaid = doc.cico_id ) )
                     or ( v_ram_id_circuitocontable = 0 ) )
                     and ( ( exists ( select rptarb_hojaid
                                      from rptArbolRamaHoja
                                         where rptarb_cliente = v_clienteID
                                                 and tbl_id = 1018
                                                 and rptarb_hojaid = doc.emp_id ) )
                     or ( v_ram_id_Empresa = 0 ) ) );

   end;
   end if;

   --/////////////////////////////////////////////////////////////////////////
   -- Solo Saldos
   --/////////////////////////////////////////////////////////////////////////
   if p_nTipo <> 0 then
   begin
      if p_nTipo = 1 then
      begin
         open rtn for
            --/////////////////////////////////////
            -- Saldos iniciales
            --/////////////////////////////////////
            select 1 grp_total,
                         p_Fini Fecha,
                         emp.emp_nombre Empresa,
                         prov.prov_nombre || ' -RZ: ' || prov.prov_razonsocial || ' -CUIT: ' || prov.prov_cuit || ' -TE: ' || prov.prov_tel Proveedor,
                         cue.cue_nombre Cuenta,
                         suc.suc_nombre Sucursal,
                         SUM(neto) Neto,
                         SUM(descuento) Descuento,
                         SUM(subtotal) Sub_Total,
                         SUM(iva) Iva,
                         SUM(total) Total,
                         SUM(pago) Pagos,
                         SUM(pendiente) Pendiente,
                         SUM(pendiente) Vto_Pendiente
              from tt_dc_csc_com_0010 fc
                     join Proveedor prov
                      on fc.prov_id = prov.prov_id
                     join Empresa emp
                      on fc.emp_id = emp.emp_id
                     join Sucursal suc
                      on fc.suc_id = suc.suc_id
                     left join Cuenta cue
                      on fc.cue_id = cue.cue_id
              GROUP by fc.prov_id,prov.prov_nombre || ' -RZ: ' || prov.prov_razonsocial || ' -CUIT: ' || prov.prov_cuit || ' -TE: ' || prov.prov_tel,emp.emp_nombre,cue.cue_nombre,suc.suc_nombre

               HAVING ( ABS(SUM(sqlserver_utilities.round_(pendiente, 2))) >= p_saldominimo
              or p_soloDeudores = 0 )
              order by Proveedor,
                       emp.emp_nombre,
                       cue.cue_nombre,
                       suc.suc_nombre;

      end;
      else
      begin
         open rtn for
            --/////////////////////////////////////
            -- Saldos iniciales
            --/////////////////////////////////////
            select 1 grp_total,
                         p_Fini Fecha,
                         prov.prov_nombre || ' -RZ: ' || prov.prov_razonsocial || ' -CUIT: ' || prov.prov_cuit || ' -TE: ' || prov.prov_tel Proveedor,
                         SUM(neto) Neto,
                         SUM(descuento) Descuento,
                         SUM(subtotal) Sub_Total,
                         SUM(iva) Iva,
                         SUM(total) Total,
                         SUM(pago) Pagos,
                         SUM(pendiente) Pendiente,
                         SUM(pendiente) Vto_Pendiente
              from tt_dc_csc_com_0010 fc
                     join Proveedor prov
                      on fc.prov_id = prov.prov_id
              GROUP by fc.prov_id,prov.prov_nombre || ' -RZ: ' || prov.prov_razonsocial || ' -CUIT: ' || prov.prov_cuit || ' -TE: ' || prov.prov_tel

               HAVING ( ABS(SUM(sqlserver_utilities.round_(pendiente, 2))) >= p_saldominimo
              or p_soloDeudores = 0 )
              order by Proveedor;

      end;
      end if;

   end;
   --/////////////////////////////////////////////////////////////////////////
   -- Saldo y Periodo
   --/////////////////////////////////////////////////////////////////////////
   else
   begin
      open rtn for
         --/////////////////////////////////////////////////////////////////////////
         --
         --	Facturas, Notas de Credio/Debito y Ordenes de Pago en el Periodo
         --
         --/////////////////////////////////////////////////////////////////////////
         
         --/////////////////////////////////////
         -- Saldos iniciales
         --/////////////////////////////////////
         select 1 grp_total,
                      0 doct_id,
                      0 comp_id,
                      0 nOrden_id,
                      'Saldo Inicial' Documento,
                      p_Fini Fecha,
                      0 Numero,
                      'Saldo inicial' Comprobante,
                      prov_nombre || ' -RZ: ' || prov_razonsocial || ' -CUIT: ' || prov_cuit || ' -TE: ' || prov_tel Proveedor,
                      SUM(neto) Neto,
                      SUM(descuento) Descuento,
                      SUM(subtotal) Sub_Total,
                      SUM(iva) Iva,
                      SUM(total) Total,
                      SUM(pago) Pagos,
                      SUM(pendiente) Pendiente,
                      '' Moneda,
                      '' Estado,
                      cue_nombre Cuenta,
                      '' Documento,
                      emp_nombre Empresa,
                      suc_nombre Sucursal,
                      '' Cond_Pago,
                      '' Legajo,
                      '' Centro_de_Costo,
                      null Vto,
                      0 Vto_Importe,
                      SUM(pendiente) Vto_Pendiente,
                      null Observaciones
           from tt_dc_csc_com_0010 fc
                  join Proveedor prov
                   on fc.prov_id = prov.prov_id
                  join Empresa emp
                   on fc.emp_id = emp.emp_id
                  join Sucursal suc
                   on fc.suc_id = suc.suc_id
                  left join Cuenta cue
                   on fc.cue_id = cue.cue_id
           GROUP by fc.prov_id,prov_nombre || ' -RZ: ' || prov_razonsocial || ' -CUIT: ' || prov_cuit || ' -TE: ' || prov_tel,cue_nombre,suc_nombre,emp_nombre

            HAVING ( ABS(SUM(sqlserver_utilities.round_(pendiente, 2))) >= p_saldominimo
           or p_soloDeudores = 0 )
         union all
         --/////////////////////////////////////
         --	Facturas, Notas de Credio/Debito
         --/////////////////////////////////////
         select 1 grp_total,
                      fc.doct_id doct_id,
                      fc.fc_id comp_id,
                      1 nOrden_id,
                      doc_nombre Documento,
                      fc_fecha Fecha,
                      fc_numero Numero,
                      fc_nrodoc Comprobante,
                      prov_nombre || ' -RZ: ' || prov_razonsocial || ' -CUIT: ' || prov_cuit || ' -TE: ' || prov_tel Proveedor,
                      case fc.doct_id
                                     when 8 then -fc_neto
                      else fc_neto
                         end Neto,
                      case fc.doct_id
                                     when 8 then -fc_importedesc1 + fc_importedesc2
                      else fc_importedesc1 + fc_importedesc2
                         end Descuento,
                      case fc.doct_id
                                     when 8 then -fc_subtotal
                      else fc_subtotal
                         end Sub_Total,
                      case fc.doct_id
                                     when 8 then -fc_ivari + fc_ivarni
                      else fc_ivari + fc_ivarni
                         end Iva,
                      case fc.doct_id
                                     when 8 then -fc_total
                      else fc_total
                         end Total,
                      case
                           when fc_totalcomercial = 0
                             and fc_fechavto < CURRENT_TIMESTAMP
                             and fc_fechavto < p_Ffin
                             and fc.doct_id = 8 then -fc_total
                           when fc_totalcomercial = 0
                             and fc_fechavto < CURRENT_TIMESTAMP
                             and fc_fechavto < p_Ffin
                             and fc.doct_id <> 8 then fc_total
                      else 0
                         end Pagos,
                      case fc.doct_id
                                     when 8 then -fc_pendiente
                      else fc_pendiente
                         end Pendiente,
                      mon_nombre Moneda,
                      est_nombre Estado,
                      cue_nombre Cuenta,
                      doc_nombre Documento,
                      emp_nombre Empresa,
                      suc_nombre Sucursal,
                      cpg_nombre Cond_Pago,
                      case
                           when lgj_titulo <> '' then lgj_titulo
                      else lgj_codigo
                         end Legajo,
                      ccos_nombre Centro_de_Costo,
                      case
                           when fcd_fecha is not null then fcd_fecha
                      else fcp_fecha
                         end Vto,
                      case fc.doct_id
                                     when 8 then -coalesce(fcd_importe, fcp_importe)
                      else coalesce(fcd_importe, fcp_importe)
                         end Vto_Importe,
                      case
                           when fc_totalcomercial = 0
                             and fc_fechavto < CURRENT_TIMESTAMP
                             and fc_fechavto < p_Ffin then 0
                           when fc_totalcomercial = 0
                             and ( fc_fechavto >= CURRENT_TIMESTAMP
                             or fc_fechavto >= p_Ffin )
                             and fc.doct_id = 8 then -fc_total
                           when fc_totalcomercial = 0
                             and ( fc_fechavto >= CURRENT_TIMESTAMP
                             or fc_fechavto >= p_Ffin )
                             and fc.doct_id <> 8 then fc_total
                           when fc.doct_id = 8 then -coalesce(fcd_pendiente, 0)
                      else coalesce(fcd_pendiente, 0)
                         end Vto_Pendiente,
                      fc_descrip Observaciones
           from FacturaCompra fc
                  join Proveedor prov
                   on fc.prov_id = prov.prov_id
                  left join FacturaCompraDeuda fcd
                   on fc.fc_id = fcd.fc_id
                  left join FacturaCompraPago fcp
                   on fc.fc_id = fcp.fc_id
                  left join AsientoItem ai
                   on fc.as_id = ai.as_id
                  and asi_tipo = v_cta_acreedor
                  left join Cuenta cue
                   on ai.cue_id = cue.cue_id
                  join Moneda mon
                   on fc.mon_id = mon.mon_id
                  join Estado est
                   on fc.est_id = est.est_id
                  join Documento doc
                   on fc.doc_id = doc.doc_id
                  join Empresa emp
                   on doc.emp_id = emp.emp_id
                  join Sucursal suc
                   on fc.suc_id = suc.suc_id
                  left join Legajo lgj
                   on fc.lgj_id = lgj.lgj_id
                  join CondicionPago cpg
                   on fc.cpg_id = cpg.cpg_id
                  left join CentroCosto ccos
                   on fc.ccos_id = ccos.ccos_id
            where fc_fecha >= p_Fini
                    and fc_fecha <= p_Ffin
                    and fc.est_id <> 7
                    and ( ABS(sqlserver_utilities.round_(fc_pendiente, 2)) >= p_saldominimo
                    or p_soloDeudores = 0 )
                    and ( exists ( select *
                                         from EmpresaUsuario
                                            where emp_id = doc.emp_id
                                                    and us_id = p_us_id )
                    or ( p_us_id = 1 ) )
/ * -///////////////////////////////////////////////////////////////////////
		
		INICIO SEGUNDA PARTE DE ARBOLES
		
/////////////////////////////////////////////////////////////////////// * /
                    and ( fc.prov_id = v_prov_id
                    or v_prov_id = 0 )
                    and ( fc.suc_id = v_suc_id
                    or v_suc_id = 0 )
                    and ( ai.cue_id = v_cue_id
                    or v_cue_id = 0 )
                    and ( doc.cico_id = v_cico_id
                    or v_cico_id = 0 )
                    and ( doc.emp_id = v_emp_id
                    or v_emp_id = 0 )
                    -- Arboles
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 29
                                                and rptarb_hojaid = fc.prov_id ) )
                    or ( v_ram_id_Proveedor = 0 ) )
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 1007
                                                and rptarb_hojaid = fc.suc_id ) )
                    or ( v_ram_id_Sucursal = 0 ) )
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 17
                                                and rptarb_hojaid = ai.cue_id ) )
                    or ( v_ram_id_Cuenta = 0 ) )
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 1016
                                                and rptarb_hojaid = doc.cico_id ) )
                    or ( v_ram_id_circuitocontable = 0 ) )
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 1018
                                                and rptarb_hojaid = doc.emp_id ) )
                    or ( v_ram_id_Empresa = 0 ) )
         union all
         --/////////////////////////////////////
         --	Remitos, Notas de Credio/Debito
         --/////////////////////////////////////
         select 1 grp_total,
                            rc.doct_id doct_id,
                            rc.rc_id comp_id,
                            1 nOrden_id,
                            doc_nombre Documento,
                            rc_fecha Fecha,
                            rc_numero Numero,
                            rc_nrodoc Comprobante,
                            prov_nombre || ' -RZ: ' || prov_razonsocial || ' -CUIT: ' || prov_cuit || ' -TE: ' || prov_tel Proveedor,
                            case rc.doct_id
                                           when 25 then -rc_neto
                            else rc_neto
                               end Neto,
                            case rc.doct_id
                                           when 25 then -rc_importedesc1 + rc_importedesc2
                            else rc_importedesc1 + rc_importedesc2
                               end Descuento,
                            case rc.doct_id
                                           when 25 then -rc_subtotal
                            else rc_subtotal
                               end Sub_Total,
                            case rc.doct_id
                                           when 25 then -rc_ivari + rc_ivarni
                            else rc_ivari + rc_ivarni
                               end Iva,
                            case rc.doct_id
                                           when 25 then -rc_total
                            else rc_total
                               end Total,
                            0 Pagos,
                            case rc.doct_id
                                           when 25 then -rc_pendiente
                            else rc_pendiente
                               end Pendiente,
                            mon_nombre Moneda,
                            est_nombre Estado,
                            '' Cuenta,
                            doc_nombre Documento,
                            emp_nombre Empresa,
                            suc_nombre Sucursal,
                            cpg_nombre Cond_Pago,
                            case
                                 when lgj_titulo <> '' then lgj_titulo
                            else lgj_codigo
                               end Legajo,
                            ccos_nombre Centro_de_Costo,
                            rc_fecha Vto,
                            case rc.doct_id
                                           when 25 then -rc_pendiente
                            else rc_pendiente
                               end Vto_Importe,
                            case rc.doct_id
                                           when 25 then -rc_pendiente
                            else rc_pendiente
                               end Vto_Pendiente,
                            rc_descrip Observaciones
           from RemitoCompra rc
                  join Proveedor prov
                   on rc.prov_id = prov.prov_id
                  and p_conRemito <> 0
                  left join Documento doc
                   on rc.doc_id = doc.doc_id
                  left join Moneda mon
                   on doc.mon_id = mon.mon_id
                  left join Estado est
                   on rc.est_id = est.est_id
                  left join Empresa emp
                   on doc.emp_id = emp.emp_id
                  left join Sucursal suc
                   on rc.suc_id = suc.suc_id
                  left join Legajo lgj
                   on rc.lgj_id = lgj.lgj_id
                  left join CondicionPago cpg
                   on rc.cpg_id = cpg.cpg_id
                  left join CentroCosto ccos
                   on rc.ccos_id = ccos.ccos_id
            where rc_fecha >= p_Fini
                    and rc_fecha <= p_Ffin
                    and rc.est_id <> 7
                    and p_conRemito <> 0
                    and ( ABS(sqlserver_utilities.round_(rc_pendiente, 2)) >= p_saldominimo
                    or p_soloDeudores = 0 )
                    and ( exists ( select *
                                         from EmpresaUsuario
                                            where emp_id = doc.emp_id
                                                    and us_id = p_us_id )
                    or ( p_us_id = 1 ) )
/ * -///////////////////////////////////////////////////////////////////////
		
		INICIO SEGUNDA PARTE DE ARBOLES
		
/////////////////////////////////////////////////////////////////////// * /
                    and ( rc.prov_id = v_prov_id
                    or v_prov_id = 0 )
                    and ( rc.suc_id = v_suc_id
                    or v_suc_id = 0 )
                    and ( doc.cico_id = v_cico_id
                    or v_cico_id = 0 )
                    and ( doc.emp_id = v_emp_id
                    or v_emp_id = 0 )
                    -- Arboles
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 29
                                                and rptarb_hojaid = rc.prov_id ) )
                    or ( v_ram_id_Proveedor = 0 ) )
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 1007
                                                and rptarb_hojaid = rc.suc_id ) )
                    or ( v_ram_id_Sucursal = 0 ) )
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 1016
                                                and rptarb_hojaid = doc.cico_id ) )
                    or ( v_ram_id_circuitocontable = 0 ) )
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 1018
                                                and rptarb_hojaid = doc.emp_id ) )
                    or ( v_ram_id_Empresa = 0 ) )
         --/////////////////////////////////////
         --	Ordenes de Pago
         --/////////////////////////////////////
         union all
         select 1 grp_total,
                opg.doct_id doct_id,
                opg.opg_id comp_id,
                1 nOrden_id,
                doc_nombre Documento,
                opg_fecha Fecha,
                opg_numero Numero,
                opg_nrodoc Comprobante,
                prov_nombre || ' -RZ: ' || prov_razonsocial || ' -CUIT: ' || prov_cuit || ' -TE: ' || prov_tel Proveedor,
                0 Neto,
                0 Descuento,
                0 Sub_Total,
                0 Iva,
                0 Total,
                opg_total Pagos,
                -opg_pendiente Pendiente,
                '' Moneda,
                est_nombre Estado,
                ( select min(cue_nombre)
                  from OrdenPagoItem opgi
                         join Cuenta cue
                          on opgi.cue_id = cue.cue_id
                     where opg_id = opg.opg_id
                             and opgi_tipo = 5 ) Cuenta,
                doc_nombre Documento,
                emp_nombre Empresa,
                suc_nombre Sucursal,
                '' Cond_Pago,
                case
                     when lgj_titulo <> '' then lgj_titulo
                else lgj_codigo
                   end Legajo,
                ccos_nombre Centro_de_Costo,
                opg_fecha Vto,
                0 Vto,
                -opg_pendiente Vto_Pendiente,
                opg_descrip Observaciones
           from OrdenPago opg
                  join Proveedor prov
                   on opg.prov_id = prov.prov_id
                  join Estado est
                   on opg.est_id = est.est_id
                  join Documento doc
                   on opg.doc_id = doc.doc_id
                  join Empresa emp
                   on doc.emp_id = emp.emp_id
                  join Sucursal suc
                   on opg.suc_id = suc.suc_id
                  left join Legajo lgj
                   on opg.lgj_id = lgj.lgj_id
                  left join CentroCosto ccos
                   on opg.ccos_id = ccos.ccos_id
            where opg_fecha >= p_Fini
                    and opg_fecha <= p_Ffin
                    and opg.est_id <> 7
                    and ( ABS(sqlserver_utilities.round_(opg_pendiente, 2)) >= p_saldominimo
                    or p_soloDeudores = 0 )
                    and ( exists ( select *
                                         from EmpresaUsuario
                                            where emp_id = doc.emp_id
                                                    and us_id = p_us_id )
                    or ( p_us_id = 1 ) )
/ * -///////////////////////////////////////////////////////////////////////
		
		INICIO SEGUNDA PARTE DE ARBOLES
		
/////////////////////////////////////////////////////////////////////// * /
                    and ( opg.prov_id = v_prov_id
                    or v_prov_id = 0 )
                    and ( opg.suc_id = v_suc_id
                    or v_suc_id = 0 )
                    and ( exists ( select *
                                   from OrdenPagoItem
                                      where opg_id = opg.opg_id
                                              and opgi_tipo = v_cta_acreedoropg
                                              and cue_id = v_cue_id )
                    or v_cue_id = 0 )
                    and ( doc.cico_id = v_cico_id
                    or v_cico_id = 0 )
                    and ( doc.emp_id = v_emp_id
                    or v_emp_id = 0 )
                    -- Arboles
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 29
                                                and rptarb_hojaid = opg.prov_id ) )
                    or ( v_ram_id_Proveedor = 0 ) )
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 1007
                                                and rptarb_hojaid = opg.suc_id ) )
                    or ( v_ram_id_Sucursal = 0 ) )
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 17
                                                and ( exists ( select *
                                                               from OrdenPagoItem
                                                                  where opg_id = opg.opg_id
                                                                          and opgi_tipo = v_cta_acreedoropg
                                                                          and cue_id = rptarb_hojaid ) ) ) )
                    or ( v_ram_id_Cuenta = 0 ) )
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 1016
                                                and rptarb_hojaid = doc.cico_id ) )
                    or ( v_ram_id_circuitocontable = 0 ) )
                    and ( ( exists ( select rptarb_hojaid
                                     from rptArbolRamaHoja
                                        where rptarb_cliente = v_clienteID
                                                and tbl_id = 1018
                                                and rptarb_hojaid = doc.emp_id ) )
                    or ( v_ram_id_Empresa = 0 ) )
           order by Proveedor,
                    Cuenta,
                    Fecha,
                    nOrden_id;

   end;
   end if;
*/

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function dc_csc_com_0010(integer, date, date, character varying, character varying, character varying, character varying, smallint, character varying, smallint, smallint, smallint)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: add_months(timestamp with time zone, integer)

-- drop function add_months(timestamp with time zone, integer);

create or replace function add_months(p_date timestamp with time zone, p_interval_val integer)
  returns timestamp with time zone as
$BODY$
begin
    return (p_date + (p_interval_val * '1 month'::INTERVAL));
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function add_months(timestamp with time zone, integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: add_months(timestamp with time zone, integer)

-- drop function add_months(timestamp with time zone, integer);

create or replace function add_months(p_date timestamp with time zone, p_interval_val integer)
  returns timestamp with time zone as
$BODY$
begin
    return (p_date + (p_interval_val * '1 month'::INTERVAL));
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function add_months(timestamp with time zone, integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: dateadd(character varying, integer, timestamp with time zone)

-- drop function dateadd(character varying, integer, timestamp with time zone);

create or replace function dateadd(p_interval character varying, p_interval_val integer, p_date timestamp with time zone)
  returns timestamp with time zone as
$BODY$
declare
    v_ucase_interval varchar(10);
    v_date timestamp with time zone;
begin
    v_date := p_date;
    v_ucase_interval := UPPER(p_interval);
      
    if v_ucase_interval in ('YEAR', 'YY', 'YYYY')
    then
      RETURN add_months(v_date, p_interval_val * 12);
      
    ELSif v_ucase_interval in ('QUARTER', 'QQ', 'Q')
    then
      RETURN add_months(v_date, p_interval_val * 3);
      
    ELSif v_ucase_interval in ('MONTH', 'MM', 'M')
    then
      RETURN add_months(v_date, p_interval_val);
      
    ElSif v_ucase_interval in ('DAYOFYEAR', 'DY', 'Y', 'DAY', 'DD', 'D', 'WEEKDAY', 'DW', 'W')
    then
      RETURN v_date + (p_interval_val * '1 day'::interval);
      
    ElSif v_ucase_interval in ('WEEK', 'WK', 'WW')
    then
      RETURN v_date + (p_interval_val * 7 * '1 day'::interval);
      
    ElSif v_ucase_interval in ('HOUR', 'HH')
    then
      RETURN v_date + (p_interval_val * '1 hour'::interval);
      
    ElSif v_ucase_interval in ('MINUTE', 'MI', 'N')
    then
      RETURN v_date + (p_interval_val * '1 minute'::interval);
      
    ElSif v_ucase_interval in ('SECOND', 'SS', 'S')
    then
      RETURN v_date + (p_interval_val * '1 second'::interval);
      
    ElSif v_ucase_interval in ('MILLISECOND', 'MS')
    then
      RETURN v_date + (p_interval_val * '1 millisecond'::interval);
      
    else
      RETURN null;
    end if;
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function dateadd(character varying, integer, timestamp with time zone)
  owner to postgres;

/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: getdate()

-- drop function getdate();

create or replace function getdate()
  returns timestamp with time zone as
'select now()'
  language sql STABLE
  cost 100;
alter function getdate()
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: isnumeric(integer)

-- drop function isnumeric(integer);

create or replace function isnumeric(param integer)
  returns smallint as
$BODY$
begin
	return -1;
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function isnumeric(integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: isnumeric(character varying)

-- drop function isnumeric(character varying);

create or replace function isnumeric(param character varying)
  returns smallint as
$BODY$
begin
	if (param ~ E'^[-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?$') then
		return -1;
	else
		return 0;
	end if;
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function isnumeric(character varying)
  owner to postgres;

/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbconvertid(character varying)

-- drop function sp_arbconvertid(character varying);

create or replace function sp_arbconvertid(in p_id character varying, out p_hoja_id integer, out p_ram_id integer)
  returns record as
$BODY$
declare
begin

   p_hoja_id := 0;

   p_ram_id := 0;

   if SUBSTR(p_id, 1, 1) = 'n' then-- esto significa que es un nodo
   
      p_ram_id := to_number(SUBSTR(p_id, 2, LENGTHB(p_id) - 1));

   else
      p_hoja_id := to_number(p_id);

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbconvertid(character varying)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbgetallhojas(integer, integer, integer)

-- drop function sp_arbgetallhojas(integer, integer, integer);

create or replace function sp_arbgetallhojas(p_ram_id integer, p_clienteid integer, p_tblidalias integer)
  returns void as
$BODY$
declare
   v_tot2 integer;
   v_tot1 integer;
   v_n integer;
begin

   create temporary table tt_t_rama
   (
     ram_id integer  not null,
     N integer  not null
   ) on commit drop;

   if p_ram_id = 0 then
      RETURN;
   end if;

   if p_clienteId = 0 then
      raise exception '@@ERROR_SP:El procedimiento almacenado sp_ArbGetAllHojas no puede ser llamado para obtener un cursor. Se debe usar sp_ArbGetAllHojasRs.';
      RETURN;
   end if;
	 
   v_tot1 := -1;

   v_tot2 := 0;

   v_n := 1;

   insert into tt_t_rama ( ram_id, N )
                  values ( p_ram_id, 0 );

   while v_tot1 < v_tot2
   loop
      begin
         v_tot1 := v_tot2;

         insert into tt_t_rama
           ( ram_id, N )
           ( select r.ram_id,
                    v_n
             from Rama r,
                  tt_t_rama t
                where r.ram_id_padre = t.ram_id
                        and t.N = v_n - 1
                        and r.ram_id <> t.ram_id );

         select COUNT(*)
         into v_tot2
         from tt_t_rama;

         v_n := v_n + 1;

      end;
   end loop;

   if p_clienteId <> 0 then
   declare
      v_tbl_id integer;
   begin
      select tbl_id
        into v_tbl_id
      from Arbol inner join Rama on Arbol.arb_id = Rama.arb_id
      where Rama.ram_id = p_ram_id;

      if p_tblIdAlias <> 0 then
         v_tbl_id := p_tblIdAlias;
      end if;

      insert into rptArbolRamaHoja
        ( rptarb_cliente, rptarb_hojaid, tbl_id, ram_id )
        ( select DISTINCT p_clienteId,
                          h.id,
                          v_tbl_id,
                          t.ram_id
          from Hoja h inner join tt_t_rama t on h.ram_id = t.ram_id );

   end;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbgetallhojas(integer, integer, integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbisraiz(integer)

-- drop function sp_arbisraiz(integer);

create or replace function sp_arbisraiz(in p_ram_id integer, out p_israiz smallint)
  returns smallint as
$BODY$
declare
   v_temp integer := 0;
begin

   begin
      select count(*) into v_temp
      from Rama
         where ram_id = p_ram_id
                 and ram_id_padre = 0;
   exception
      when others then
         null;
         raise info 'puto';
   end;

   -- Verifico que se trate de una raiz
   if v_temp = 1 then
      p_IsRaiz := 1::smallint;

   else
      p_IsRaiz := 0::smallint;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbisraiz(integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cfg_getValor(character varying, character varying, smallint, integer)

-- drop function sp_cfg_getValor(character varying, character varying, smallint, integer);

create or replace function sp_cfg_getValor(in p_cfg_grupo character varying, in p_cfg_aspecto character varying, out p_cfg_valor character varying, in p_bshow smallint, in p_emp_id integer)
  returns character varying as
$BODY$
begin

   if p_bShow <> 0 then
    raise exception '@@ERROR_SP:El procedimiento almacenado sp_cfg_getValor no puede ser llamado para obtener un cursor. Se debe usar sp_cfg_getValorRs.';
		RETURN;
   end if;

   select cfg_valor
     into p_cfg_valor
     from Configuracion
      where cfg_grupo = p_cfg_grupo
              and cfg_aspecto = p_cfg_aspecto
              and ( emp_id = p_emp_id
              or ( emp_id is null
              and p_emp_id is null ) );
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cfg_getValor(character varying, character varying, smallint, integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cfg_getValorrs(character varying, character varying, smallint, integer)

-- drop function sp_cfg_getValorrs(character varying, character varying, smallint, integer);

create or replace function sp_cfg_getValorrs(in p_cfg_grupo character varying, in p_cfg_aspecto character varying, out p_cfg_valor character varying, in p_bshow smallint, in p_emp_id integer, out rtn refcursor)
  returns record as
$BODY$
begin

   select cfg_valor
     into p_cfg_valor
     from Configuracion
      where cfg_grupo = p_cfg_grupo
              and cfg_aspecto = p_cfg_aspecto
              and ( emp_id = p_emp_id
              or ( emp_id is null
              and p_emp_id is null ) );

   if p_bShow <> 0 then
      open rtn for
         select p_cfg_valor
           from DUAL ;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cfg_getValorrs(character varying, character varying, smallint, integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_dbgetnewid2(character varying, character varying, integer, integer, smallint)

-- drop function sp_dbgetnewid2(character varying, character varying, integer, integer, smallint);

create or replace function sp_dbgetnewid2(in p_tabla character varying, in p_pk character varying, in p_min integer, in p_max integer, out p_id integer, in p_bselect smallint)
  returns integer as
$BODY$
begin

   if p_bselect <> 0 then
      raise exception '@@ERROR_SP:El procedimiento almacenado SP_DBGetNewId2 no puede ser llamado para obtener un cursor. Se debe usar SP_DBGetNewId2Rs.';
			RETURN;
   end if;

   select max(Id_NextId)
     into p_id
     from Id
      where Id_Tabla = p_tabla
              and Id_CampoId = p_pk
              and Id_Rango = p_min;

   -- si no existe en la tabla
   if coalesce(p_id, 0) = 0 then
   declare
      v_sqlstmt varchar(5000);
   begin
      v_sqlstmt := 'insert into Id (Id_Tabla, Id_NextId, Id_CampoId, Id_Rango) select '''
                    || p_tabla || 
                    ''',coalesce(max(to_number(' || p_pk || ')),0)+1, ''' 
                    || p_pk || ''',' 
                    || to_char(p_min) || 
                    ' from ' || p_tabla ||
                    ' where isnumeric(' || p_pk || ')<>0 and (to_number(' || p_pk || ') >= '
                    || to_char(p_min) 
                    || ' and ' || ' to_number(' || p_pk || ') <= ' || to_char(p_max) || ')';

      EXECUTE v_sqlstmt;

      select max(Id_NextId)
        into p_id
        from Id
         where Id_Tabla = p_tabla
                 and Id_CampoId = p_pk
                 and Id_Rango = p_min;

   end;
   end if;

   p_id := coalesce(p_id, 0);

   if p_id = 0 then
      p_id := p_min;

   end if;

   if p_id < p_min then
      p_id := p_min;

   end if;

   if p_id > p_max then
      p_id := p_max;

   end if;

   update id
      set Id_NextId = p_id + 1
      where Id_Tabla = p_tabla
     and Id_CampoId = p_pk
     and Id_Rango = p_min;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_dbgetnewid2(character varying, character varying, integer, integer, smallint)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_getrptid()

-- drop function sp_getrptid();

create or replace function sp_getrptid(out p_clienteid integer)
  returns integer as
$BODY$
declare
begin

   select id_NextId
     into p_ClienteID
     from Id
      where Id_Tabla = 'rptArbolRamaHoja'
              and id_CampoId = 'rptarb_cliente';

   if coalesce(p_ClienteID, 0) = 0 then
   begin
      insert into id
        ( id_NextId, id_Tabla, id_CampoId )
        values ( 0, 'rptArbolRamaHoja', 'rptarb_cliente' );

      p_ClienteID := 1;

   end;
   end if;

   update id
      set id_NextId = p_ClienteID + 1
      where Id_Tabla = 'rptArbolRamaHoja'
     and id_CampoId = 'rptarb_cliente';

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_getrptid()
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: to_char(integer)

-- drop function to_char(integer);

create or replace function to_char(param integer)
  returns varchar as
$BODY$
begin
	return to_char(param,'9999999999999');
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function to_char(integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javiers

http://www.crowsoft.com.ars

javier at crowsoft.com.ar
*/
-- Function: to_number(integer)

-- drop function to_number(integer);

create or replace function to_number(param integer)
  returns integer as
$BODY$
begin
	return param;
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function to_number(integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: to_number(character varying)

-- drop function to_number(character varying);

create or replace function to_number(param character varying)
  returns integer as
$BODY$
begin
	return to_number(param, '999999999');
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function to_number(character varying)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: charindex()

-- drop function charindex();

-- thanks to http://www.xzilla.net/blog/2006/Dec/sql-servers-charindex-function-in-postgresql.html

create or replace function charindex(
        text, 
        text, 
        integer
) 
returns integer
as
$BODY$ 
        select case when strpos(substr($2, $3+1), $1) = 0 then 0 else strpos(substr($2, $3+1), $1) + $3
end;
$BODY$
  language SQL IMMUTABLE returns null on null INPUT;
alter function charindex(text, text, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: dateadd(character varying, integer, timestamp with time zone)

-- drop function dateadd(character varying, integer, timestamp with time zone);

create or replace function dateadd(p_interval character varying, p_interval_val integer, p_date timestamp with time zone)
  returns timestamp with time zone as
$BODY$
declare
    v_ucase_interval varchar(10);
    v_date timestamp with time zone;
begin
    v_date := p_date;
    v_ucase_interval := UPPER(p_interval);
      
    if v_ucase_interval in ('YEAR', 'YY', 'YYYY')
    then
      RETURN add_months(v_date, p_interval_val * 12);
      
    ELSif v_ucase_interval in ('QUARTER', 'QQ', 'Q')
    then
      RETURN add_months(v_date, p_interval_val * 3);
      
    ELSif v_ucase_interval in ('MONTH', 'MM', 'M')
    then
      RETURN add_months(v_date, p_interval_val);
      
    ElSif v_ucase_interval in ('DAYOFYEAR', 'DY', 'Y', 'DAY', 'DD', 'D', 'WEEKDAY', 'DW', 'W')
    then
      RETURN v_date + (p_interval_val * '1 day'::interval);
      
    ElSif v_ucase_interval in ('WEEK', 'WK', 'WW')
    then
      RETURN v_date + (p_interval_val * 7 * '1 day'::interval);
      
    ElSif v_ucase_interval in ('HOUR', 'HH')
    then
      RETURN v_date + (p_interval_val * '1 hour'::interval);
      
    ElSif v_ucase_interval in ('MINUTE', 'MI', 'N')
    then
      RETURN v_date + (p_interval_val * '1 minute'::interval);
      
    ElSif v_ucase_interval in ('SECOND', 'SS', 'S')
    then
      RETURN v_date + (p_interval_val * '1 second'::interval);
      
    ElSif v_ucase_interval in ('MILLISECOND', 'MS')
    then
      RETURN v_date + (p_interval_val * '1 millisecond'::interval);
      
    else
      RETURN null;
    end if;
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function dateadd(character varying, integer, timestamp with time zone)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
/*

THIS function NEEDS unaccent.sql to be run in the database

where to find that script for 9.0
locate unaccent
/Library/PostgreSQL/9.0/share/postgresql/contrib/unaccent.sql

from 9.1 and above you can use:

create EXTENSION unaccent;

from: http://stackoverflow.com/questions/11005036/does-postgresql-support-accent-insensitive-collations

unaccent is a text search dictionary that removes accents (diacritic signs) from lexemes.

Index

To use an index for that kind of query, create an index on the expression. However, Postgres only accepts
IMMUTABLE functions for functional indexes. if a function can return a different result under different
circumstances, the index could silently break.

unaccent() only STABLE not IMMUTABLE

Unfortunately, unaccent() is only STABLE, not IMMUTABLE. According to this thread on pgsql-bugs, 
this is due to three reasons:

It depends on the behavior of a dictionary.
There is no hard-wired connection to this dictionary.
It therefore also depends on the current search_path, which can change easily.
Some tutorials on the web instruct to just alter the function and declare it IMMUTABLE.
This is a brute-force method that might break under rare circumstances.

Others suggest a simple IMMUTABLE wrapper function, like I did myself in the past.

There is an ongoing debate whether to make the variant with two parameters IMMUTABLE 
which declares the used dictionary explicitly. Read here or here.

Another alternative would be this module with an IMMUTABLE unaccent() function by Musicbrainz, 
provided on Github. Haven't tested it myself. I think I have come up with a better idea:

Best for now

All of this put together I propose this mostly safe approach that is just as efficient as other 
solutions floating around, but safer: Create a simple wrapper function with the two-parameter 
variant that hard-codes the correct dictionary as well as the right search_path:

Set the search_path to the schema where you install your extensions (default is public).
Why the dangling pg_temp? To rule out temporary objects coming first. More in the manual here.
You can build a functional index using that, since it is declared IMMUTABLE.

create INDEX users_unaccent_name_idx on users(f_unaccent(name));
Adapt your query to use the index:

select *
FROM   users
WHERE  f_unaccent(name) = f_unaccent('João');

Pattern matching

if you want to use it with LIKE (and a pattern that is not left-anchored), you
can combine this with the module pg_tgrm in PostgreSQL 9.1 or later. Create a 
functional GIN or GIST index. Example for GIN:

create INDEX users_unaccent_name_trgm_idx on users
USING gin (f_unaccent(name) gin_trgm_ops);
Be aware that GIN and GIST indexes are somewhat more expensive to maintain. Would be used in a query like:

select *
FROM   users
WHERE  f_unaccent(name) LIKE ('%' || f_unaccent('João') || '%');
I have written a more detailed answer about pattern matching and performance in a recent answer on dba.SE.

pg_tgrm also provides very useful operators for "similarity" % and "distance" <->.

*/

create or replace function f_unaccent(text)
  returns text as
$func$
select unaccent('unaccent', $1)
$func$  language sql IMMUTABLE set search_path = public, pg_temp;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: getdate()

-- drop function getdate();

create or replace function getdate()
  returns timestamp with time zone as
'select now()'
  language sql STABLE
  cost 100;
alter function getdate()
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: instr()

-- drop function instr();

-- thanks to http://www.xzilla.net/blog/2006/Dec/sql-servers-instr-function-in-postgresql.html

create or replace function instr(
        text, 
        text, 
        integer default 0
) 
returns integer
as
$BODY$ 
        select case when strpos(substr($1, $3+1), $2) = 0 then 0 else strpos(substr($1, $3+1), $2) + $3
end;
$BODY$
  language SQL IMMUTABLE returns null on null INPUT;
alter function instr(text, text, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: is_error(varchar)

-- drop function is_error(varchar);

create or replace function is_error(in p_error_code varchar) 
returns boolean as
$body$
declare
v_error varchar;
begin

          v_error := substring(p_error_code, 1, 2);

          return v_error not in ('00','01','02');

end;
$body$
  language plpgsql volatile
  cost 100;
alter function is_error(varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: isnumeric(integer)

-- drop function isnumeric(integer);

create or replace function isnumeric(param integer)
  returns smallint as
$BODY$
begin
	return -1;
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function isnumeric(integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: isnumeric(character varying)

-- drop function isnumeric(character varying);

create or replace function isnumeric(param character varying)
  returns smallint as
$BODY$
begin
	if (param ~ E'^[-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?$') then
		return -1;
	else
		return 0;
	end if;
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function isnumeric(character varying)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: number_to_char(character varying)

-- drop function number_to_char(character varying);

create or replace function number_to_char(
   in val decimal(18,6),
   in format varchar default '999G999G999G990D00'
)
returns varchar as
$BODY$
begin

  return trim(to_char(val, format));

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function number_to_char(decimal, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: result_error()

-- drop function result_error();

create or replace function result_error
(
    in message varchar
)
  returns row_result as
$BODY$
declare
  rtn row_result;
begin

    rtn.type := 'ERROR';
    rtn.message := message;
    return rtn;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function result_error(varchar)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: result_failed()

-- drop function result_failed();

create or replace function result_failed
(
)
  returns row_result as
$BODY$
declare
  rtn row_result;
begin

    rtn.type := 'success';
    rtn.id := 0;
    return rtn;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function result_failed()
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: result_get_id_or_error()

-- drop function result_get_id_or_error(integer, varchar);

create or replace function result_get_id_or_error (
  in rslt row_result,
  in p_id_name varchar,
  out p_id integer,
  out p_success integer,
  out p_error_msg varchar
)
  returns record as
$BODY$
begin

   if rslt.type = 'ERROR' then
      p_error_msg := '@@ERROR_SP:' || rslt.message;
      p_success := 0
      exit;
   else
      if rslt.type = p_id_name then
         p_id = rslt.id;
         p_success := 1;
         exit;
      end if;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function result_get_id_or_error(row_result, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: result_success()

-- drop function result_success();

create or replace function result_success
(
)
  returns row_result as
$BODY$
declare
  rtn row_result;
begin

    rtn.type := 'success';
    rtn.id := 1;
    return rtn;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function result_success()
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_arbol_create()

-- drop function sp_arb_arbol_create();

create or replace function sp_arb_arbol_create(
  in p_us_id integer,
  in p_tbl_id integer,
  in p_nombre varchar,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
        v_arb_id integer;
        v_raiz_id integer;
begin

        select SP_DBGetNewId('arbol',
                              'arb_id') into v_arb_id;

        insert into arbol (arb_id, arb_nombre, tbl_id, modifico)
        values (v_arb_id, p_nombre, p_tbl_id, p_us_id);

        select SP_DBGetNewId('rama',
                             'ram_id') into v_raiz_id;

        insert into rama (ram_id, ram_nombre, ram_id_padre, ram_orden, arb_id, modifico)
        values (v_raiz_id, p_nombre, 0, 0, v_arb_id, p_us_id);

        rtn := 'rtn';

        open rtn for select arb_id, arb_nombre, v_raiz_id as ram_id from arbol where arb_id = v_arb_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_arbol_create(integer, integer, varchar)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_arbol_sort()

-- drop function sp_arb_arbol_sort(int, int);

create or replace function sp_arb_arbol_sort(
  in p_us_id integer,
  in p_arb_id integer,
  in p_desc integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   c_arbol refcursor;
   v_row record;
   v_ram_id integer;
   v_ram_id_padre integer;
   v_last_ram_id_padre integer;
   v_orden integer;
   v_sqlstmt varchar(1000);
begin

   v_last_ram_id_padre := -1;

   v_sqlstmt := 'select ram_id, ram_id_padre from Rama where arb_id = ' || p_arb_id::varchar || ' order by ram_id_padre, ram_nombre';

   if p_desc <> 0 then
     v_sqlstmt := v_sqlstmt || ' desc';
   end if;

   open c_arbol for EXECUTE v_sqlstmt;

   loop
      fetch c_arbol into v_row;
      exit when not found;

      v_ram_id := v_row.ram_id;
      v_ram_id_padre := v_row.ram_id_padre;

      if v_ram_id_padre <> v_last_ram_id_padre then
        v_last_ram_id_padre := v_ram_id_padre;

        v_orden := 0;

      end if;

      v_orden := v_orden + 1;

      update rama set ram_orden = v_orden where ram_id = v_ram_id;

   end loop;

   close c_arbol;

   rtn := 'rtn';

   open rtn for select * from rama where ram_id = (select ram_id from rama where arb_id = p_arb_id and ram_id_padre = 0);

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_arbol_sort(integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbconvertid(character varying)

-- drop function sp_arbconvertid(character varying);

create or replace function sp_arbconvertid(in p_id character varying, out p_hoja_id integer, out p_ram_id integer)
  returns record as
$BODY$
declare
begin

   p_hoja_id := 0;

   p_ram_id := 0;

   if lower(SUBSTR(p_id, 1, 1)) = 'n' then-- esto significa que es un nodo
   
      p_ram_id := to_number(SUBSTR(p_id, 2, LENGTH(p_id) - 1));

   else
      p_hoja_id := to_number(p_id);

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbconvertid(character varying)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbgetallhojas(integer, integer, integer)

-- drop function sp_arbgetallhojas(integer, integer, integer);

create or replace function sp_arbgetallhojas(
in p_ram_id integer, 
in p_clienteid integer default 0, 
in p_tblidalias integer default 0)
  returns void as
$BODY$
declare
   v_tot2 integer;
   v_tot1 integer;
   v_n integer;
begin

   drop table if exists tt_t_rama;

   create temporary table tt_t_rama
   (
     ram_id integer  not null,
     N integer  not null
   ) on commit drop;

   if p_ram_id = 0 then
      RETURN;
   end if;

   if p_clienteId = 0 then
      raise exception '@@ERROR_SP:El procedimiento almacenado sp_ArbGetAllHojas no puede ser llamado para obtener un cursor. Se debe usar sp_ArbGetAllHojasRs.';
      RETURN;
   end if;
	 
   v_tot1 := -1;

   v_tot2 := 0;

   v_n := 1;

   insert into tt_t_rama ( ram_id, N )
                  values ( p_ram_id, 0 );

   while v_tot1 < v_tot2
   loop
      begin
         v_tot1 := v_tot2;

         insert into tt_t_rama
           ( ram_id, N )
           ( select r.ram_id,
                    v_n
             from Rama r,
                  tt_t_rama t
                where r.ram_id_padre = t.ram_id
                        and t.N = v_n - 1
                        and r.ram_id <> t.ram_id );

         select COUNT(*)
         into v_tot2
         from tt_t_rama;

         v_n := v_n + 1;

      end;
   end loop;

   if p_clienteId <> 0 then
   declare
      v_tbl_id integer;
   begin
      select tbl_id
        into v_tbl_id
      from Arbol inner join Rama on Arbol.arb_id = Rama.arb_id
      where Rama.ram_id = p_ram_id;

      if p_tblIdAlias <> 0 then
         v_tbl_id := p_tblIdAlias;
      end if;

      insert into rptArbolRamaHoja
        ( rptarb_cliente, rptarb_hojaid, tbl_id, ram_id )
        ( select DISTINCT p_clienteId,
                          h.id,
                          v_tbl_id,
                          t.ram_id
          from Hoja h inner join tt_t_rama t on h.ram_id = t.ram_id );

   end;
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbgetallhojas(integer, integer, integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbgetarboles(integer)

-- drop function sp_arbgetarboles(integer);

create or replace function sp_arbgetarboles(in p_tbl_id integer, out rtn refcursor)
  returns refcursor as
$BODY$
declare
begin

        rtn := 'rtn';

        open rtn for
        select  Arbol.arb_id,
                arb_Nombre,
                ram_id
        from Arbol,
             Rama
         where Rama.ram_id_padre = 0
                 and Arbol.arb_id = Rama.arb_id
                 and tbl_id = p_tbl_id
                 and Rama.ram_id <> 0;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbgetarboles(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbgetdecendencia()

-- drop function sp_arbgetdecendencia();

create or replace function sp_arbgetdecendencia(
        in p_ram_id integer default null,
        in p_incluir_ram_id integer default 1,
        in p_incluir_ram_id_padre integer default 0, -- este default es necesario para: SP_ArbCopiarRama, SP_ArbBorrarRama
        in p_incluir_nombre integer default 0,       -- este default es necesario para: SP_ArbCopiarRama, SP_ArbBorrarRama
        in p_incluir_arb_id integer default 0,
        out rtn refcursor)
  returns refcursor as
$BODY$
declare
   v_tot2 integer;
   v_tot1 integer;
   v_n integer;
   v_arb_id integer;
   v_sqlstmt varchar(512);
   v_where varchar(255);
   v_sqlArbId varchar(50);
   v_tran_id integer;
begin

        if p_ram_id = 0 then
                RETURN;
        end if;

        create TEMP table tt_t_rama2
        (
          tran_id integer not null,
          ram_id integer  not null,
          N integer  not null,
          ram_id_padre integer  not null,
          arb_id integer  not null,
          orden integer  not null
        ) on commit drop;

        v_tran_id := nextval('t_rama2_seq');

        v_tot1 := -1;

        v_tot2 := 0;

        v_n := 1;

        if p_incluir_arb_id <> 0 then
                select arb_id
                into v_arb_id
                from Rama
                where ram_id = p_ram_id;
        else
                v_arb_id := 0;
        end if;

        insert into tt_t_rama2
        (tran_id, ram_id, N, ram_id_padre, arb_id, orden)
        (select v_tran_id,
                p_ram_id,
                0,
                ram_id_padre,
                v_arb_id,
                ram_orden
        from Rama
        where ram_id = p_ram_id );

   while v_tot1 < v_tot2
   loop
      begin
         v_tot1 := v_tot2;

         insert into tt_t_rama2
           ( tran_id, ram_id, N, ram_id_padre, arb_id, orden )
           select v_tran_id,
                  r.ram_id,
                  v_n,
                  r.ram_id_padre,
                  v_arb_id,
                  r.ram_orden
             from Rama r,
                  tt_t_rama2 t
              where r.ram_id_padre = t.ram_id
                      and t.tran_id = v_tran_id
                      and t.N = v_n - 1
                      -- esto chequea que no existan referencias circulares
                      and not exists ( select *
                                       from tt_t_rama2
                                          where tt_t_rama2.ram_id = r.ram_id and tt_t_rama2.tran_id = v_tran_id )
             order by r.ram_orden;

         select COUNT(*) into v_tot2
         from tt_t_rama2 t where t.tran_id = v_tran_id;

         v_n := v_n + 1;

      end;
   end loop;

   v_where := ' where t.tran_id = ' || v_tran_id::varchar;

   if p_incluir_ram_id = 0 then
      v_where := v_where || ' and t.ram_id <> ' || to_char(p_ram_id);
   end if;

   if p_incluir_arb_id <> 0 then
      v_sqlArbId := ',t.arb_id';

   else
      v_sqlArbId := '';

   end if;

   if p_incluir_ram_id_padre <> 0 then
   begin
      if p_incluir_nombre <> 0 then
         v_sqlstmt := 'select t.ram_id,t.ram_id_padre,r.ram_nombre' || v_sqlArbId || ' from tt_t_rama2 t inner join rama r on t.ram_id = r.ram_id';

      else
         v_sqlstmt := 'select ram_id,ram_id_padre' || v_sqlArbId || ' from tt_t_rama2 t';

      end if;

   end;
   else
   begin
      if p_incluir_nombre <> 0 then
         v_sqlstmt := 'select t.ram_id,r.ram_nombre' || v_sqlArbId || ' from tt_t_rama2 t inner join rama r on t.ram_id = r.ram_id';

      else
         v_sqlstmt := 'select ram_id' || v_sqlArbId || ' from tt_t_rama2 t';

      end if;

   end;
   end if;

   v_sqlstmt := v_sqlstmt || v_where || ' order by n,orden';

   rtn := 'rtn';

   open rtn for EXECUTE v_sqlstmt;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbgetdecendencia(integer, integer, integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbgethojas()

-- drop function sp_arbgethojas();

create or replace function sp_arbgethojas(
  in p_ram_id integer default null,
  in p_soloColumnas integer default 0,
  in p_aBuscar varchar default '',
  in p_top integer default 3000,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   -- 1 Averiguo de que tabla se trata
   v_tabla varchar(5000);
   v_campoId varchar(5000);
   v_campoNombre varchar(255);
   v_campos varchar(5000);
   v_camposRama varchar(5000);
   v_tablasRama varchar(5000);
   v_where varchar(5000);
   v_prefix varchar(5000);
   v_sqlstmt varchar(5000);
   v_sqlstmt2 varchar(5000);
   v_sqlwhere varchar(5000);
   v_esRaiz integer;
   v_arb_id integer;
   v_tran_id integer;
begin

        create TEMP table tt_hojaid
        (
          tran_id integer not null,
          hoja_id integer not null,
          id integer not null
        ) on commit drop;

        v_tran_id := nextval('t_hojaid_seq');
        
   --------------------------------------------------------------------
   
   select ramc_valor
     into v_camposRama
     from RamaConfig
      where ram_id = p_ram_id
              and ramc_aspecto = 'Campos';

   select ramc_valor
     into v_tablasRama
     from RamaConfig
      where ram_id = p_ram_id
              and ramc_aspecto = 'Tablas';

   select ramc_valor
     into v_prefix
     from RamaConfig
      where ram_id = p_ram_id
              and ramc_aspecto = 'Prefix';

   select ramc_valor
     into v_where
     from RamaConfig
      where ram_id = p_ram_id
              and ramc_aspecto = 'where';

   if v_camposRama is null then
      v_camposRama := '';

   end if;

   if v_tablasRama is null then
      v_tablasRama := '';

   end if;

   if v_prefix is null then
      v_prefix := '';

   end if;

   if v_where is null then
      v_where := '';

   end if;

   --------------------------------------------------------------------
   select tbl_nombreFisico,
          tbl_camposInView,
          tbl_campoId,
          tbl_campoNombre
     into v_tabla,
          v_campos,
          v_campoId,
          v_campoNombre
     from arbol inner join rama on arbol.arb_id = rama.arb_id
                inner join tabla on tabla.tbl_id = arbol.tbl_id
     where rama.ram_id = p_ram_id;

   --------------------------------------------------------------------
   if LTRIM(v_camposRama) <> '' then
      v_campos := v_camposRama;

   end if;

   if LTRIM(v_prefix) = '' then
      v_prefix := v_tabla;

   end if;

   --------------------------------------------------------------------
   -- armo la sentencia sql
   v_sqlstmt := 'select hoja_id,';

   v_sqlstmt := v_sqlstmt || v_prefix || '.' || v_campoId || ' as ID,';

   if INSTR(v_campoNombre, 'codigo', 1) <> 0 then
      v_sqlstmt := v_sqlstmt || v_prefix || '.' || v_campoNombre || ' as Codigo';

   else
      if INSTR(v_campoNombre, 'apellido', 1) <> 0 then
         v_sqlstmt := v_sqlstmt || v_prefix || '.' || v_campoNombre || ' as Apellido' ;

      else
         v_sqlstmt := v_sqlstmt || v_prefix || '.' || v_campoNombre || ' as Nombre';

      end if;

   end if;

   v_campos := sp_strSetPrefix(v_prefix, v_campos);

   if LTRIM(v_campos) <> '' then
      v_sqlstmt := v_sqlstmt || ',' || v_campos;

   end if;

   v_sqlstmt := v_sqlstmt || ' from ' || v_tabla || ' ' || v_prefix;

   if LTRIM(v_tablasRama) <> '' then
      v_sqlstmt := v_sqlstmt || ',' || v_tablasRama;

   end if;

   v_sqlwhere := ' where Hoja.ram_id = ' || to_char(p_ram_id) || ' and Hoja.id = ' || v_prefix || '.' || v_campoId || v_where;

   -- si solo quieren las columnas
   if coalesce(p_soloColumnas, 0) <> 0 then
   begin
      v_sqlstmt := v_sqlstmt || ', Hoja ' || v_sqlwhere;

      v_sqlstmt := v_sqlstmt || ' and 1=2';

   end;
   else
   begin
      -- si se trata de la raiz tambien entran los que no estan asignados a ninguna rama
      select ram_id_padre,
             arb_id
        into v_esRaiz,
             v_arb_id
        from Rama
         where ram_id = p_ram_id;

      if v_esRaiz = 0 then
      begin
         -- Ids de la raiz
         v_sqlstmt2 := ' insert into tt_hojaid select ' || v_tran_id::varchar || ', hoja_id,id from Hoja where ram_id = ' || to_char(p_ram_id);

         EXECUTE v_sqlstmt2;--print (@sqlstmt2)--
         

         -- Ids sin asignar
         v_sqlstmt2 := 'insert into tt_hojaid select ' || v_tran_id::varchar || ', ' || v_campoId || '*-1,' || v_campoId || ' from ' || v_tabla || ' where not exists (select hoja_id from Hoja inner join Rama on Hoja.ram_id = Rama.ram_id where Hoja.id = ' || v_tabla || '.' || v_campoId || ' and Hoja.arb_id = ' || to_char(v_arb_id) || ' and (Rama.ram_id <> ram_id_padre or Rama.ram_id = 0))';

         EXECUTE v_sqlstmt2;--print (@sqlstmt2)--
         

         -- el filtro esta en tt_hojaid
         v_sqlstmt := v_sqlstmt || ', tt_hojaid where tt_hojaid.tran_id = ' || v_tran_id::varchar || ' and tt_hojaid.id = ' || v_prefix || '.' || v_campoId || v_where;

      end;
      else
         v_sqlstmt := v_sqlstmt || ', Hoja ' || v_sqlwhere;

      end if;

   end;
   end if;

   v_sqlstmt := v_sqlstmt || ' limit ' || p_top::varchar;

   rtn := 'rtn';

   open rtn for EXECUTE v_sqlstmt;
   --print (@sqlstmt)--
   
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbgethojas(integer, integer, varchar, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbgetramas(integer)

-- drop function sp_arbgetramas(integer);

create or replace function sp_arbgetramas(in p_arb_id integer, out rtn refcursor)
  returns refcursor as
$BODY$
declare
   -- para traer la raiz primero
   --select ram_id, ram_nombre, ram_id_padre from rama where arb_id = @@arb_id and ram_id <> 0 order by ram_id_padre
   v_raiz_id integer;
begin
        select ram_id
        into v_raiz_id
        from Rama
        where arb_id = p_arb_id
        and ram_id_padre = 0
        and ram_id <> 0;

        rtn := 'rtn';

        select into rtn t.rtn from SP_ArbGetDecendencia(v_raiz_id,1,1,1,0) t;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbgetramas(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_hoja_paste_copy()

-- drop function sp_arb_hoja_paste_copy();

create or replace function sp_arb_hoja_paste_copy
(
  in p_us_id integer,
  in p_ids varchar,
  in p_ram_id_copy_to integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_new_hoja_id integer;
   v_arb_id integer;

   c_leaves_to_copy refcursor;
   v_leave_row record;

   v_ids   varchar[];
   v_id    varchar;
   v_index integer;
begin

    if p_ids = '' then RETURN; end if;

    if p_ram_id_copy_to = 0 then RETURN; end if;

    if not exists(select 1 from rama where ram_id = p_ram_id_copy_to) then RETURN; end if;

    select arb_id into v_arb_id from rama where ram_id = p_ram_id_copy_to;


    -- Creo un cursor para recorrer cada una de las hojas e insertarlas
    open c_leaves_to_copy for EXECUTE 'select hoja_id, id, modifico from Hoja where hoja_id in (' || p_ids ||')';

    loop
        fetch c_leaves_to_copy into v_leave_row;
        exit when not found;
        begin

           if not exists(select 1 from hoja where ram_id = p_ram_id_copy_to and id = v_leave_row.id) then

               -- Por cada hoja obtengo un id nuevo
               select SP_DBGetNewId('hoja',
                                    'hoja_id') into v_new_hoja_id;

               insert into hoja ( hoja_id, id, modifico, ram_id, arb_id )
               values ( v_new_hoja_id, v_leave_row.id, v_leave_row.modifico, p_ram_id_copy_to, v_arb_id );

           end if;
        end;
    end loop;

    close c_leaves_to_copy;

    v_ids := regexp_split_to_array(p_ids, ',');

    for v_index in 1 .. array_upper(v_ids, 1)
    loop

        v_id := v_ids[v_index];

        if v_id::integer < 0 then

            -- Por cada hoja obtengo un id nuevo
            select SP_DBGetNewId('hoja',
                                 'hoja_id') into v_new_hoja_id;

            insert into hoja ( hoja_id, id, modifico, ram_id, arb_id )
            values ( v_new_hoja_id, v_id::integer * -1, p_us_id, p_ram_id_copy_to, v_arb_id );

        end if;
    end loop;

    rtn := 'rtn';

    open rtn for select * from rama where ram_id = p_ram_id_copy_to;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_hoja_paste_copy(integer, varchar, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_hoja_paste_cut()

-- drop function sp_arb_hoja_paste_cut();

create or replace function sp_arb_hoja_paste_cut
(
  in p_us_id integer,
  in p_ids varchar,
  in p_ram_id_to_paste_in integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_new_hoja_id integer;
   v_arb_id integer;

   c_leaves_to_copy refcursor;
   v_leave_row record;

   v_ids   varchar[];
   v_id    varchar;
   v_index integer;
begin

    if p_ids = '' then RETURN; end if;

    if p_ram_id_to_paste_in = 0 then RETURN; end if;

    if not exists(select 1 from rama where ram_id = p_ram_id_to_paste_in) then RETURN; end if;

    select arb_id into v_arb_id from rama where ram_id = p_ram_id_to_paste_in;


    -- Creo un cursor para recorrer cada una de las hojas e insertarlas
    open c_leaves_to_copy for EXECUTE 'select hoja_id, id, modifico from Hoja where hoja_id in (' || p_ids ||')';

    loop
        fetch c_leaves_to_copy into v_leave_row;
        exit when not found;
        begin

           if not exists(select 1 from hoja where ram_id = p_ram_id_to_paste_in and id = v_leave_row.id) then

               update hoja set ram_id = p_ram_id_to_paste_in, arb_id = v_arb_id where hoja_id = v_leave_row.hoja_id;

           else

               delete from hoja where hoja_id = v_leave_row.hoja_id;

           end if;
        end;
    end loop;

    close c_leaves_to_copy;

    v_ids := regexp_split_to_array(p_ids, ',');

    for v_index in 1 .. array_upper(v_ids, 1)
    loop

        v_id := v_ids[v_index];

        if v_id::integer < 0 then

            -- Por cada hoja obtengo un id nuevo
            select SP_DBGetNewId('hoja',
                                 'hoja_id') into v_new_hoja_id;

            insert into hoja ( hoja_id, id, modifico, ram_id, arb_id )
            values ( v_new_hoja_id, v_id::integer * -1, p_us_id, p_ram_id_to_paste_in, v_arb_id );

        end if;
    end loop;

    rtn := 'rtn';

    open rtn for select * from rama where ram_id = p_ram_id_to_paste_in;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_hoja_paste_cut(integer, varchar, integer)
  owner to postgres;
  /*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbisraiz(integer)

-- drop function sp_arbisraiz(integer);

create or replace function sp_arbisraiz(in p_ram_id integer, out p_israiz smallint)
  returns smallint as
$BODY$
declare
   v_temp integer := 0;
begin

   begin
      select count(*) into v_temp
      from Rama
         where ram_id = p_ram_id
                 and ram_id_padre = 0;
   exception
      when others then
         null;
         raise info 'puto';
   end;

   -- Verifico que se trate de una raiz
   if v_temp = 1 then
      p_IsRaiz := 1::smallint;

   else
      p_IsRaiz := 0::smallint;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbisraiz(integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_rama_create()

-- drop function sp_arb_rama_create();

create or replace function sp_arb_rama_create(
  in p_us_id integer,
  in p_arb_id integer,
  in p_ram_id_padre integer,
  in p_nombre varchar,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
        v_ram_id integer;
        v_is_temp boolean;
        v_max integer;
        v_orden integer;
        v_arb_id integer;
begin

        select SP_DBGetNewId('rama',
                              'ram_id') into v_ram_id;

        v_is_temp := p_ram_id_padre = -1000;
    
        /*
        ' - Si es una rama temporal le asigno como padre
        '   su propio ID para que quede huerfana
        */
        if v_is_temp then
                p_ram_id_padre = v_ram_id;
                v_orden := 0;
        /*
        ' - Si no obtengo el numero de orden que le corresponde
        '   dentro del padre
        '
        */
        else
                select max(ram_orden) into v_max from rama where ram_id_padre = p_ram_id_padre;
                if v_max is null then
                        v_orden := 1;                        
                else
                        v_orden := v_max + 1;                        
                end if;

                select arb_id into p_arb_id from rama where ram_id = p_ram_id_padre;
        end if;

        insert into rama (ram_id, ram_nombre, ram_id_padre, ram_orden, arb_id, modifico)
        values (v_ram_id, p_nombre, p_ram_id_padre, v_orden, p_arb_id, p_us_id);

        rtn := 'rtn';

        open rtn for select * from rama where ram_id = v_ram_id;
   
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_rama_create(integer, integer, integer, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbborrarrama()

-- drop function sp_arbborrarrama(int, int);

create or replace function sp_arbborrarrama(
  in p_us_id integer,
  in p_ram_id integer
)
  returns void as
$BODY$
declare
   v_error_code varchar := '00';
   v_error_msg varchar := '';
   -- si la rama es raiz tengo que borrar el arbol
   v_arb_id integer;
   -- para actulizar el orden
   v_ram_orden integer;
   v_ram_id_padre integer;
   rtn refcursor;
   v_row record;
   v_tran_id integer;
begin

          if not exists(select 1 from rama where ram_id = p_ram_id) then RETURN; end if;

   --------------------------------------------------------------------

        create TEMP table tt_t_ramas_a_borrar
        (
          ram_id integer  not null,
          tran_id integer  not null
        ) on commit drop;
        
        v_tran_id := nextval('t_ramas_a_borrar_seq');
        
   --------------------------------------------------------------------
   
   set TRANSACTION READ WRITE;

   if p_ram_id = 0 then RETURN; end if;

   select arb_id,
          ram_orden,
          ram_id_padre
     into v_arb_id,
          v_ram_orden,
          v_ram_id_padre
     from Rama
     where ram_id = p_ram_id
       and ram_id_padre = 0;

   select into rtn t.rtn from SP_ArbGetDecendencia(p_ram_id,1,0,0,0) t;

   loop
          fetch rtn into v_row;
          exit when not found;
          insert into tt_t_ramas_a_borrar(ram_id, tran_id) values (v_row.ram_id, v_tran_id);
   end loop;
   close rtn;

   begin
      -- primero las hojas
      delete from Hoja where exists(select 1 from tt_t_ramas_a_borrar where Hoja.ram_id = tt_t_ramas_a_borrar.ram_id);

   exception
      when others then
         v_error_code := SQLSTATE;
         v_error_msg := SQLERRM;
   end;

   if not is_error(v_error_code) then

             begin
                -- ahora las ramas
                delete from Rama where exists (select 1 from tt_t_ramas_a_borrar where Rama.ram_id = tt_t_ramas_a_borrar.ram_id);
             exception
                when others then
                   v_error_code := SQLSTATE;
                   v_error_msg := SQLERRM;
             end;

             if not is_error(v_error_code) then
             begin
                       -- si era una raiz borro el arbol
                       if v_arb_id is not null then

                          delete from Arbol where arb_id = v_arb_id;

                       else
                          -- sino, tengo que actualizar el orden de los que estaban bajo esta rama
                          update rama
                             set ram_orden = ram_orden - 1
                          where ram_id_padre = v_ram_id_padre
                            and ram_orden < v_ram_orden;

                       end if;

                       RETURN;

             exception
                when others then
                   v_error_code := SQLSTATE;
                   v_error_msg := SQLERRM;
             end;
             end if;
   end if;
   
   if is_error(v_error_code) then

          raise exception 'No se pude borrar la rama. % %', v_error_code, v_error_msg;
          
   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbborrarrama(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_rama_get_rama(integer)

-- drop function sp_arb_rama_get_rama(integer, integer);

create or replace function sp_arb_rama_get_rama(in p_arb_id integer, in p_client_id integer, out rtn refcursor)
  returns refcursor as
$BODY$
begin

        rtn := 'rtn';

        open rtn for
        select rama.ram_id, ram_nombre, ram_id_padre
        from rama inner join hoja on rama.ram_id = hoja.ram_id
        where hoja.arb_id = p_arb_id
          and hoja.id = p_client_id
          and rama.ram_id <> rama.ram_id_padre; /* filter temp branches */

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_rama_get_rama(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_rama_get_ramas(integer)

-- drop function sp_arb_rama_get_ramas(integer);

create or replace function sp_arb_rama_get_ramas(in p_ram_id integer, out rtn refcursor)
  returns refcursor as
$BODY$
begin

        rtn := 'rtn';

        select into rtn t.rtn from SP_ArbGetDecendencia(p_ram_id,1,1,1,0) t;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_rama_get_ramas(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_rama_move_bottom()

-- drop function sp_arb_rama_move_bottom(int, int);

create or replace function sp_arb_rama_move_bottom(
  in p_us_id integer,
  in p_ram_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_last integer;
   v_ram_orden integer;
begin

   if not exists(select 1 from rama where ram_id = p_ram_id) then RETURN; end if;

   select max(ram_orden) into v_last from rama where ram_id_padre = (select ram_id_padre from rama where ram_id = p_ram_id);

   set TRANSACTION READ WRITE;

   if p_ram_id = 0 then RETURN; end if;

   select ram_orden into v_ram_orden from rama where ram_id = p_ram_id;

   if v_ram_orden = v_last then RETURN; end if;

   update rama
    set ram_orden = ram_orden - 1
   where ram_id_padre = (select ram_id_padre from rama where ram_id = p_ram_id)
    and ram_orden > v_ram_orden;

   update rama set ram_orden = v_last where ram_id = p_ram_id;

   rtn := 'rtn';

   open rtn for select * from rama where ram_id = p_ram_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_rama_move_bottom(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_rama_move_down()

-- drop function sp_arb_rama_move_down(int, int);

create or replace function sp_arb_rama_move_down(
  in p_us_id integer,
  in p_ram_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_last integer;
   v_ram_orden integer;
begin

   if not exists(select 1 from rama where ram_id = p_ram_id) then RETURN; end if;

   select max(ram_orden) into v_last from rama where ram_id_padre = (select ram_id_padre from rama where ram_id = p_ram_id);

   set TRANSACTION READ WRITE;

   if p_ram_id = 0 then RETURN; end if;

   select ram_orden into v_ram_orden from rama where ram_id = p_ram_id;

   if v_ram_orden = v_last then RETURN; end if;

   update rama
    set ram_orden = ram_orden - 1
   where ram_id_padre = (select ram_id_padre from rama where ram_id = p_ram_id)
    and ram_orden = v_ram_orden + 1;

   update rama set ram_orden = ram_orden +1 where ram_id = p_ram_id;

   rtn := 'rtn';

   open rtn for select * from rama where ram_id = p_ram_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_rama_move_down(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_rama_move_top()

-- drop function sp_arb_rama_move_top(int, int);

create or replace function sp_arb_rama_move_top(
  in p_us_id integer,
  in p_ram_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_ram_orden integer;
   v_first integer;
begin

   if not exists(select 1 from rama where ram_id = p_ram_id) then RETURN; end if;

   select min(ram_orden) into v_first from rama where ram_id_padre = (select ram_id_padre from rama where ram_id = p_ram_id);

   set TRANSACTION READ WRITE;

   if p_ram_id = 0 then RETURN; end if;

   select ram_orden into v_ram_orden from rama where ram_id = p_ram_id;

   if v_ram_orden = v_first then RETURN; end if;

   update rama
    set ram_orden = ram_orden + 1
   where ram_id_padre = (select ram_id_padre from rama where ram_id = p_ram_id)
    and ram_orden < v_ram_orden;

   update rama set ram_orden = v_first where ram_id = p_ram_id;

   rtn := 'rtn';

   open rtn for select * from rama where ram_id = p_ram_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_rama_move_top(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_rama_move_up()

-- drop function sp_arb_rama_move_up(int, int);

create or replace function sp_arb_rama_move_up(
  in p_us_id integer,
  in p_ram_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_ram_orden integer;
begin

   if not exists(select 1 from rama where ram_id = p_ram_id) then RETURN; end if;

   set TRANSACTION READ WRITE;

   if p_ram_id = 0 then RETURN; end if;

   select ram_orden into v_ram_orden from rama where ram_id = p_ram_id;

   if v_ram_orden = 0 then RETURN; end if;

   update rama
    set ram_orden = ram_orden + 1
   where ram_id_padre = (select ram_id_padre from rama where ram_id = p_ram_id)
    and ram_orden = v_ram_orden - 1;

   update rama set ram_orden = ram_orden -1 where ram_id = p_ram_id;

   rtn := 'rtn';

   open rtn for select * from rama where ram_id = p_ram_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_rama_move_up(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_rama_orden_validate()

-- drop function sp_arb_rama_orden_validate(int, int);

create or replace function sp_arb_rama_orden_validate(
  in p_us_id integer
)
  returns void as
$BODY$
declare
   v_orden integer;
   c1 refcursor;
   c2 refcursor;
   v_row record;
   v_row2 record;
begin

   set TRANSACTION READ WRITE;

   open c1 for select ram_id from rama where ram_id <> 0;
   loop
          fetch c1 into v_row;
          exit when not found;

          v_orden := 0;

          open c2 for select ram_id from rama where ram_id_padre = v_row.ram_id order by ram_orden;
          loop

                fetch c2 into v_row2;
                exit when not found;

                update rama set ram_orden = v_orden where ram_id = v_row2.ram_id;
                v_orden := v_orden +1;

          end loop;
          close c2;

   end loop;
   close c1;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_rama_orden_validate(integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbcopiarrama()

-- drop function sp_arbcopiarrama();

create or replace function sp_arbcopiarrama
(
  in p_us_id integer,
  in p_ram_id_copy_from integer,
  in p_ram_id_copy_to integer,
  in p_solo_los_hijos smallint,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_ram_id integer;
   v_new_ram_id integer;
   v_new_hoja_id integer;
   v_ram_id_padre integer;
   v_orden integer;
   v_arb_id integer;
   v_incluir_ram_id_to_copy integer;

   c_branches_to_copy refcursor;
   c_leaves_to_copy refcursor;
   v_branch_row record;
   v_leave_row record;
   v_tran_id integer;
begin

   if p_ram_id_copy_from = 0 then RETURN; end if;

   if p_ram_id_copy_to = 0 then RETURN; end if;

   if not exists(select 1 from rama where ram_id = p_ram_id_copy_from) then RETURN; end if;

   if not exists(select 1 from rama where ram_id = p_ram_id_copy_to) then RETURN; end if;

   --------------------------------------------------------------------

        create TEMP table t_rama_new
        (
          ram_id integer  not null,
          ram_id_new integer  not null,
          tran_id integer  not null
        ) on commit drop;

        v_tran_id := nextval('t_rama_new_seq');

   --------------------------------------------------------------------

   select arb_id into v_arb_id from rama where ram_id = p_ram_id_copy_to;

   if p_solo_los_hijos <> 0 then
      v_incluir_ram_id_to_copy := 0;

   else
      v_incluir_ram_id_to_copy := 1;

   end if;

   select into c_branches_to_copy t.rtn from SP_ArbGetDecendencia(p_ram_id_copy_from,v_incluir_ram_id_to_copy,0,0,0) t;

   loop
      fetch c_branches_to_copy into v_branch_row;
      exit when not found;
      
      begin

         v_ram_id := v_branch_row.ram_id;

         -- si esta es la rama principal de la copia, su padre tiene que ser la rama en la que estoy pegando
         if v_ram_id = p_ram_id_copy_from then
            v_ram_id_padre := p_ram_id_copy_to;
            select max(ram_orden) into v_orden from rama where ram_id_padre = v_ram_id_padre;
            v_orden := coalesce(v_orden + 1, 0); 

         else
         begin
            -- Obtengo el padre de la rama que estoy copiando
            select ram_id_padre into v_ram_id_padre from rama where ram_id = v_ram_id;

            -- Si pedi copiar solo los hijos y la rama que estoy copiando es hija directa, 
            -- entonces su padre es la rama en la que estoy pegando
            if p_solo_los_hijos <> 0 and v_ram_id_padre = p_ram_id_copy_from then
            begin
               v_ram_id_padre := p_ram_id_copy_to;
               select max(ram_orden) into v_orden from rama where ram_id_padre = v_ram_id_padre;
               v_orden := coalesce(v_orden + 1, 0); 

            end;
            else
            begin
               -- Obtengo el nuevo padre
               select ram_id_new into v_ram_id_padre
               from rama
               inner join t_rama_new
                    on rama.ram_id = t_rama_new.ram_id
                        and rama.ram_id = v_ram_id_padre
               where tran_id = v_tran_id;

               v_orden := null;
               
            end;
            end if;

         end;
         end if;

         select SP_DBGetNewId('rama',
                              'ram_id') into v_new_ram_id;

         insert into rama
           ( ram_id, ram_nombre, arb_id, modifico, ram_id_padre, ram_orden )
           ( select v_new_ram_id,
                    ram_nombre,
                    v_arb_id,
                    p_us_id,
                    v_ram_id_padre,
                    coalesce(v_orden, ram_orden)
             from rama
                where ram_id = v_ram_id );

         insert into t_rama_new ( ram_id, ram_id_new, tran_id ) values ( v_ram_id, v_new_ram_id, v_tran_id );

         -- Creo un cursor para recorrer cada una de las hojas e insertarlas
         open c_leaves_to_copy for select hoja_id from Hoja where ram_id = v_ram_id;

         loop
            fetch c_leaves_to_copy into v_leave_row;
            exit when not found;
            begin
               -- Por cada hoja obtengo un id nuevo
               select SP_DBGetNewId('hoja',
                                    'hoja_id') into v_new_hoja_id;

               insert into hoja
                 ( hoja_id, id, modifico, ram_id, arb_id )
                 ( select v_new_hoja_id,
                          id,
                          modifico,
                          v_new_ram_id,
                          v_arb_id
                   from Hoja
                      where hoja_id = v_leave_row.hoja_id );

            end;
         end loop;

         close c_leaves_to_copy;

      end;
   end loop;

   close c_branches_to_copy;

   rtn := 'rtn';

   open rtn for select * from rama where ram_id = p_ram_id_copy_to;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbcopiarrama(integer, integer, integer, smallint)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arbcortarrama()

-- drop function sp_arbcortarrama();

create or replace function sp_arbcortarrama
(
  in p_us_id integer,
  in p_ram_id_cut_from integer,
  in p_ram_id_to_paste_in integer,
  in p_solo_los_hijos smallint,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_arb_id integer;
   v_incluir_ram_id_to_copy integer;
   v_orden integer;

   c_branches_to_copy refcursor;
   v_branch_row record;
begin

   if p_ram_id_cut_from = 0 then RETURN; end if;

   if p_ram_id_to_paste_in = 0 then RETURN; end if;

   if not exists(select 1 from rama where ram_id = p_ram_id_cut_from) then RETURN; end if;

   if not exists(select 1 from rama where ram_id = p_ram_id_to_paste_in) then RETURN; end if;

   select arb_id into v_arb_id from rama where ram_id = p_ram_id_to_paste_in;

   if p_solo_los_hijos <> 0 then
      v_incluir_ram_id_to_copy := 0;

      select max(orden) into v_orden from rama where ram_id_padre = p_ram_id_to_paste_in;

      v_orden := coalesce(v_orden+1,0);

      update rama
                  set ram_id_padre = p_ram_id_to_paste_in, modifico = p_us_id, ram_orden = ram_orden + v_orden
                  where ram_id_padre = p_ram_id_cut_from;

   else
      v_incluir_ram_id_to_copy := 1;

      update rama
                  set ram_id_padre = p_ram_id_to_paste_in, modifico = p_us_id, ram_orden = ram_orden + v_orden
                  where ram_id = p_ram_id_cut_from;

   end if;

   if exists(select 1 from rama where ram_id = p_ram_id_cut_from and arb_id <> v_arb_id) then

       select into c_branches_to_copy t.rtn from SP_ArbGetDecendencia(p_ram_id_cut_from,v_incluir_ram_id_to_copy,0,0,0) t;

       loop
          fetch c_branches_to_copy into v_branch_row;
          exit when not found;

          update rama set arb_id = v_arb_id, modifico = p_us_id where rama.ram_id = v_branch_row.ram_id;
          update hoja set arb_id = v_arb_id, modifico = p_us_id where hoja.ram_id = v_branch_row.ram_id;

       end loop;

       close c_branches_to_copy;

   end if;

   rtn := 'rtn';

   open rtn for select * from rama where ram_id = p_ram_id_to_paste_in;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arbcortarrama(integer, integer, integer, smallint)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_arb_rama_rename()

-- drop function sp_arb_rama_rename();

create or replace function sp_arb_rama_rename(
  in p_us_id integer,
  in p_ram_id integer,
  in p_nombre varchar,
  out rtn refcursor
)
  returns refcursor as
$BODY$
begin

        update rama set ram_nombre = p_nombre where ram_id = p_ram_id;


        if exists(select 1 from rama where ram_id = p_ram_id and ram_id_padre = 0)
        then

            update arbol set arb_nombre = p_nombre
            where arb_id = (select arb_id from rama where ram_id = p_ram_id);

        end if;

        rtn := 'rtn';

        open rtn for select * from rama where ram_id = p_ram_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_arb_rama_rename(integer, integer, varchar)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cfg_getvalor(character varying, character varying, smallint, integer)

-- drop function sp_cfg_getvalor(character varying, character varying, smallint, integer);

create or replace function sp_cfg_getvalor
(
    in p_cfg_grupo character varying,
    in p_cfg_aspecto character varying,
    in p_bshow smallint default 0,
    in p_emp_id integer default null,
    out p_cfg_valor character varying
)
  returns character varying as
$BODY$
begin

   if p_bShow <> 0 then
    raise exception '@@ERROR_SP:El procedimiento almacenado sp_cfg_getvalor no puede ser llamado para obtener un cursor. Se debe usar sp_cfg_getvalorRs.';
		RETURN;
   end if;

   select cfg_valor
     into p_cfg_valor
     from Configuracion
      where cfg_grupo = p_cfg_grupo
              and cfg_aspecto = p_cfg_aspecto
              and ( emp_id = p_emp_id
              or ( emp_id is null
              and p_emp_id is null ) );
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cfg_getvalor(character varying, character varying, smallint, integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cfg_getvalorrs(character varying, character varying, smallint, integer)

-- drop function sp_cfg_getvalorrs(character varying, character varying, smallint, integer);

create or replace function sp_cfg_getvalorrs(in p_cfg_grupo character varying, in p_cfg_aspecto character varying, out p_cfg_valor character varying, in p_bshow smallint, in p_emp_id integer, out rtn refcursor)
  returns record as
$BODY$
begin

   select cfg_valor
     into p_cfg_valor
     from Configuracion
      where cfg_grupo = p_cfg_grupo
              and cfg_aspecto = p_cfg_aspecto
              and ( emp_id = p_emp_id
              or ( emp_id is null
              and p_emp_id is null ) );

   if p_bShow <> 0 then
      open rtn for
         select p_cfg_valor
           from DUAL ;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cfg_getvalorrs(character varying, character varying, smallint, integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_cols()

-- drop function sp_cols();

create or replace function sp_cols(in tableName varchar, refcursor)
  returns refcursor as
$BODY$
declare
v_leng_id integer;
begin
        open $2 for
        select *
        from information_schema.columns
        where table_name = lower(tableName);

        RETURN $2;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_cols(varchar, refcursor)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_dbgetnewid(character varying, character varying, smallint)

-- drop function sp_dbgetnewid(character varying, character varying, smallint);

-- select * from sp_dbgetnewid('asiento','as_id');

create or replace function sp_dbgetnewid
(
 in p_tabla character varying,
 in p_pk character varying,
 out p_id integer
)
  returns integer as
$BODY$
declare
  v_sqlstmt varchar(255);
begin

   if lower(p_tabla) = 'stock' or lower(p_tabla) = 'stockitem' then

      select max(id_nextId)
        into p_id
      from IdStock
      where id_tabla = p_tabla
        and id_campoId = p_pk
        and id_rango = 0;

      -- si no existe en la tabla
      if p_id is null then

         v_sqlstmt := 'insert into IdStock (id_tabla, id_nextId, id_campoId) select ''' || p_tabla
                      || ''',coalesce(max(' || p_pk || '),0)+1, ''' || p_pk
                      || ''' from ' || p_tabla
                      || ' where isnumeric(' || p_pk || ')<>0';

         execute v_sqlstmt;

         select max(id_nextId)
           into p_id
         from IdStock
         where id_tabla = p_tabla
           and id_campoId = p_pk;

      end if;

      update idStock
         set id_nextId = p_id + 1
      where id_tabla = p_tabla
        and id_campoId = p_pk;

   else

      if lower(p_tabla) = 'asiento' or lower(p_tabla) = 'asientoitem' then

         select max(id_nextId)
           into p_id
         from IdAsiento
         where id_tabla = p_tabla
           and id_campoId = p_pk
           and id_rango = 0;

         -- si no existe en la tabla
         if p_id is null then

            v_sqlstmt := 'insert into IdAsiento (id_tabla, id_nextId, id_campoId) select ''' || p_tabla
                         || ''',coalesce(max(' || p_pk || '),0)+1, ''' || p_pk
                         || ''' from ' || p_tabla
                         || ' where isnumeric(' || p_pk || ')<>0';

            execute v_sqlstmt;

            select max(id_nextId)
              into p_id
            from IdAsiento
            where id_tabla = p_tabla
              and id_campoId = p_pk;

         end if;

         update idAsiento
            set id_nextId = p_id + 1
         where id_tabla = p_tabla
           and id_campoId = p_pk;

      else

         select max(id_nextId)
           into p_id
         from Id
         where id_tabla = p_tabla
           and id_campoId = p_pk
           and id_rango = 0;

         -- si no existe en la tabla
         if p_id is null then

            v_sqlstmt := 'insert into Id (id_tabla, id_nextId, id_campoId) select ''' || p_tabla
                         || ''',coalesce(max(' || p_pk || '),0)+1, ''' || p_pk
                         || ''' from ' || p_tabla
                         || ' where isnumeric(' || p_pk || ')<>0';

            execute v_sqlstmt;

            select max(id_nextId)
              into p_id
            from Id
            where id_tabla = p_tabla
              and id_campoId = p_pk;

         end if;

         update id
            set id_nextId = p_id + 1
         where id_tabla = p_tabla
           and id_campoId = p_pk;

      end if;

   end if;
   
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_dbgetnewid(character varying, character varying)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_dbgetnewid2

-- drop function sp_dbgetnewid2(character varying, character varying, integer, integer);

-- select * from sp_dbgetnewid2('alarma','al_id', 1000000, 10000000);

create or replace function sp_dbgetnewid2
(
  in p_tabla character varying, 
  in p_pk character varying, 
  in p_min integer, 
  in p_max integer, 
  out p_id integer
)
  returns integer as
$BODY$
declare
  v_sqlstmt varchar(5000);
begin

   select max(id_nextId)
     into p_id
   from id
   where id_tabla = p_tabla
     and id_campoId = p_pk
     and id_rango = p_min;

   -- si no existe en la tabla
   if coalesce(p_id, 0) = 0 then
      v_sqlstmt := 'insert into id (id_tabla, id_nextId, id_campoId, id_rango) select '''
                    || p_tabla || 
                    ''',coalesce(max(to_number(' || p_pk || ')),0)+1, ''' 
                    || p_pk || ''',' 
                    || to_char(p_min) || 
                    ' from ' || p_tabla ||
                    ' where isnumeric(' || p_pk || ')<>0 and (to_number(' || p_pk || ') >= '
                    || to_char(p_min) 
                    || ' and ' || ' to_number(' || p_pk || ') <= ' || to_char(p_max) || ')';

      execute v_sqlstmt;

      select max(id_nextId)
        into p_id
      from id
      where id_tabla = p_tabla
        and id_campoId = p_pk
        and id_rango = p_min;

   end if;

   p_id := coalesce(p_id, 0);

   if p_id = 0 then
      p_id := p_min;
   end if;

   if p_id < p_min then
      p_id := p_min;
   end if;

   if p_id > p_max then
      p_id := p_max;
   end if;

   update id
      set id_nextId = p_id + 1
   where id_tabla = p_tabla
     and id_campoId = p_pk
     and id_rango = p_min;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_dbgetnewid2(character varying, character varying, integer, integer)
  owner to postgres;
  /*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_getrptid()

-- drop function sp_getrptid();

create or replace function sp_getrptid(out p_clienteid integer)
  returns integer as
$BODY$
declare
begin

   select id_NextId
     into p_ClienteID
     from Id
      where Id_Tabla = 'rptArbolRamaHoja'
              and id_CampoId = 'rptarb_cliente';

   if coalesce(p_ClienteID, 0) = 0 then
   begin
      insert into id
        ( id_NextId, id_Tabla, id_CampoId )
        values ( 0, 'rptArbolRamaHoja', 'rptarb_cliente' );

      p_ClienteID := 1;

   end;
   end if;

   update id
      set id_NextId = p_ClienteID + 1
      where Id_Tabla = 'rptArbolRamaHoja'
     and id_CampoId = 'rptarb_cliente';

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_getrptid()
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_helpgetfilter()

-- drop function sp_helpgetfilter();

create or replace function sp_helpgetfilter(
  in p_bFilterType integer,
  in p_filter varchar)
  returns varchar as
$BODY$
declare
   
begin

  --/////////////////////////////////////////////////////////////////////////////////////
  /*
  Public Const c_HelpFilterBeginLike = 1
  Public Const c_HelpFilterHaveTo = 2
  Public Const c_HelpFilterWildcard = 3
  Public Const c_HelpFilterEndLike = 4
  Public Const c_HelpFilterIsLike = 5
  */
  return case p_bFilterType
                 when 1 then p_filter || '%'
                 when 3 then REPLACE(p_filter, '*', '%')
                 when 4 then '%' || p_filter
                 when 5 then p_filter
                 -- Default
                 -- case 2 then '%' + @@filter + '%'
                 else '%' || p_filter || '%'
         end;
   --/////////////////////////////////////////////////////////////////////////////////////
           
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_helpgetfilter(integer, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_historia_update()

-- drop function sp_historia_update(integer, integer, integer, integer, varchar);

create or replace function sp_historia_update
(
  in p_tbl_id integer,
  in p_id integer,
  in p_modifico integer,
  in p_hst_operacion integer,
  in p_hst_descrip varchar default ''
)
  returns void as
$BODY$
begin

   if not exists ( select *
                   from Usuario
                   where us_id = p_modifico ) then
      return;

   end if;

   insert into Historia( tbl_id, id, modifico, hst_operacion, hst_descrip )
     values ( p_tbl_id, coalesce(p_id, 0), p_modifico, p_hst_operacion, coalesce(p_hst_descrip, '') );

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_historia_update(integer, integer, integer, integer, varchar)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_leng_get_text()

-- drop function sp_leng_get_text();

create or replace function sp_leng_get_text
(
  in p_code varchar,
  in p_us_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_leng_id integer;
   v_rtn varchar(5000);
begin

   v_rtn := '';

   select cfg_valor::integer
     into v_leng_id
     from Configuracion
      where cfg_grupo = 'Usuario-Config'
        and cfg_aspecto = 'Lenguaje Gral_' || p_us_id::varchar;

   if coalesce(v_leng_id, 0) = 0 then
   begin
      select cfg_valor::integer
        into v_leng_id
        from Configuracion
         where cfg_grupo = 'general'
           and cfg_aspecto = 'lenguaje';

   end;
   end if;

   if coalesce(v_leng_id, 0) = 0 then
      v_leng_id := 1;-- CrowSoft default language (Castellano)
   end if;

   if coalesce(v_leng_id, 0) <> 0 then
   begin

      select lengi_texto
        into v_rtn
        from LenguajeItem
         where leng_id = v_leng_id
           and lengi_codigo = p_code;

      -- Si no lo encuentro veo si el lenguaje tiene un lenguaje padre
      if coalesce(v_rtn, '') = '' then
      begin
         -- Busco el lenguaje tiene un lenguaje padre
         select leng_id_padre
           into v_leng_id
           from Lenguaje
            where leng_id = v_leng_id;

         -- Si hay un lenguaje padre le pido que me traiga el texto
         if coalesce(v_leng_id, 0) <> 0 then
         begin
            v_rtn := sp_leng_get_text_aux(p_code, v_leng_id);

         end;
         end if;

      end;
      end if;

   end;
   end if;

   rtn := 'rtn';

   open rtn for select v_rtn;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_leng_get_text(varchar, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_leng_get_text_aux()

-- drop function sp_leng_get_text_aux();

create or replace function sp_leng_get_text_aux
(
  in p_code varchar default null,
  in p_leng_id integer default null
) returns varchar as
$BODY$
declare
   v_leng_id integer;
   v_rtn varchar(5000);
begin

   v_leng_id := p_leng_id;

   select lengi_texto
     into v_rtn
     from LenguajeItem
      where leng_id = v_leng_id
              and lengi_codigo = p_code;

   -- if this language doesn't contain a definition for this code
   -- and the language is not the main language ( Spanish )
   -- we use the parent language
   --
   if coalesce(v_rtn, '') = '' and v_leng_id <> 1 then

      select leng_id_padre
        into v_leng_id
        from Lenguaje
         where leng_id = v_leng_id;

      -- if the language doesn't have a parent
      -- we use 1 which is ( Spanish )
      --
      v_leng_id := coalesce(v_leng_id, 1);

      v_rtn := sp_leng_get_text_aux(p_code, v_leng_id);

   end if;

   return v_rtn;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_leng_get_text_aux(varchar, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_strgetrealname()

-- drop function sp_strgetrealname();

create or replace function sp_strgetrealname
(
  in p_prefix varchar,
  in p_campo varchar
)
returns varchar as
$BODY$
declare
   v_j integer;
begin

   v_j := coalesce(strpos(p_campo, '='), 0);

   if v_j = 0 then
      p_campo := p_prefix || '.' || p_campo;

   else
      p_campo := SUBSTR(p_campo, 1, v_j) || p_prefix || '.' || LTRIM(SUBSTR(p_campo, v_j + 1, LENGTH(p_campo)));

   end if;

   return p_campo;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_strgetrealname(varchar, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_strreplaceequalswithas()

-- drop function sp_strreplaceequalswithas();

create or replace function sp_strreplaceequalswithas(p_campos character varying)
  returns character varying as
$BODY$
declare
   v_retval varchar(5000);
   v_campo varchar(5000);
   v_caracter varchar(1);
   v_i integer;
   v_j integer;
   v_z integer;
   v_q integer;
   v_r integer;
   v_t integer;
   v_p integer;
   v_n integer;
   v_work_done boolean;
begin

   v_i := 1;

   v_j := 0;

   v_p := 0;

   v_z := 0;

   v_retval := '';

   v_work_done := false;

   -- si no hay campos tampoco
   if p_campos is null
     or p_campos is null then
      RETURN '';

   end if;

   --------------------------------------------
   v_j := coalesce(INSTR(p_campos, ',', v_j + 1), 0);

   v_z := coalesce(INSTR(p_campos, '(', v_z + 1), 0);

   --------------------------------------------
   if v_j = 0 then
   begin
      if v_i < v_z then
      begin
         v_retval := LTRIM(p_campos);

         v_i := INSTR(v_retval, '=', 1);

         if v_i < v_z and v_i <> 0 then
         begin
                v_retval := SUBSTR(v_retval, v_i +1) || ' as ' || REPLACE(SUBSTR(v_retval, 1, v_i -1),'''', '"');
         end;
         end if;

      end;
      else
         v_i := INSTR(v_retval, '=', 1);

         if v_i <> 0 then
         begin
                v_retval := SUBSTR(v_retval, v_i +1) || ' as ' || REPLACE(SUBSTR(v_retval, 1, v_i -1),'''', '"');
         
         end;
         end if;

      end if;

   end;
   else
   begin
      while v_j <> 0
      loop
         begin
            -- si hay un parentesis es por que hay un subselect, en cuyo caso no toco nada que este en
            -- el parentesis
            if v_i < v_z
              and v_z < v_j then
            begin
               --leeo caracter por caracter hasta encontrar el cierre del parentesis
               v_r := LENGTH(p_campos) + 1;

               v_t := v_z;

               while v_t < v_r
               loop
                  begin
                     v_caracter := SUBSTR(p_campos, v_t, 1);

                     -- si encuentro un parentesis abierto, incremento un contador para buscar uno cerrado
                     if v_caracter = '(' then
                        v_p := v_p + 1;

                     end if;

                     if v_caracter = ')' then
                     begin
                        v_p := v_p - 1;
                     
                        -- si encontre el cierre del primer parentesis termine con este campo
                        if v_p = 0 then
                           exit;
                           
                        end if;

                     end;
                     end if;

                     v_t := v_t + 1;

                  end;
               end loop;

               -- ahora busco una coma a partir del ultimo parentesis
               v_j := INSTR(p_campos, ',', v_t);

               -- si la encuentro agrego el campo tal como esta a la sentencia
               if v_j > 0 then
               begin
                  v_campo := LTRIM(SUBSTR(p_campos, v_i, v_j - v_i));

                  v_n := INSTR(v_campo, '=', 1);

                  if v_n < v_z and v_n <> 0 then
                  begin
                        v_campo := SUBSTR(v_campo, v_n +1) || ' as ' || REPLACE(SUBSTR(v_campo, 1, v_n -1),'''', '"') || ',';
                  end;
                  end if;
         
                  v_retval := v_retval || v_campo;

                  -- me preparo para buscar la proxima coma
                  v_i := v_j + 1;

                  v_j := INSTR(p_campos, ',', v_j + 1);

                  v_z := INSTR(p_campos, '(', v_i + 1);

               end;
               -- si no encuentro la coma es porque se terminaron los campos, asi que
               -- agrego el campo a la sentencia y termine
               else
               begin
                  v_campo := LTRIM(SUBSTR(p_campos, v_i, LENGTH(p_campos)));

                  v_n := INSTR(v_campo, '=', 1);

                  if v_n < v_z and v_n <> 0 then
                  begin
                        v_campo := SUBSTR(v_campo, v_n +1) || ' as ' || REPLACE(SUBSTR(v_campo, 1, v_n -1),'''', '"');
                  end;
                  end if;

                  v_retval := v_retval || v_campo;

                  -- con esto voy al final
                  v_work_done:= true;
                  exit;

               end;
               end if;

            end;
            else
            begin
               v_campo := LTRIM(SUBSTR(p_campos, v_i, v_j - v_i));

               v_n := INSTR(v_campo, '=', 1);

               if v_n <> 0 then
               begin
                   v_campo := SUBSTR(v_campo, v_n +1) || ' as ' || REPLACE(SUBSTR(v_campo, 1, v_n -1),'''', '"');
               end;
               end if;

               v_retval := v_retval || v_campo || ',';

               v_i := v_j + 1;

               v_j := INSTR(p_campos, ',', v_j + 1);

               -- busco el proximo parentesis
               v_z := INSTR(p_campos, '(', v_i + 1);

            end;
            end if;

         end;
      end loop;
      if not v_work_done then
        begin
              if v_i < v_z then
              begin
                 --leeo caracter por caracter hasta encontrar el cierre del parentesis
                 v_r := LENGTH(p_campos) + 1;

                 v_t := v_z;

                 while v_t < v_r
                 loop
                    begin
                       v_caracter := SUBSTR(p_campos, v_t, 1);

                       -- si encuentro un parentesis abierto, incremento un contador para buscar uno cerrado
                       if v_caracter = '(' then
                          v_p := v_p + 1;

                       end if;

                       if v_caracter = ')' then
                       begin
                          v_p := v_p - 1;
                          
                          -- si encontre el cierre del primer parentesis termine con este campo
                          if v_p = 0 then
                             exit;

                          end if;

                       end;
                       end if;

                       v_t := v_t + 1;

                    end;
                 end loop;

                 v_campo := LTRIM(SUBSTR(p_campos, v_i, LENGTH(p_campos)));

                 v_n := INSTR(v_campo, '=', 1);

                 if v_n < v_z and v_n <> 0 then
                 begin
                        v_campo := SUBSTR(v_campo, v_n +1) || ' as ' || REPLACE(SUBSTR(v_campo, 1, v_n -1),'''', '"');
                 end;
                 end if;

                 v_retval := v_retval || v_campo;

              end;
              else
              begin
                 v_campo := LTRIM(SUBSTR(p_campos, v_i, LENGTH(p_campos)));

                 v_n := INSTR(v_campo, '=', 1);

                 if v_n <> 0 then
                 begin
                        v_campo := SUBSTR(v_campo, v_n +1) || ' as ' || REPLACE(SUBSTR(v_campo, 1, v_n -1),'''', '"');
                 end;
                 end if;

                 v_retval := v_retval || v_campo;

              end;
              end if;
        end;
      end if;
   end;
   end if;

   return v_retval;
   
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_strreplaceequalswithas(character varying)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_strSetPrefix()

-- drop function sp_strSetPrefix();

create or replace function sp_strsetprefix
(
  in p_prefix varchar,
  in p_campos varchar
)
returns varchar as
$BODY$
declare
   v_retval varchar(5000);
   v_campo varchar(5000);
   v_caracter varchar(1);
   v_i integer;
   v_j integer;
   v_z integer;
   v_q integer;
   v_r integer;
   v_t integer;
   v_p integer;
   v_work_done boolean;
begin

   v_i := 1;

   v_j := 0;

   v_p := 0;

   v_z := 0;

   v_retval := '';

   v_work_done := false;

   --------------------------------------------
   -- si no hay prefijo no toco los campos
   if p_prefix is null
     or p_prefix is null then
      RETURN '';

   end if;

   -- si no hay campos tampoco
   if p_campos is null
     or p_campos is null then
      RETURN '';

   end if;

   --------------------------------------------
   v_j := coalesce(INSTR(p_campos, ',', v_j + 1), 0);

   v_z := coalesce(INSTR(p_campos, '(', v_z + 1), 0);

   --------------------------------------------
   if v_j = 0 then
   begin
      if v_i < v_z then
      begin
         v_campo := LTRIM(p_campos);

         v_retval := v_retval || v_campo;

      end;
      else
         v_retval := sp_strGetRealName(p_prefix, p_campos);

      end if;

   end;
   else
   begin
      while v_j <> 0
      loop
         begin
            -- si hay un parentesis es por que hay un subselect, en cuyo caso no toco nada que este en
            -- el parentesis
            if v_i < v_z
              and v_z < v_j then
            begin
               --leeo caracter por caracter hasta encontrar el cierre del parentesis
               v_r := LENGTH(p_campos) + 1;

               v_t := v_z;

               while v_t < v_r
               loop
                  begin
                     v_caracter := SUBSTR(p_campos, v_t, 1);

                     -- si encuentro un parentesis abierto, incremento un contador para buscar uno cerrado
                     if v_caracter = '(' then
                        v_p := v_p + 1;

                     end if;

                     if v_caracter = ')' then
                     begin
                        v_p := v_p - 1;
                        
                        -- si encontre el cierre del primer parentesis termine con este campo
                        if v_p = 0 then
                           exit;

                        end if;

                     end;
                     end if;

                     v_t := v_t + 1;

                  end;
               end loop;

               -- ahora busco una coma a partir del ultimo parentesis
               v_j := INSTR(p_campos, ',', v_t);

               -- si la encuentro agrego el campo tal como esta a la sentencia
               if v_j > 0 then
               begin
                  v_campo := LTRIM(SUBSTR(p_campos, v_i, v_j - v_i + 1));

                  v_retval := v_retval || v_campo;

                  -- me preparo para buscar la proxima coma
                  v_i := v_j + 1;

                  v_j := INSTR(p_campos, ',', v_j + 1);

                  v_z := INSTR(p_campos, '(', v_i + 1);

               end;
               -- si no encuentro la coma es porque se terminaron los campos, asi que
               -- agrego el campo a la sentencia y termine
               else
               begin
                  v_campo := LTRIM(SUBSTR(p_campos, v_i, LENGTH(p_campos)));

                  v_retval := v_retval || v_campo;

                  -- con esto voy al final
                  v_work_done:= true;
                  exit;

               end;
               end if;

            end;
            else
            begin
               v_campo := LTRIM(SUBSTR(p_campos, v_i, v_j - v_i + 1));

               v_campo:= sp_strGetRealName(p_prefix, v_campo);

               v_retval := v_retval || v_campo;

               v_i := v_j + 1;

               v_j := INSTR(p_campos, ',', v_j + 1);

               -- busco el proximo parentesis
               v_z := INSTR(p_campos, '(', v_i + 1);

            end;
            end if;

         end;
      end loop;
      if not v_work_done then
        begin
              if v_i < v_z then
              begin
                 --leeo caracter por caracter hasta encontrar el cierre del parentesis
                 v_r := LENGTH(p_campos) + 1;

                 v_t := v_z;

                 while v_t < v_r
                 loop
                    begin
                       v_caracter := SUBSTR(p_campos, v_t, 1);

                       -- si encuentro un parentesis abierto, incremento un contador para buscar uno cerrado
                       if v_caracter = '(' then
                          v_p := v_p + 1;

                       end if;

                       if v_caracter = ')' then
                       begin
                          v_p := v_p - 1;
                          
                          -- si encontre el cierre del primer parentesis termine con este campo
                          if v_p = 0 then
                             exit;

                          end if;

                       end;
                       end if;

                       v_t := v_t + 1;

                    end;
                 end loop;

                 v_campo := LTRIM(SUBSTR(p_campos, v_i, LENGTH(p_campos)));

                 v_retval := v_retval || v_campo;

              end;
              else
              begin
                 v_campo := LTRIM(SUBSTR(p_campos, v_i, LENGTH(p_campos)));

                 v_campo:= sp_strGetRealName(p_prefix, v_campo);

                 v_retval := v_retval || v_campo;

              end;
              end if;
        end;
      end if;
   end;
   end if;

   --------------------------------------------
   RETURN sp_strReplaceEqualsWithAs(v_retval);

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_strsetprefix(varchar, varchar)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_sys_language_get()

-- drop function sp_sys_language_get();

create or replace function sp_sys_language_get
(
  in p_us_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_leng_id integer;
begin

   select cfg_valor::integer
     into v_leng_id
     from Configuracion
      where cfg_grupo = 'Usuario-Config'
        and cfg_aspecto = 'Lenguaje Gral_' || p_us_id::varchar;

   if coalesce(v_leng_id, 0) = 0 then
   begin
      select cfg_valor::integer
        into v_leng_id
        from Configuracion
         where cfg_grupo = 'general'
           and cfg_aspecto = 'lenguaje';

   end;
   end if;

   if coalesce(v_leng_id, 0) = 0 then
      v_leng_id := 1;-- CrowSoft default language (Castellano)
   end if;

   rtn := 'rtn';

   open rtn for select sysl_code, sysl_text from sysLanguage where leng_id = v_leng_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_sys_language_get(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_sys_language_update()

-- drop function sp_sys_language_update();

create or replace function sp_sys_language_update()
  returns void as
$BODY$
declare
   cur refcursor;
   v_row record;
begin

   set TRANSACTION READ WRITE;

   delete from sysLanguage;

   open cur for select leng_id from lenguaje;
   loop
          fetch cur into v_row;
          exit when not found;

          perform sp_sys_language_update(v_row.leng_id);
          
   end loop;
   close cur;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_sys_language_update()
  owner to postgres;


-- Function: sp_sys_language_update(int)

-- drop function sp_sys_language_update(int);

create or replace function sp_sys_language_update(in p_leng_id integer)
  returns void as
$BODY$
declare
   cur refcursor;
   v_row record;
   v_text varchar(5000);
begin

   set TRANSACTION READ WRITE;

   open cur for select distinct(lengi_codigo) from lenguajeItem;
   loop
          fetch cur into v_row;
          exit when not found;

          v_text := sp_leng_get_text_aux(v_row.lengi_codigo, p_leng_id);

          if v_text <> '' then

            insert into sysLanguage (leng_id, sysl_code, sysl_text) values(p_leng_id, v_row.lengi_codigo, v_text);
          else
            raise notice 'CODE not found: %', v_row.lengi_codigo;
          end if;

   end loop;
   close cur;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_sys_language_update()
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_sys_menu_get()

-- drop function sp_sys_menu_get();

create or replace function sp_sys_menu_get(in p_us_id integer, in p_emp_id integer, out rtn refcursor)
  returns refcursor as
$BODY$
declare
v_leng_id integer;
begin
        select cfg_valor::int into v_leng_id
        from configuracion
        where cfg_grupo = 'Usuario-Config'
        and cfg_aspecto = 'Lenguaje Gral_' || p_us_id::varchar
        and emp_id = p_emp_id;

        v_leng_id := coalesce(v_leng_id, 1);                            

        rtn := 'rtn';
        
        open rtn for
        select

                        s.sysm_id,
                        s.sysm_orden,
                        s.sysm_objetoinicializacion,
                        s.sysm_objetoedicion,
                        m.me_path,
                        m.me_path2, 
                        replace(s.sysm_objetoedicion,'.','/') as handler,
                        s.pre_id,
                        m.me_action,
                        m.me_action2,
                        m.me_id,
                        m.me_text,
                        m.me_key,
                        m.me_father,
                        m.me_position,
                        m.me_is_last,
                        m.me_is_separator,
                        m.me_have_separator,
                        m.me_is_main_menu,
                        m.me_is_popup_menu,
                        m.me_object_handler,
                        m.me_package,
                        m.me_file_path,
                        l.lengi_texto as text,
                        coalesce(lfather1.lengi_texto,'') as father1,
                        coalesce(lfather2.lengi_texto,'') as father2,
                        coalesce(lfather3.lengi_texto,'') as father3,
                        coalesce(lfather4.lengi_texto,'') as father4,
                        coalesce(lfather5.lengi_texto,'') as father5,

                        father1.me_id as father1_id,
                        father2.me_id as father2_id,
                        father3.me_id as father3_id,
                        father4.me_id as father4_id,
                        father5.me_id as father5_id

                        /*
                        ,'mkdir ' || substring(s.sysm_objetoedicion from 1 for position('.' in s.sysm_objetoedicion)-1) as make_dir
                        ,'touch ' || replace(s.sysm_objetoedicion,'.','/') || '.js' as js_file
                        */
                        
 	from sysModulo s 
                inner join sysModuloUser u on s.sysm_id = u.sysm_id and u.us_id = p_us_id
                inner join sysMenu m on s.pre_id = m.pre_id
                left join lenguajeItem l on l.lengi_codigo = m.me_text and l.leng_id = v_leng_id

                left join sysMenu father1 on m.me_id_father = father1.me_id
                left join sysMenu father2 on father1.me_id_father = father2.me_id
                left join sysMenu father3 on father2.me_id_father = father3.me_id
                left join sysMenu father4 on father3.me_id_father = father4.me_id
                left join sysMenu father5 on father4.me_id_father = father5.me_id
                
                left join lenguajeItem lfather1 on father1.me_text = lfather1.lengi_codigo and lfather1.leng_id = v_leng_id
                left join lenguajeItem lfather2 on father2.me_text = lfather2.lengi_codigo and lfather2.leng_id = v_leng_id
                left join lenguajeItem lfather3 on father3.me_text = lfather3.lengi_codigo and lfather3.leng_id = v_leng_id
                left join lenguajeItem lfather4 on father4.me_text = lfather4.lengi_codigo and lfather4.leng_id = v_leng_id
                left join lenguajeItem lfather5 on father5.me_text = lfather5.lengi_codigo and lfather5.leng_id = v_leng_id

	order by 
	coalesce(replace(lfather5.lengi_texto, '&',''),'zzz'), 
	coalesce(replace(lfather4.lengi_texto, '&',''),'zzz'), 
	coalesce(replace(lfather3.lengi_texto, '&',''),'zzz'), 
	coalesce(replace(lfather2.lengi_texto, '&',''),'zzz'), 
	coalesce(replace(lfather1.lengi_texto, '&',''),'zzz'), 
	coalesce(replace(l.lengi_texto, '&',''),'zzz') desc;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_sys_menu_get(integer, integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_sys_module_get()

-- drop function sp_sys_module_get();

create or replace function sp_sys_module_get(in p_us_id integer, out rtn refcursor)
  returns refcursor as
$BODY$
declare
begin
        rtn := 'rtn';
        
        open rtn for
        select distinct

			s.sysm_id,
			s.sysm_orden,
			s.sysm_objetoinicializacion,
			s.sysm_objetoedicion,
			s.pre_id

 	from sysModulo s inner join sysModuloUser u on s.sysm_id = u.sysm_id and u.us_id = p_us_id

	order by s.sysm_orden;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_sys_module_get(integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: to_char(integer)

-- drop function to_char(integer);

create or replace function to_char(param integer)
  returns varchar as
$BODY$
begin
	return to_char(param,'9999999999999');
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function to_char(integer)
  owner to postgres;
/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: to_number(integer)

-- drop function to_number(integer);

create or replace function to_number(param integer)
  returns integer as
$BODY$
begin
	return param;
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function to_number(integer)
  owner to postgres;
  /*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: to_number(character varying)

-- drop function to_number(character varying);

create or replace function to_number(param character varying)
  returns integer as
$BODY$
begin
	return to_number(param, '999999999');
end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function to_number(character varying)
  owner to postgres;

/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_stock_update_numero_serie()

-- drop function sp_doc_stock_update_numero_serie(integer, integer);

create or replace function sp_doc_stock_update_numero_serie
(
  in p_st_id integer,
  in p_restar integer
)
  returns void as
$BODY$  
declare
   v_prns_id integer;
   v_depl_id integer;
   v_doct_id_cliente integer;
   v_id_cliente integer;

   v_modificado date;
   v_creado date;

   v_st_id_prns integer;
   v_depl_id_prns integer;
   v_doct_id_cliente_prns integer;
   v_id_cliente_prns integer;
begin

   -- cargamos el deposito destino
   -- desde el movimiento de stock
   -- ya que el 99% de las veces
   -- es un insert
   --
   select doct_id_cliente,
          id_cliente,
          modificado,
          creado,
          depl_id_destino
     into v_doct_id_cliente,
          v_id_cliente,
          v_modificado,
          v_creado,
          v_depl_id
   from Stock
   where st_id = p_st_id;

   /*-------------------------------------------------------------------
     insert
   ---------------------------------------------------------------------*/

   -- solo puedo usarlo si no estoy borrando o anulando
   --
   if v_modificado = v_creado and p_restar = 0 then

      -- actualizamos el deposito siempre y el cliente, el proveedor
      -- y el documento de salida y de ingreso solo si corresponde
      --
      perform sp_doc_stock_update_numero_serie2(
                                        p_st_id,
                                        v_doct_id_cliente,
                                        v_id_cliente,
                                        null,
                                        null,
                                        v_depl_id);

   /*-------------------------------------------------------------------
     update
   ---------------------------------------------------------------------*/

   else

      -- si estoy anulando o borrando
      --
      if p_restar <> 0 then

         for v_prns_id in
            select prns_id
            from StockItem
            where st_id = p_st_id
              and prns_id is not null
              and sti_ingreso > 0
         loop

            v_st_id_prns := null;

            select st_id
              into v_st_id_prns
            from ProductoNumeroSerie
            where prns_id = v_prns_id;

            -- si soy el ultimo movimiento de este numero de serie
            --
            if p_st_id = v_st_id_prns then

               -- obtengo el movimiento anterior a mi
               --
               select max(st_id)
                 into v_st_id_prns
               from StockItem
               where prns_id = v_prns_id
                 and st_id <> v_st_id_prns;

               -- obtengo el deposito del ultimo movimiento
               --
               select doct_id_cliente,
                      id_cliente,
                      depl_id_destino
                 into v_doct_id_cliente_prns,
                      v_id_cliente_prns,
                      v_depl_id_prns
               from Stock
               where st_id = v_st_id_prns;

               perform sp_doc_stock_update_numero_serie3(
                                                 v_prns_id,
                                                 v_st_id_prns,
                                                 v_doct_id_cliente_prns,
                                                 v_id_cliente_prns,
                                                 v_depl_id_prns);

            end if;

         end loop;

      -- sino esta borrando modificamos todos los numeros de serie
      -- cuyo st_id = @@st_id
      --
      else
         perform sp_doc_stock_update_numero_serie4(
                                       p_st_id,
                                       v_doct_id_cliente,
                                       v_id_cliente,
                                       v_depl_id);

      end if;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_stock_update_numero_serie(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_stock_update_numero_serie2()

-- drop function sp_doc_stock_update_numero_serie2(integer, integer, integer, integer, integer, integer);

create or replace function sp_doc_stock_update_numero_serie2
(
  in p_st_id integer,
  in v_doct_id_cliente integer,
  in v_id_cliente integer,
  in iv_cli_id integer,
  in iv_prov_id integer,
  in v_depl_id integer
)
  returns void as
$BODY$
declare  
   v_cli_id integer := iv_cli_id;
   v_prov_id integer := iv_prov_id;
begin

   -- ahora definimos a que proveedor y cliente pertenece
   -- TODO: aca todavia falta una vuelta de tuerca para estar seguro
   -- que no hay otro movimiento posterior que envie el numero de serie
   -- a un cliente, y este movimiento que ahora estamos borrando no
   -- tiene efecto sobre el numero de serie
   --
   /*
                    1	factura de venta
                    3	remito de venta
                    */
   -- cliente
   --
   if v_doct_id_cliente in ( 1,3 ) then

      select case v_doct_id_cliente
                when 1 then ( select cli_id
                              from FacturaVenta
                              where fv_id = v_id_cliente )
                when 3 then ( select cli_id
                              from RemitoVenta
                              where rv_id = v_id_cliente )
                else null
             end
        into v_cli_id;

      update ProductoNumeroSerie
         set depl_id = v_depl_id,
             cli_id = v_cli_id,
             doc_id_salida = v_id_cliente,
             doct_id_salida = v_doct_id_cliente,
             st_id = p_st_id
         where exists ( select StockItem.prns_id
                        from StockItem
                        where StockItem.st_id = p_st_id
                          and StockItem.prns_id = ProductoNumeroSerie.prns_id );

   else

      /*
          7	nota de credito venta
         24	devolucion remito venta
      */
      if v_doct_id_cliente in ( 7,24 ) then

         -- si ya no esta en el deposito de terceros entonces lo desvinculo de cualquier cliente
         --
         update ProductoNumeroSerie
            set depl_id = v_depl_id,
                cli_id = null,
                doc_id_salida = null,
                doct_id_salida = null,
                st_id = p_st_id
            where exists ( select StockItem.prns_id
                           from StockItem
                           where StockItem.st_id = p_st_id
                             and StockItem.prns_id = ProductoNumeroSerie.prns_id );

      -- proveedor
      --
      else

         /*
             2	 factura de compra
             4	 remito de compra
             42 orden de servicio
         */
         -- Nota: Si esta anulando el remito o la factura de compra, no me preocupo ya que
         --       en la anulacion y tambien al borrar el documento, se elimina del stock el
         --       numero de serie
         --
         if v_doct_id_cliente in ( 2,4,42 ) then

            if v_doct_id_cliente in ( 2,4 ) then

               select case v_doct_id_cliente
                         when 2 then ( select prov_id
                                       from FacturaCompra
                                       where fc_id = v_id_cliente )
                         when 4 then ( select prov_id
                                       from RemitoCompra
                                       where rc_id = v_id_cliente )
                      end
                 into v_prov_id
               from DUAL ;

               update ProductoNumeroSerie
                  set depl_id = v_depl_id,
                      prov_id = v_prov_id,
                      doc_id_ingreso = v_id_cliente,
                      doct_id_ingreso = v_doct_id_cliente,
                      st_id = p_st_id
               where exists ( select StockItem.prns_id
                              from StockItem
                              where StockItem.st_id = p_st_id
                                and StockItem.prns_id = ProductoNumeroSerie.prns_id );

            else

               select cli_id
                 into v_cli_id
               from OrdenServicio
               where os_id = v_id_cliente;

               update ProductoNumeroSerie
                  set depl_id = v_depl_id,
                      cli_id = v_cli_id,
                      doc_id_ingreso = v_id_cliente,
                      doct_id_ingreso = v_doct_id_cliente,
                      st_id = p_st_id
               where exists ( select StockItem.prns_id
                              from StockItem
                              where StockItem.st_id = p_st_id
                                and StockItem.prns_id = ProductoNumeroSerie.prns_id );

            end if;

         else

            /*
                8	 nota de credito de compra
                25 devolucion de remito de compra
            */
            if v_doct_id_cliente in ( 8,25 ) then

               update ProductoNumeroSerie
                  set depl_id = v_depl_id,
                      doc_id_salida = v_id_cliente,
                      doct_id_salida = v_doct_id_cliente,
                      st_id = p_st_id
               where exists ( select StockItem.prns_id
                              from StockItem
                              where StockItem.st_id = p_st_id
                                and StockItem.prns_id = ProductoNumeroSerie.prns_id );

            else

               /*
                   28	recuento de stock
                   30	parte de produccion
               */
               if v_doct_id_cliente in ( 28,30 ) then

                  if v_depl_id = -2 then

                     update ProductoNumeroSerie
                        set depl_id = v_depl_id,
                            doc_id_salida = v_id_cliente,
                            doct_id_salida = v_doct_id_cliente,
                            st_id = p_st_id
                     where exists ( select StockItem.prns_id
                                    from StockItem
                                    where StockItem.st_id = p_st_id
                                      and StockItem.prns_id = ProductoNumeroSerie.prns_id );

                  else

                     update ProductoNumeroSerie
                        set depl_id = v_depl_id,
                            doc_id_ingreso = v_id_cliente,
                            doct_id_ingreso = v_doct_id_cliente,
                            st_id = p_st_id
                     where exists ( select StockItem.prns_id
                                    from StockItem
                                    where StockItem.st_id = p_st_id
                                      and StockItem.prns_id = ProductoNumeroSerie.prns_id );

                  end if;

               -- cualquier otro documento (por ejemplo transferencia de stock)
               -- solo modifica el deposito
               --
               else

                  update ProductoNumeroSerie
                     set depl_id = v_depl_id,
                         st_id = p_st_id
                  where exists ( select StockItem.prns_id
                                 from StockItem
                                 where StockItem.st_id = p_st_id
                                   and StockItem.prns_id = ProductoNumeroSerie.prns_id );

               end if;

            end if;

         end if;

      end if;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_stock_update_numero_serie2(integer, integer, integer, integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_stock_update_numero_serie2()

-- drop function sp_doc_stock_update_numero_serie2(integer, integer, integer, integer, integer);

create or replace function sp_doc_stock_update_numero_serie3
(
  in v_prns_id integer,
  in p_st_id integer,
  in v_doct_id_cliente integer,
  in v_id_cliente integer,
  in v_depl_id integer
)
  returns void as
$BODY$
declare
   v_cli_id integer;
   v_prov_id integer;
begin

   if p_st_id is null then
      return;
   end if;

   -- ahora definimos a que proveedor y cliente pertenece
   -- TODO aca todavia falta una vuelta de tuerca para estar seguro
   -- que no hay otro movimiento posterior que envie el numero de serie
   -- a un cliente, y este movimiento que ahora estamos borrando no
   -- tiene efecto sobre el numero de serie
   --
   /*
       1	factura de venta
       3	remito de venta
   */
   -- cliente
   --
   if v_doct_id_cliente in ( 1,3 ) then

      select case v_doct_id_cliente
                when 1 then ( select cli_id
                              from FacturaVenta
                              where fv_id = v_id_cliente )
                when 3 then ( select cli_id
                              from RemitoVenta
                              where rv_id = v_id_cliente )
                else null
             end
        into v_cli_id;

      update ProductoNumeroSerie
         set depl_id = v_depl_id,
             cli_id = v_cli_id,
             doc_id_salida = v_id_cliente,
             doct_id_salida = v_doct_id_cliente,
             st_id = p_st_id
      where prns_id = v_prns_id;

   else

      /*
          7	nota de credito venta
         24	devolucion remito venta
      */
      if v_doct_id_cliente in ( 7,24 ) then

         -- si ya no esta en el deposito de terceros entonces lo desvinculo de cualquier cliente
         --
         update ProductoNumeroSerie
            set depl_id = v_depl_id,
                cli_id = null,
                doc_id_salida = null,
                doct_id_salida = null,
                st_id = p_st_id
         where prns_id = v_prns_id;

      -- proveedor
      --
      else

         /*
             2	factura de compra
             4	remito de compra
            42 orden de servicio
         */
         -- nota: si esta anulando el remito o la factura de compra, no me preocupo ya que
         --       en la anulacion y tambien al borrar el documento, se elimina del stock el
         --       numero de serie
         --
         if v_doct_id_cliente in ( 2,4,42 ) then

            if v_doct_id_cliente in ( 2,4 ) then

               select case v_doct_id_cliente
                         when 2 then ( select prov_id
                                       from FacturaCompra
                                       where fc_id = v_id_cliente )
                         when 4 then ( select prov_id
                                       from RemitoCompra
                                       where rc_id = v_id_cliente )
                      end
                 into v_prov_id;

               update ProductoNumeroSerie
                  set depl_id = v_depl_id,
                      prov_id = v_prov_id,
                      doc_id_ingreso = v_id_cliente,
                      doct_id_ingreso = v_doct_id_cliente,
                      st_id = p_st_id
               where prns_id = v_prns_id;

            else

               select cli_id
                 into v_cli_id
               from OrdenServicio
               where os_id = v_id_cliente;

               update ProductoNumeroSerie
                  set depl_id = v_depl_id,
                      cli_id = v_cli_id,
                      doc_id_ingreso = v_id_cliente,
                      doct_id_ingreso = v_doct_id_cliente,
                      st_id = p_st_id
               where prns_id = v_prns_id;

            end if;

         else
            /*
                8	 nota de credito de compra
                25 devolucion de remito de compra
            */
            if v_doct_id_cliente in ( 8,25 ) then

               update ProductoNumeroSerie
                  set depl_id = v_depl_id,
                      doc_id_salida = v_id_cliente,
                      doct_id_salida = v_doct_id_cliente,
                      st_id = p_st_id
               where prns_id = v_prns_id;

            else
               /*
                   28	recuento de stock
                   30	parte de produccion
               */
               if v_doct_id_cliente in ( 28,30 ) then

                  if v_depl_id = -2 then

                     update ProductoNumeroSerie
                        set depl_id = v_depl_id,
                            doc_id_salida = v_id_cliente,
                            doct_id_salida = v_doct_id_cliente,
                            st_id = p_st_id
                     where prns_id = v_prns_id;

                  else

                     update ProductoNumeroSerie
                        set depl_id = v_depl_id,
                            doc_id_ingreso = v_id_cliente,
                            doct_id_ingreso = v_doct_id_cliente,
                            st_id = p_st_id
                     where prns_id = v_prns_id;

                  end if;

               -- cualquier otro documento (por ejemplo transferencia de stock)
               -- solo modifica el deposito
               --
               else

                  update ProductoNumeroSerie
                     set depl_id = v_depl_id,
                         st_id = p_st_id
                  where prns_id = v_prns_id;

               end if;

            end if;

         end if;

      end if;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_stock_update_numero_serie3(integer, integer, integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_stock_update_numero_serie4()

-- drop function sp_doc_stock_update_numero_serie4(integer, integer, integer, integer);

create or replace function sp_doc_stock_update_numero_serie4
(
  in p_st_id integer,
  in v_doct_id_cliente integer,
  in v_id_cliente integer,
  in v_depl_id integer
)
  returns void as
$BODY$
declare
   v_cli_id integer;
   v_prov_id integer;
begin

   -- ahora definimos a que proveedor y cliente pertenece
   -- TODO aca todavia falta una vuelta de tuerca para estar seguro
   -- que no hay otro movimiento posterior que envie el numero de serie
   -- a un cliente, y este movimiento que ahora estamos borrando no
   -- tiene efecto sobre el numero de serie
   --
   /*
       1	factura de venta
       3	remito de venta
   */
   -- cliente
   --
   if v_doct_id_cliente in ( 1,3 ) then

      select case v_doct_id_cliente
                when 1 then ( select cli_id
                              from FacturaVenta
                              where fv_id = v_id_cliente )
                when 3 then ( select cli_id
                              from RemitoVenta
                              where rv_id = v_id_cliente )
                else null
             end
        into v_cli_id;

      update ProductoNumeroSerie
         set depl_id = v_depl_id,
             cli_id = v_cli_id,
             doc_id_salida = v_id_cliente,
             doct_id_salida = v_doct_id_cliente
      where st_id = p_st_id;

   else

      /*
           7	nota de credito venta
          24	devolucion remito venta
      */
      if v_doct_id_cliente in ( 7,24 ) then

         -- si ya no esta en el deposito de terceros entonces lo desvinculo de cualquier cliente
         --
         update ProductoNumeroSerie
            set depl_id = v_depl_id,
                cli_id = null,
                doc_id_salida = null,
                doct_id_salida = null
         where st_id = p_st_id;

      -- proveedor
      --
      else

         /*
               2	factura de compra
               4	remito de compra
              42 orden de servicio
         */
         -- Nota: si esta anulando el remito o la factura de compra, no me preocupo ya que
         --       en la anulacion y tambien al borrar el documento, se elimina del stock el
         --       numero de serie
         --
         if v_doct_id_cliente in ( 2,4,42 ) then

            if v_doct_id_cliente in ( 2,4 ) then

               select case v_doct_id_cliente
                         when 2 then ( select prov_id
                                       from FacturaCompra
                                       where fc_id = v_id_cliente )
                         when 4 then ( select prov_id
                                       from RemitoCompra
                                       where rc_id = v_id_cliente )
                      end
                 into v_prov_id;

               update ProductoNumeroSerie
                  set depl_id = v_depl_id,
                      prov_id = v_prov_id,
                      doc_id_ingreso = v_id_cliente,
                      doct_id_ingreso = v_doct_id_cliente
               where st_id = p_st_id;

            else

               select cli_id
                 into v_cli_id
               from OrdenServicio
               where os_id = v_id_cliente;

               update ProductoNumeroSerie
                  set depl_id = v_depl_id,
                      cli_id = v_cli_id,
                      doc_id_ingreso = v_id_cliente,
                      doct_id_ingreso = v_doct_id_cliente
               where st_id = p_st_id;

            end if;

         else

            /*
                 8	 nota de credito de compra
                 25 devolucion de remito de compra
            */
            if v_doct_id_cliente in ( 8,25 ) then

               update ProductoNumeroSerie
                  set depl_id = v_depl_id,
                      doc_id_salida = v_id_cliente,
                      doct_id_salida = v_doct_id_cliente
               where st_id = p_st_id;

            else

               /*
                    28	recuento de stock
                    30	parte de produccion
               */
               if v_doct_id_cliente in ( 28,30 ) then

                  if v_depl_id = -2 then

                     update ProductoNumeroSerie
                        set depl_id = v_depl_id,
                            doc_id_salida = v_id_cliente,
                            doct_id_salida = v_doct_id_cliente
                     where st_id = p_st_id;

                  else

                     update ProductoNumeroSerie
                        set depl_id = v_depl_id,
                            doc_id_ingreso = v_id_cliente,
                            doct_id_ingreso = v_doct_id_cliente
                     where st_id = p_st_id;

                  end if;

               -- cualquier otro documento (por ejemplo transferencia de stock)
               -- solo modifica el deposito
               --
               else

                  update ProductoNumeroSerie
                     set depl_id = v_depl_id
                  where st_id = p_st_id;

               end if;

            end if;

         end if;

      end if;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_stock_update_numero_serie4(integer, integer, integer, integer)
  owner to postgres;
  /*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_stock_producto_get_kit_info()

-- drop function sp_stock_producto_get_kit_info(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer);
/*
select * from sp_doc_factura_venta_get(1,1,1);
fetch all from rtn;
*/
create or replace function sp_stock_producto_get_kit_info
(
  in p_pr_id integer,
  in p_bCreateTable integer default 1,
  in p_bSoloStockXItem integer default 0,          -- La recursividad se detiene en aquellos kits que no controlan stock por item
  in p_bSetPrIdKit integer default 0,              -- Para aquellos items que tambien son kits les asigna el pr_id_kit
                                                   -- solo en el primer nivel es decir que deben producirse los kits que componen
                                                   -- a este kit
  in p_cantidad integer default 1,
  in p_bPPK integer default 0,                     -- Cuando estoy armando el kit, no quiero que me exija que los componentes
                                                   -- esten asociados al kit, por que en ese caso no puedo armar el kit
  in ip_prfk_id integer default 0,                 -- La formula a usar
  in p_bExpandKit integer default 0,               -- Cuando es cero, si el Kit es resumido, este sp no devuelve los items,
                                                   -- sino que solo devuelve el pr_id del kit, para simular un kit que esta
                                                   -- compuesto unicamente por un item, y de esta forma el kit sera manejado
                                                   -- por todo el resto del codigo como un producto mas.
                                                   --
                                                   -- Por ahora el unico que llama a este sp con @@bExpandKit <> 0 es el
                                                   -- parte de produccion para poder consumir los items del kit.
                                                   --
                                                   -- Esto SOLO se aplica a los kits que son RESUMIDOS
                                                   --
                                                   -- Ademas solo se aplica al primer nivel del Kit, es decir que si tenemos
                                                   -- el kit A compuesto por 10 componentes y uno de ellos es un kit (el B),
                                                   -- este sp devolvera solo 10 componentes, no desagrega los componentes del
                                                   -- Kit B
  in p_bExpandKitAllLevels integer default 0,      -- Expande al kit en todos sus niveles, es decir que recorre todos los items,
                                                   -- solo es llamado por ahora por dc_csc_stk_0180 y dc_csc_ven_0350
  in p_bGetFomulaFromTableAux integer default 0,   -- Esta tabla contiene hasta diez formulas de kits que deben ser utilizadas
                                                   -- para obtener la lista de insumos del kit
                                                   -- solo es llamado por ahora por dc_csc_prd_0020
  in p_bSetPrIdSubKit integer default 0,           -- identifica cada item con el subkit al que pertence
                                                   -- solo es llamado por ahora por dc_csc_prd_0020
  in p_bAddPrIdKitToTable integer default 0,       -- Agrega el pr_id del kit dentro de la tabla #KitItemsSerie

  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
        p_prfk_id integer := ip_prfk_id;

        v_bLlevaNroSerie smallint;  -- Si es un kit la cosa se pone mas complicada ya que hay que fijarse
                                    -- si las componentes del kit llevan stock y numero de serie

        v_Unidad varchar(255);
        v_nivel integer;
        v_prk_cantidad decimal(18,6);
        v_pr_id_item integer;
        v_pr_kitResumido smallint;
        v_bExpandKit smallint;      -- para poder incluirlo en el reporte de necesidad de compra
        v_cantidad_kit integer;
begin

   v_bExpandKit := p_bExpandKit;

   if p_bExpandKitAllLevels <> 0 then
      v_bExpandKit := 1;
   end if;

   if p_prfk_id is null then

      if p_bGetFomulaFromTableAux <> 0 then

         select t.prfk_id
           into p_prfk_id
         from tt_FormulasKit t
         join ProductoFormulaKit prfk
           on t.prfk_id = prfk.prfk_id
         where prfk.pr_id = p_pr_id;

      end if;

      if p_prfk_id is null then

         select prfk_id
           into p_prfk_id
         from ProductoFormulaKit
         where pr_id = p_pr_id
           and prfk_default <> 0;

      end if;

   end if;

   -- Solo se crea la tabla en la primera llamada
   if p_bCreateTable <> 0 then

         create temporary table tt_FormulasKit (prfk_id integer) on commit drop;

   end if;

   select pr_kitResumido
     into v_pr_kitResumido
   from Producto
   where pr_id = p_pr_id;

   if v_bExpandKit = 0 and v_pr_kitResumido <> 0 then

      insert into tt_KitItemsSerie ( pr_id, cantidad, prk_id ) values ( p_pr_id, 1, 0 );

   else

      -- Si solo quiere los componentes de kits que controlan stock por item, y este kit no controla stock por item,
      -- (son aquellos que debe ser fabricados previamente), solo agrego este producto y listo
      --
      if exists ( select pr_id
                  from Producto
                  where pr_id = p_pr_id
                    and pr_kitStkItem = 0
                    and p_bSoloStockXItem <> 0 ) then

         insert into tt_KitItemsSerie( pr_id, cantidad, prk_id ) values ( p_pr_id, p_cantidad, 0 );

      else


         -- Agrego los items de este kit
         select max(nivel)
           into v_nivel
         from tt_KitItems ;

         v_nivel := coalesce(v_nivel, 0) + 1;

         -- Agrego todos los items de este kit que son kit
         insert into tt_KitItems
           ( pr_id, nivel )
           ( select k.pr_id_item,
                    v_nivel
             from ProductoKit k
             join Producto p
               on k.pr_id_item = p.pr_id
             where k.prfk_id = p_prfk_id
               and p.pr_eskit <> 0 );

         -- Agrego todos los items de este Kit que no sean kit
         insert into tt_KitItemsSerie
           ( pr_id, cantidad, prk_id )
           ( select k.pr_id_item,
                    k.prk_cantidad * p_cantidad,
                    k.prk_id
             from ProductoKit k
             join Producto p
               on k.pr_id_item = p.pr_id
             where k.prfk_id = p_prfk_id
               and ( p.pr_eskit = 0 or ( p.pr_kitStkItem = 0 and p_bSoloStockXItem <> 0 )));

         -- Actualizo el pr_id_kit para definir a que kit pertenecen estos insumos
         --
         if p_bSetPrIdSubKit <> 0 then

            update tt_KitItemsSerie set pr_id_kit = p_pr_id where pr_id_kit is null;

         else

            if p_bSetPrIdKit <> 0 then

               update tt_KitItemsSerie set pr_id_kit = 0;-- Para diferenciarlos de los Items de Kits

            end if;

         end if;

         loop

            if not exists ( select *
                            from tt_KitItems
                            where nivel = v_nivel ) then
               exit;

            end if;

            select min(pr_id)
              into v_pr_id_item
            from tt_KitItems
            where nivel = v_nivel;

            -- Solo los que son kit
            if exists ( select *
                        from Producto
                        where pr_id = v_pr_id_item
                          and pr_eskit <> 0
                          and ( pr_kitStkItem <> 0 or p_bSoloStockXItem = 0 ) ) then

               select prk_cantidad
                 into v_prk_cantidad
               from ProductoKit
               where prfk_id = p_prfk_id
                 and pr_id_item = v_pr_id_item;

               v_prk_cantidad := v_prk_cantidad * p_cantidad;

               select sp_stock_producto_get_kit_info(
                            v_pr_id_item,--@@pr_id
                            0,--@@bCreateTable
                            p_bSoloStockXItem,
                            0,--@@bSetPrIdKit
                            v_prk_cantidad,
                            0,--@@bPPK
                            null,--@@prfk_id
                            0,--@@bExpandKit
                            p_bExpandKitAllLevels,
                            p_bGetFomulaFromTableAux,
                            p_bSetPrIdSubKit,
                            p_bAddPrIdKitToTable) into rtn;

            end if;

            -- Identifico a que kit pertenecen estos items
            -- Observen que cuando se utiliza @@bSetPrIdKit todos los insumos
            -- quedan asociados con al primer nivel de sub kits
            --
            if p_bSetPrIdKit <> 0 then

               update tt_KitItemsSerie
                  set pr_id_kit = v_pr_id_item
               where pr_id_kit is null;

            end if;

            -- Este ya lo procese asi que lo borro
            delete from tt_KitItems where pr_id = v_pr_id_item;

            if p_bAddPrIdKitToTable <> 0 then

               select prk_cantidad * p_cantidad
                 into v_cantidad_kit
               from ProductoKit k
               where k.prfk_id = p_prfk_id
                 and pr_id_item = v_pr_id_item;

               insert into tt_KitItemsSerie( pr_id, cantidad, prk_id, pr_id_kit, nivel )
                    values ( v_pr_id_item, v_cantidad_kit, 0, p_pr_id, v_nivel );

            end if;

         end loop;

         -- Pongo en null para que no se confunda el 0 con un id de producto y
         -- fallen otros sp que llaman a este y luego utilizan el pr_id_kit para
         -- insertarlo en alguna tabla, como es el caso de sp_DocParteProdKitSaveItemKit
         --
         if p_bSetPrIdKit <> 0 then

            update tt_KitItemsSerie
               set pr_id_kit = null
            where pr_id_kit = 0;

         end if;

      end if;

      -- Solo si no estoy produciendo el kit
      --
      if p_bSetPrIdKit <> 0 and p_bPPK = 0 and p_bSetPrIdSubKit = 0 then

         if exists ( select *
                     from Producto
                     where pr_id = p_pr_id
                       and pr_eskit <> 0
                       and pr_kitStkItem = 0 ) then

            update tt_KitItemsSerie set pr_id_kit = p_pr_id;

         end if;

      end if;

   end if;

   -- Solo la primera llamada devuelve datos
   if p_bCreateTable <> 0 then

      if p_bSetPrIdKit <> 0 then

         open rtn for
            select k.pr_id,
                   p.pr_nombrecompra,
                   p.pr_llevanroserie,
                   k.pr_id_kit,
                   sum(cantidad) cantidad
            from tt_KitItemsSerie k
            join Producto p
              on k.pr_id = p.pr_id
            group by k.pr_id,p.pr_nombrecompra,p.pr_llevanroserie,k.pr_id_kit;

      else

         open rtn for
            select k.pr_id,
                   p.pr_nombrecompra,
                   p.pr_llevanroserie,
                   sum(cantidad) cantidad
            from tt_KitItemsSerie k
            join Producto p
              on k.pr_id = p.pr_id
            group by k.pr_id,p.pr_nombrecompra,p.pr_llevanroserie;

      end if;

   end if;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_stock_producto_get_kit_info(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_op_mf_cheque_save()

/*
drop function sp_doc_op_mf_cheque_save(
  integer,
  varchar,
  decimal,
  decimal,
  date,
  date,
  varchar,
  integer,
  integer,
  integer,
  integer,
  integer,
  integer,
  integer,
  integer);
*/

create or replace function sp_doc_op_mf_cheque_save
(
  in p_tipo integer,
  in p_cheq_numerodoc varchar,
  in p_importe decimal(18,6),
  in p_importeOrigen decimal(18,6),
  in p_cheq_fechaCobro date,
  in p_cheq_fechaVto date,
  in p_descrip varchar,
  in p_chq_id integer,
  in p_opg_id integer,
  in ip_mf_id integer,
  in p_dbco_id integer,
  in p_cle_id integer,
  in p_mon_id integer,
  in p_prov_id integer,
  in ip_cue_id integer,
  out p_cheq_id integer
)
  returns integer as
$BODY$
declare
   p_cue_id integer := ip_cue_id;
   p_mf_id integer := ip_mf_id;
   v_opgit_cheques smallint := 1;
   v_opgit_chequesT smallint := 6;
   v_cheq_propio smallint := 1;
   v_bco_id integer;
   v_cheq_numero integer;
   v_emp_id integer;
   v_cheq_fecha2 date;
begin

   -- obtengo la empresa de este cheque
   --
   if coalesce(p_opg_id, 0) <> 0 then

      select doc.emp_id
        into v_emp_id
      from OrdenPago opg
      join Documento doc
        on opg.doc_id = doc.doc_id
      where opg.opg_id = p_opg_id;

   else

      if coalesce(p_mf_id, 0) <> 0 then

         select doc.emp_id
           into v_emp_id
         from MovimientoFondo mf
         join Documento doc
           on mf.doc_id = doc.doc_id
         where mf.mf_id = p_mf_id;

      else

         if coalesce(p_dbco_id, 0) <> 0 then

            select doc.emp_id
              into v_emp_id
            from DepositoBanco dbco
            join Documento doc
              on dbco.doc_id = doc.doc_id
            where dbco.dbco_id = p_dbco_id;

         end if;
      end if;
   end if;

   -- esto es aproposito, ya que los cheques propios que se utilizan para
   -- pagar a proveedores no estan asociados a ninguna cuenta contable
   --
   if exists ( select *
               from Cheque
               where cheq_id = p_cheq_id
                 and p_opg_id is not null ) then

      p_cue_id := null;

   else

      if exists ( select *
                  from Cheque
                  where cheq_id = p_cheq_id
                    and coalesce(mf_id, 0) > coalesce(p_mf_id, 0) ) then

         select cue_id,
                mf_id
           into p_cue_id,
                p_mf_id
         from Cheque
         where cheq_id = p_cheq_id;

      end if;

   end if;

   -- si este renglon es un cheque lo doy de alta en la tabla Cheque
   --
   if p_tipo = v_opgit_cheques or p_tipo = v_opgit_chequesT then

      -- obtengo el banco
      --
      select bco_id
        into v_bco_id
      from Cuenta
      join Chequera
        on Cuenta.cue_id = Chequera.cue_id
      where chq_id = p_chq_id;

      -- si es nuevo insert
      --
      if p_cheq_id is null then

         select sp_dbGetNewId('Cheque', 'cheq_id') into p_cheq_id;
         select sp_dbGetNewId('Cheque', 'cheq_numero') into v_cheq_numero;

         select sp_doc_get_fecha2(p_cheq_fechaCobro, 1, p_cle_id) into v_cheq_fecha2;

         insert into Cheque( cheq_id, cheq_numero, cheq_numerodoc, cheq_importe, cheq_importeOrigen, cheq_tipo,
                             cheq_fechaCobro, cheq_fechaVto, cheq_fecha2, cheq_descrip, chq_id, opg_id, mf_id, dbco_id,
                             cle_id, bco_id, cue_id, mon_id, prov_id, emp_id )
         values ( p_cheq_id, v_cheq_numero, p_cheq_numerodoc, p_importe, p_importeOrigen, v_cheq_propio,
                  p_cheq_fechaCobro, p_cheq_fechaVto, v_cheq_fecha2, p_descrip, p_chq_id, p_opg_id, p_mf_id, p_dbco_id,
                  p_cle_id, v_bco_id, p_cue_id, p_mon_id, p_prov_id, v_emp_id );

         perform sp_chequera_set(p_chq_id, p_cheq_numerodoc);

      else

         -- cheque de tercero ya que no tiene chequera
         --
         if p_chq_id is null then

            update Cheque
               set opg_id = coalesce(p_opg_id, opg_id),
                   mf_id = coalesce(p_mf_id, mf_id),
                   dbco_id = coalesce(p_dbco_id, dbco_id),
                   cue_id = p_cue_id,
                   prov_id = coalesce(p_prov_id, prov_id)
            where cheq_id = p_cheq_id;

         -- cheque propio
         --
         else

            select sp_doc_get_fecha2(p_cheq_fechaCobro, 1, p_cle_id) into v_cheq_fecha2;

            -- sino update
            --
            update Cheque
               set cheq_numerodoc = p_cheq_numerodoc,
                   cheq_importe = p_importe,
                   cheq_importeOrigen = p_importeOrigen,
                   cheq_tipo = v_cheq_propio,
                   cheq_fechaCobro = p_cheq_fechaCobro,
                   cheq_fechaVto = p_cheq_fechaVto,
                   cheq_fecha2 = v_cheq_fecha2,
                   cheq_descrip = p_descrip,
                   chq_id = p_chq_id,
                   opg_id = coalesce(p_opg_id, opg_id),
                   mf_id = coalesce(p_mf_id, mf_id),
                   dbco_id = coalesce(p_dbco_id, dbco_id),
                   cle_id = p_cle_id,
                   bco_id = v_bco_id,
                   cue_id = p_cue_id,
                   mon_id = p_mon_id,
                   prov_id = coalesce(p_prov_id, prov_id)
            where cheq_id = p_cheq_id;

         end if;

      end if;

   end if;

exception
   when others then

      raise exception '%. %.', sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_op_mf_cheque_save(
  integer,
  varchar,
  decimal,
  decimal,
  date,
  date,
  varchar,
  integer,
  integer,
  integer,
  integer,
  integer,
  integer,
  integer,
  integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_orden_pago_cheque_set_credito()

-- drop function sp_doc_orden_pago_cheque_set_credito(integer, integer);

create or replace function sp_doc_orden_pago_cheque_set_credito
(
  in p_opg_id integer,
  in p_borrar integer default 0
)
  returns void as
$BODY$
declare
   v_pendiente decimal(18,6);
   v_prov_id integer;
   v_emp_id integer;

   v_doct_ordenpagochq integer := 1016;

   v_old_prov_ids integer[];
   i integer;
begin

   -- Si no hay documento adios
   --
   if p_opg_id = 0 then
      return;
   end if;

   SET TRANSACTION READ WRITE;

   -- Datos del documento
   --
   select prov_id,
          emp_id
     into v_prov_id,
          v_emp_id
   from OrdenPago
   where opg_id = p_opg_id;


   -- Borrar referencias a este documento por otro proveedor
   --

   -- Siempre borro cualquier mencion a este documento en el cache de cualquier
   -- proveedor que no sea el indicado por el documento
   --
   if exists ( select prov_id
               from ProveedorCacheCredito
               where prov_id <> v_prov_id
                 and doct_id = v_doct_ordenpagochq
                 and id = p_opg_id ) then


        select into v_old_prov_ids prov_id
        from ProveedorCacheCredito
        where prov_id <> v_prov_id
         and doct_id = v_doct_ordenpagochq
         and id = p_opg_id;

        delete from ProveedorCacheCredito
        where prov_id <> v_prov_id
          and doct_id = v_doct_ordenpagochq
          and id = p_opg_id;

        for i in 1 .. array_upper(v_old_prov_ids, 1)
        loop

          perform sp_proveedor_update_credito(v_old_prov_ids[i], v_emp_id);

        end loop;

   end if;

   -- Borrar
   --
   if p_borrar <> 0 then

      delete from ProveedorCacheCredito
      where prov_id = v_prov_id
        and doct_id = v_doct_ordenpagochq
        and id = p_opg_id;

   else

      select sum(cheq_importe)
        into v_pendiente
      from Cheque
      where opg_id = p_opg_id
        and cheq_fechacobro > CURRENT_TIMESTAMP
        and cheq_anulado = 0
        and cheq_rechazado = 0;

      v_pendiente := sqlserver_utilities.round_(coalesce(v_pendiente, 0), 2);

      if exists ( select id
                  from ProveedorCacheCredito
                  where prov_id = v_prov_id
                    and doct_id = v_doct_ordenpagochq
                    and id = p_opg_id ) then

         if abs(v_pendiente) >= 0.01 then

            update ProveedorCacheCredito
               set provcc_importe = v_pendiente
            where prov_id = v_prov_id
              and doct_id = v_doct_ordenpagochq
              and id = p_opg_id;

         -- Si no hay nada pendiente lo saco del cache
         else

            delete from ProveedorCacheCredito
            where prov_id = v_prov_id
              and doct_id = v_doct_ordenpagochq
              and id = p_opg_id;

         end if;

      else

         -- Solo si hay algo pendiente
         if abs(v_pendiente) >= 0.01 then

            insert into ProveedorCacheCredito( prov_id, doct_id, id, provcc_importe, emp_id )
            values ( v_prov_id, v_doct_ordenpagochq, p_opg_id, v_pendiente, v_emp_id );

         end if;

      end if;

   end if;

   -- Actualizo la deuda en la tabla proveedor
   --
   perform sp_proveedor_update_credito(v_prov_id, v_emp_id);

   return;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_orden_pago_cheque_set_credito(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_orden_pago_set_credito()

-- drop function sp_doc_orden_pago_set_credito(integer, integer);

/*
          select * from ordenpago;
          select * from sp_doc_orden_pago_set_credito(3,1);
*/

create or replace function sp_doc_orden_pago_set_credito
(
  in p_opg_id integer,
  in p_borrar integer default 0
)
  returns void as
$BODY$
declare
   v_pendiente decimal(18,6);
   v_prov_id integer;
   v_emp_id integer;

   v_doct_orden_pago integer := 16;

   v_old_prov_ids integer[];
   i integer;
begin

   -- si no hay documento adios
   --
   if p_opg_id = 0 then
      return;
   end if;

   SET TRANSACTION READ WRITE;

   -- datos del documento
   --
   select round(opg_pendiente, 2),
          prov_id,
          emp_id
     into v_pendiente,
          v_prov_id,
          v_emp_id
   from OrdenPago opg
   where opg_id = p_opg_id;

   -- borrar referencias a este documento por otro proveedor
   --
   
   -- siempre borro cualquier mencion a este documento en el cache de cualquier
   -- proveedor que no sea el indicado por el documento
   --
   if exists ( select prov_id
               from ProveedorCacheCredito
               where prov_id <> v_prov_id
                 and doct_id = v_doct_orden_pago
                 and id = p_opg_id ) then

      select into v_old_prov_ids prov_id
      from ProveedorCacheCredito
      where prov_id <> v_prov_id
       and doct_id = v_doct_orden_pago
       and id = p_opg_id;

      delete from ProveedorCacheCredito
      where prov_id <> v_prov_id
        and doct_id = v_doct_orden_pago
        and id = p_opg_id;

      for i in 1 .. array_upper(v_old_prov_ids, 1)
      loop

          perform sp_proveedor_update_credito(v_old_prov_ids[i], v_emp_id);

      end loop;

   end if;

   -- borrar
   --
   if p_borrar <> 0 then

      delete from ProveedorCacheCredito
      where prov_id = v_prov_id
        and doct_id = v_doct_orden_pago
        and id = p_opg_id;

   -- insert - update
   --
   else

      if exists ( select id
                  from ProveedorCacheCredito
                  where prov_id = v_prov_id
                    and doct_id = v_doct_orden_pago
                    and id = p_opg_id ) then

         if abs(v_pendiente) >= 0.01 then

            update ProveedorCacheCredito
               set provcc_importe = v_pendiente
            where prov_id = v_prov_id
              and doct_id = v_doct_orden_pago
              and id = p_opg_id;

         -- si no hay nada pendiente lo saco del cache
         else

            delete from ProveedorCacheCredito
            where prov_id = v_prov_id
              and doct_id = v_doct_orden_pago
              and id = p_opg_id;

         end if;

      else
         -- solo si hay algo pendiente
         if abs(v_pendiente) >= 0.01 then

            insert into ProveedorCacheCredito ( prov_id, doct_id, id, provcc_importe, emp_id )
                                       values ( v_prov_id, v_doct_orden_pago, p_opg_id, v_pendiente, v_emp_id );

         end if;

      end if;

   end if;

   -- actualizo la deuda en la tabla Proveedor
   --
   perform sp_proveedor_update_credito(v_prov_id, v_emp_id);

exception
    when others then
        raise exception 'Ha ocurrido un error al actualizar el estado de la orden de pago. sp_doc_orden_pago_set_credito. %. %.',
                         sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_orden_pago_set_credito(integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_orden_pago_set_estado()

-- drop function sp_doc_orden_pago_set_estado(integer, integer);

/*
          select * from ordenpago;
          select * from sp_doc_orden_pago_set_estado(3,1);
*/

create or replace function sp_doc_orden_pago_set_estado
(
  in p_opg_id integer,
  out p_est_id integer
)
  returns integer as
$BODY$
declare
   v_est_id integer;
   v_prov_id integer;
   v_pendiente decimal(18,6);
   v_llevaFirma smallint;
   v_firmado smallint;
   v_doc_id integer;
   v_doc_llevafirma smallint;

   v_estado_pendiente integer := 1;
   v_estado_pendienteFirma integer := 4;
   v_estado_finalizado integer := 5;
   v_estado_anulado integer := 7;
begin

   if p_opg_id = 0 then
      return;
   end if;

   select prov_id,
          opg_firmado,
          est_id,
          round(opg_pendiente, 2),
          doc_id
     into v_prov_id,
          v_firmado,
          v_est_id,
          v_pendiente,
          v_doc_id
   from OrdenPago
   where opg_id = p_opg_id;

   select doc_llevafirma
     into v_doc_llevafirma
   from Documento
   where doc_id = v_doc_id;

   if v_est_id <> v_estado_anulado then

      -- si el documento requiere firma y el comprobante no esta firmado
      -- y no esta finalizado (puede ser que se finalizo y luego se modifico el documento
      -- para que requiera firma en cuyo caso no se exige firma para documentos finalizados)
      --
      if v_firmado = 0 and v_doc_llevafirma <> 0 and v_est_id <> v_estado_finalizado then

         v_est_id := v_estado_pendienteFirma;

      else

         -- si el comprobante no tiene pendiente se finaliza
         --
         if coalesce(v_pendiente, 0) <= 0 then

            v_est_id := v_estado_finalizado;

         else

            v_est_id := v_estado_pendiente;

         end if;

      end if;

      update OrdenPago
         set est_id = v_est_id
      where opg_id = p_opg_id;

   end if;

   p_est_id := v_est_id;

exception
   when others then

   raise exception 'Ha ocurrido un error al actualizar el estado de la orden de pago. sp_doc_orden_pago_set_estado. %. %.',
                   sqlstate, sqlerrm;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_orden_pago_set_credito(integer, integer)
  owner to postgres;
  /*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_venta_editable_get()

-- drop function sp_doc_factura_venta_editable_get(integer, integer, integer, integer, integer);

create or replace function sp_doc_factura_venta_editable_get
/*
          select * from sp_doc_factura_venta_editable_get(1,7,1)
*/
(
  in p_emp_id integer,
  in p_fv_id integer,
  in p_us_id integer,
  in p_no_anulado integer default 0,
  in p_delete integer default 0,
  out p_editable integer,
  out p_edit_msg varchar  
)
  returns record as
$BODY$
declare
   v_doc_id integer;
   v_fv_fecha date;
   v_estado integer;
   v_firmado integer;
   v_emp_id integer;
   v_emp_nombre varchar(255);
   v_impreso smallint;

   v_anulado integer := 7;
   v_csPreVtaEditFactura integer;
   v_csPreVtaDeleteFactura integer;

   v_pre_id integer;
   v_doc_nombre varchar(255);
   v_fca_id integer;

   v_fca_fechaDesde date;
   v_fca_fechaHasta date;

   v_doc_editarimpresos smallint;
begin

   v_anulado := 7;

   v_csPreVtaEditFactura := 16003;

   v_csPreVtaDeleteFactura := 16004;

   if p_fv_id <> 0 then

      select d.doc_id,
             d.emp_id,
             c.fv_fecha,
             c.est_id,
             c.impreso
        into v_doc_id,
             v_emp_id,
             v_fv_fecha,
             v_estado,
             v_impreso
      from FacturaVenta c
             join Documento d
               on c.doc_id = d.doc_id
      where c.fv_id = p_fv_id;

      if p_emp_id <> v_emp_id then

         select emp_nombre
           into v_emp_nombre
         from Empresa
         where emp_id = v_emp_id;

         p_editable := 0;

         if p_delete = 0 then
            p_edit_msg := 'El comprobante pertenece a la empresa ' || v_emp_nombre || ', para editarlo debe ingresar al sistema indicando dicha empresa.';
         else
            p_edit_msg := 'El comprobante pertenece a la empresa ' || v_emp_nombre || ', para borrarlo debe ingresar al sistema indicando dicha empresa.';
         end if;

         return;

      end if;

      if v_estado = v_anulado and p_no_anulado = 0 then

         p_editable := 0;
         p_edit_msg := 'El comprobante esta anulado';

         return;

      end if;

      if p_delete = 0 then
         v_pre_id := v_csPreVtaEditFactura;
      else
         v_pre_id := v_csPreVtaDeleteFactura;
      end if;

      -- Tiene permiso para editar facturas de venta
      --
      if not exists ( select per_id
                      from Permiso
                      where pre_id = v_pre_id
                        and ( ( us_id = p_us_id )
                             or exists ( select us_id
                                         from UsuarioRol
                                         where us_id = p_us_id
                                           and rol_id = Permiso.rol_id ))) then
         p_editable := 0;

         if p_delete = 0 then
            p_edit_msg := 'Usted no tiene permiso para editar facturas de venta';
         else
            p_edit_msg := 'Usted no tiene permiso para borrar facturas de venta';
         end if;

         return;

      end if;

      v_pre_id := null;

      select case
               when p_delete = 0 then pre_id_edit
               else pre_id_delete
             end,
             doc_nombre
        into v_pre_id,
             v_doc_nombre
      from Documento
      where doc_id = v_doc_id;

      if not exists ( select per_id
                      from Permiso
                      where pre_id = v_pre_id
                        and ( ( us_id = p_us_id )
                               or exists ( select us_id
                                           from UsuarioRol
                                           where us_id = p_us_id
                                             and rol_id = Permiso.rol_id ))) then
         p_editable := 0;

         if p_delete = 0 then
            p_edit_msg := 'Usted no tiene permiso para editar ' || v_doc_nombre;
         else
            p_edit_msg := 'Usted no tiene permiso para borrar ' || v_doc_nombre;
         end if;

         return;

      end if;

      -- Fechas de control de Acceso
      select fca_id
        into v_fca_id
      from Documento
      where doc_id = v_doc_id;

      if not v_fca_id is null then

         if not exists ( select fca_id
                         from FechaControlAcceso
                         where fca_id = v_fca_id
                           and v_fv_fecha between fca_fechaDesde and fca_fechaHasta ) then

            select fca_fechaDesde,
                   fca_fechaHasta
              into v_fca_fechaDesde,
                   v_fca_fechaHasta
            from FechaControlAcceso
            where fca_id = v_fca_id;

            p_editable := 0;

            p_edit_msg := 'La fecha del comprobante esta fuera del intervalo definido por las fechas de control de acceso (' 
                            || to_char(coalesce(v_fca_fechaDesde, ''), 'dd-mm-yyyy') 
                            || ' - ' 
                            || to_char(coalesce(v_fca_fechaHasta, ''), 'dd-mm-yyyy') 
                            || ')';

            return;

         end if;

      end if;

      if exists ( select fv_id
                  from FacturaVentaCobranza
                  where fv_id = p_fv_id ) then

         p_editable := 0;
         p_edit_msg := 'El comprobante esta vinculado a una cobranza';

         return;

      end if;


      if exists ( select fv_id_factura
                  from FacturaVentaNotaCredito
                  where fv_id_factura = p_fv_id
                     or fv_id_notacredito = p_fv_id ) then

         p_editable := 0;
         p_edit_msg := 'El comprobante esta vinculado a una factura o nota de credito';

         return;

      end if;

      if exists ( select fvi.fv_id
                  from RemitoFacturaVenta r
                  join FacturaVentaItem fvi
                    on r.fvi_id = fvi.fvi_id
                  where fvi.fv_id = p_fv_id ) then

         p_editable := 0;
         p_edit_msg := 'El comprobante esta vinculado a un remito';

         return;

      end if;


      if exists ( select fvi.fv_id
                  from PedidoFacturaVenta r
                  join FacturaVentaItem fvi
                    on r.fvi_id = fvi.fvi_id
                  where fvi.fv_id = p_fv_id ) then

         p_editable := 0;
         p_edit_msg := 'El comprobante esta vinculado a un pedido de venta';

         return;

      end if;

      if exists ( select fvi.fv_id
                  from PackingListFacturaVenta r
                  join FacturaVentaItem fvi
                    on r.fvi_id = fvi.fvi_id
                  where fvi.fv_id = p_fv_id ) then

         p_editable := 0;
         p_edit_msg := 'El comprobante esta vinculado a un packing list';

         return;

      end if;

      if v_impreso <> 0 and p_no_anulado = 0 then

         select doc_editarimpresos
           into v_doc_editarimpresos
         from Documento
         where doc_id = v_doc_id;

         if v_doc_editarimpresos = 0 then

            p_editable := 0;

            if p_delete = 0 then
               p_edit_msg := 'El comprobante esta impreso y la definición de su documento no permite la edición de comprobantes impresos.';
            else
               p_edit_msg := 'El comprobante esta impreso y la definición de su documento no permite eliminar comprobantes impresos.';
            end if;

            return;

         end if;

      end if;

   end if;

   p_editable := 1;
   p_edit_msg := '';

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_venta_editable_get(integer, integer, integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_venta_get()

-- drop function sp_doc_factura_venta_get(integer, integer, integer);
/*
select * from sp_doc_factura_venta_get(1,1,1);
fetch all from rtn;
*/
create or replace function sp_doc_factura_venta_get
(
  in p_emp_id integer,
  in p_fv_id integer,
  in p_us_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_editable integer;
   v_edit_msg varchar(255);
   v_doc_id integer;
   v_doct_id integer;
   v_ta_mascara varchar(100);
   v_ta_propuesto smallint;
   v_DeplNombre varchar(255);
   v_DeplId integer;
   v_DepfId integer;
   v_bIvari smallint;
   v_bIvarni smallint;
   v_cli_id integer;
begin

   rtn := 'rtn';

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                             TALONARIO Y ESTADO DE EDICION                                                          //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
   select cli_id,
          doc_id,
          doct_id
   into v_cli_id,
          v_doc_id,
          v_doct_id
   from FacturaVenta
   where fv_id = p_fv_id;

   select * from sp_talonario_get_propuesto(v_doc_id, v_cli_id, 0) into  v_ta_mascara, v_ta_propuesto;

   select * from sp_cliente_get_iva(v_cli_id) into v_bIvari, v_bIvarni;

   select * from sp_doc_factura_venta_editable_get(p_emp_id, p_fv_id, p_us_id) into v_editable, v_edit_msg;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                             DEPOSITO                                                                               //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
   /*Factura de Venta*/
   /*Nota de Debito Venta*/
   if v_doct_id = 1
     or v_doct_id = 9 then
   begin
      select dOrigen.depl_nombre,
             depl_id_origen,
             dOrigen.depf_id
      into v_DeplNombre,
           v_DeplId,
           v_DepfId
      from FacturaVenta
               join Stock
                on FacturaVenta.st_id = Stock.st_id
               left join DepositoLogico dOrigen
                on Stock.depl_id_origen = dOrigen.depl_id
      where fv_id = p_fv_id;

      v_DeplNombre := coalesce(v_DeplNombre, '');

      v_DeplId := coalesce(v_DeplId, 0);

      if v_DeplId = 0 then
      begin
         select dOrigen.depl_nombre,
                depl_id_origen,
                dOrigen.depf_id
           into v_DeplNombre,
                v_DeplId,
                v_DepfId
           from FacturaVenta
                  join RemitoVenta
                   on FacturaVenta.rv_id = RemitoVenta.rv_id
                  join Stock
                   on RemitoVenta.st_id = Stock.st_id
                  left join DepositoLogico dOrigen
                   on Stock.depl_id_origen = dOrigen.depl_id
            where fv_id = p_fv_id;

      end;
      end if;

   end;
   else
   begin
      /*Nota de Credito Venta*/
      if v_doct_id = 7 then
         select dDestino.depl_nombre,
                        depl_id_destino,
                        dDestino.depf_id
           into v_DeplNombre,
                v_DeplId,
                v_DepfId
           from FacturaVenta
                  join Stock
                   on FacturaVenta.st_id = Stock.st_id
                  left join DepositoLogico dDestino
                   on Stock.depl_id_destino = dDestino.depl_id
            where fv_id = p_fv_id;

      end if;

      v_DeplNombre := coalesce(v_DeplNombre, '');

      v_DeplId := coalesce(v_DeplId, 0);

      if v_DeplId = 0 then
      begin
         select dDestino.depl_nombre,
                depl_id_destino,
                dDestino.depf_id
           into v_DeplNombre,
                v_DeplId,
                v_DepfId
           from FacturaVenta
                  join RemitoVenta
                   on FacturaVenta.rv_id = RemitoVenta.rv_id
                  join Stock
                   on RemitoVenta.st_id = Stock.st_id
                  left join DepositoLogico dDestino
                   on Stock.depl_id_destino = dDestino.depl_id
            where fv_id = p_fv_id;

      end;
      end if;

   end;
   end if;

/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//                             select                                                                                 //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
   open rtn for

      select FacturaVenta.*,
             doct_nombre,
             mon_nombre,
             Documento.doc_fv_sinpercepcion,
             cli_nombre,
             lp_nombre,
             ld_nombre,
             cpg_nombre,
             est_nombre,
             ccos_nombre,
             suc_nombre,
             doc_nombre,
             ven_nombre,
             case
                  when lgj_titulo <> '' then lgj_titulo
                  else lgj_codigo
             end lgj_codigo,
             pOrigen.pro_nombre ProOrigen,
             pDestino.pro_nombre ProDestino,
             trans_nombre,
             clis_nombre,
             v_DeplId depl_id,
             v_DeplNombre depl_nombre,
             v_DepfId depf_id,
             v_bIvari bIvaRi,
             v_bIvarni bIvaRni,
             v_editable editable,
             v_edit_msg editMsg,
             v_ta_mascara ta_mascara,
             v_ta_propuesto ta_propuesto,
             doc_muevestock,
             doc_tipofactura
        from FacturaVenta
               join Documento
                on FacturaVenta.doc_id = Documento.doc_id
               join DocumentoTipo
                on FacturaVenta.doct_id = DocumentoTipo.doct_id
               join Moneda
                on FacturaVenta.mon_id = Moneda.mon_id
               join CondicionPago
                on FacturaVenta.cpg_id = CondicionPago.cpg_id
               join Estado
                on FacturaVenta.est_id = Estado.est_id
               join Sucursal
                on FacturaVenta.suc_id = Sucursal.suc_id
               join Cliente
                on FacturaVenta.cli_id = Cliente.cli_id
               left join CentroCosto
                on FacturaVenta.ccos_id = CentroCosto.ccos_id
               left join ListaPrecio
                on FacturaVenta.lp_id = ListaPrecio.lp_id
               left join ListaDescuento
                on FacturaVenta.ld_id = ListaDescuento.ld_id
               left join Vendedor
                on FacturaVenta.ven_id = Vendedor.ven_id
               left join Legajo
                on FacturaVenta.lgj_id = Legajo.lgj_id
               left join Provincia pOrigen
                on FacturaVenta.pro_id_origen = pOrigen.pro_id
               left join Provincia pDestino
                on FacturaVenta.pro_id_destino = pDestino.pro_id
               left join Transporte
                on FacturaVenta.trans_id = Transporte.trans_id
               left join ClienteSucursal
                on FacturaVenta.clis_id = ClienteSucursal.clis_id
         where fv_id = p_fv_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_venta_get(integer, integer, integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_venta_get_items()

-- drop function sp_doc_factura_venta_get_items(integer);
/*
select * from sp_doc_factura_venta_get_items(1);
fetch all from rtn;
fetch all from rtn_serie;
*/
create or replace function sp_doc_factura_venta_get_items
(
  in p_fv_id integer,
  out rtn refcursor,
  out rtn_serie refcursor,
  out rtn_kit refcursor
)
  returns record as
$BODY$
declare
   v_st_id integer;
   v_pr_id integer;
begin

   rtn := 'rtn';

   select st_id
     into v_st_id
   from FacturaVenta
   where fv_id = p_fv_id;

   open rtn for
      
      select fvi.*,
             pr_nombreventa,
             pr_llevanroserie,
             pr_llevanrolote,
             pr_lotefifo,
             pr_eskit,
             pr_porcinternov,
             tri.ti_porcentaje iva_ri_porcentaje,
             trni.ti_porcentaje iva_rni_porcentaje,
             tint.ti_porcentaje internos_porcentaje,
             ccos_nombre,
             un_nombre,
             to_nombre,
             stl_codigo,
             fvi_orden as orden
      from FacturaVentaItem fvi
      join Producto pr
       on fvi.pr_id = pr.pr_id
      join Unidad un
       on pr.un_id_venta = un.un_id
      join TipoOperacion tp
       on fvi.to_id = tp.to_id
      left join TasaImpositiva tri
       on pr.ti_id_ivariventa = tri.ti_id
      left join TasaImpositiva trni
       on pr.ti_id_ivarniventa = trni.ti_id
      left join TasaImpositiva tint
       on pr.ti_id_internosv = tint.ti_id
      left join CentroCosto ccos
       on fvi.ccos_id = ccos.ccos_id
      left join StockLote stl
       on fvi.stl_id = stl.stl_id
      where fv_id = p_fv_id
        and pr_eskit = 0
      
      union
      
      select fvi.*,
             pr_nombreventa,
             ( select min(stik_llevanroserie)
               from StockItemKit
               where pr_id = fvi.pr_id
                 and st_id = v_st_id ) pr_llevanroserie,
             pr_llevanrolote,
             pr_lotefifo,
             pr_eskit,
             pr_porcinternov,
             tri.ti_porcentaje iva_ri_porcentaje,
             trni.ti_porcentaje iva_rni_porcentaje,
             tint.ti_porcentaje internos_porcentaje,
             ccos_nombre,
             un_nombre,
             to_nombre,
             stl_codigo,
             fvi_orden as orden
      from FacturaVentaItem fvi
      join Producto pr
       on fvi.pr_id = pr.pr_id
      join Unidad un
       on pr.un_id_venta = un.un_id
      join TipoOperacion tp
       on fvi.to_id = tp.to_id
      left join TasaImpositiva tri
       on pr.ti_id_ivariventa = tri.ti_id
      left join TasaImpositiva trni
       on pr.ti_id_ivarniventa = trni.ti_id
      left join TasaImpositiva tint
       on pr.ti_id_internosv = tint.ti_id
      left join CentroCosto ccos
       on fvi.ccos_id = ccos.ccos_id
      left join StockLote stl
       on fvi.stl_id = stl.stl_id
      where fv_id = p_fv_id
        and pr_eskit <> 0
      order by orden;

 --///////////////////////////////////////////////////////////////////////////////////////////////////
 --
 --  NUMEROS DE SERIE
 --
 --///////////////////////////////////////////////////////////////////////////////////////////////////

   rtn_serie := 'rtn_serie';

   open rtn_serie for
   
      select prns.pr_id,
                     p.pr_nombrecompra,
                     prns.prns_id,
                     prns.prns_codigo,
                     prns.prns_descrip,
                     prns.prns_fechavto,
                     fvi.fvi_id
      from FacturaVentaItem fvi
      join FacturaVenta fv
        on fvi.fv_id = fv.fv_id
       and fvi.fv_id = p_fv_id
      join StockItem sti
        on sti.st_id = fv.st_id
       and sti.sti_grupo = fvi.fvi_id
      join ProductoNumeroSerie prns
        on prns.prns_id = sti.prns_id
      join Producto p
        on prns.pr_id = p.pr_id
      group by prns.prns_id,prns.pr_id,
               p.pr_nombrecompra,
               prns.prns_codigo,
               prns.prns_descrip,
               prns.prns_fechavto,fvi.fvi_id
      order by fvi.fvi_id;
      
   create temporary table tt_kit_item_serie
   (
    pr_id_kit_padre     integer,
    pr_id_kit           integer,
    cantidad            decimal(18,6) not null,
    cant_kits           integer default (0) not null,
    faltante            integer default (0) not null,
    pr_id               integer not null,
    prk_id              integer not null,
    costo               decimal(18,6) default (0) not null,
    costo_x_insumos     decimal(18,6) default (0) not null,
    col_order           integer default (3) not null,
    nivel               smallint default (0) not null
   ) on commit drop;

   for v_pr_id in select pr_id from StockItemKit where st_id = v_st_id
   loop

         perform sp_stock_producto_get_kit_info(v_pr_id, 0);

         update tt_kit_item_serie
            set pr_id_kit = v_pr_id
         where pr_id_kit is null;

   end loop;

   open rtn_kit for
   
      select k.pr_id_kit pr_id,
             k.pr_id pr_id_item,
             p.pr_nombrecompra,
             p.pr_llevanroserie,
             cantidad
      from tt_kit_item_serie k
      join Producto p
        on k.pr_id = p.pr_id;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_venta_get_items(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_doc_factura_venta_get_percepciones()

-- drop function sp_doc_factura_venta_get_percepciones(integer);
/*
select * from sp_doc_factura_venta_get_percepciones(1);
fetch all from rtn;
fetch all from rtn_serie;
*/
create or replace function sp_doc_factura_venta_get_percepciones
/*
sp_DocFacCpraGetPercepcionesones 1
*/
(
  in p_fv_id integer,
  out rtn refcursor
)
  returns refcursor as
$BODY$
begin

   rtn := 'rtn';

   open rtn for
      select FacturaVentaPercepcion.*,
             perc_nombre,
             ccos.ccos_nombre
      from FacturaVentaPercepcion
      join Percepcion
        on FacturaVentaPercepcion.perc_id = Percepcion.perc_id
      left join CentroCosto ccos
        on FacturaVentaPercepcion.ccos_id = ccos.ccos_id
      where fv_id = p_fv_id
      order by fvperc_orden;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_doc_factura_venta_get_percepciones(integer)
  owner to postgres;/*
CrowSoft-Cairo
==============

ERP application written in Scala Play Framework and Postgresql

Copyright (C) 2012  Javier Mariano Alvarez

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

========================================================================

Created by Javier

http://www.crowsoft.com.ar

javier at crowsoft.com.ar
*/
-- Function: sp_lsdoc_facturas_venta()

-- drop function sp_lsdoc_facturas_venta(integer, date, date, varchar, varchar, varchar, varchar, varchar, varchar, varchar);

create or replace function sp_lsdoc_facturas_venta
(
  in p_us_id integer,
  in p_Fini date,
  in p_Ffin date,
  in p_cli_id varchar,
  in p_est_id varchar,
  in p_ccos_id varchar,
  in p_suc_id varchar,
  in p_ven_id varchar,
  in p_doc_id varchar,
  in p_cpg_id varchar,
  in p_emp_id varchar,
  out rtn refcursor
)
  returns refcursor as
$BODY$
declare
   v_cli_id integer;
   v_ccos_id integer;
   v_suc_id integer;
   v_est_id integer;
   v_ven_id integer;
   v_doc_id integer;
   v_cpg_id integer;
   v_emp_id integer;
   v_ram_id_Cliente integer;
   v_ram_id_CentroCosto integer;
   v_ram_id_Sucursal integer;
   v_ram_id_Estado integer;
   v_ram_id_Vendedor integer;
   v_ram_id_Documento integer;
   v_ram_id_CondicionPago integer;
   v_ram_id_Empresa integer;
   v_clienteID integer;
   v_IsRaiz smallint;
begin

   rtn := 'rtn';
   
   /*- ///////////////////////////////////////////////////////////////////////
    INICIO PRIMERA PARTE DE ARBOLES
   /////////////////////////////////////////////////////////////////////// */
      
   select * from sp_ArbConvertId(p_cli_id) into v_cli_id, v_ram_id_Cliente;

   select * from sp_ArbConvertId(p_ccos_id) into v_ccos_id, v_ram_id_CentroCosto;

   select * from sp_ArbConvertId(p_suc_id) into v_suc_id, v_ram_id_Sucursal;

   select * from sp_ArbConvertId(p_est_id) into v_est_id, v_ram_id_Estado;

   select * from sp_ArbConvertId(p_ven_id) into v_ven_id, v_ram_id_Vendedor;

   select * from sp_ArbConvertId(p_doc_id) into v_doc_id, v_ram_id_Documento;

   select * from sp_ArbConvertId(p_cpg_id) into v_cpg_id, v_ram_id_CondicionPago;

   select * from sp_ArbConvertId(p_emp_id) into v_emp_id, v_ram_id_Empresa;

   select * from  sp_GetRptId() into v_clienteID;

   if v_ram_id_Cliente <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Cliente, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Cliente) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Cliente,
                           v_clienteID);

      end;
      else
         v_ram_id_Cliente := 0;

      end if;

   end;
   end if;

   if v_ram_id_CentroCosto <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_CentroCosto, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_CentroCosto) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_CentroCosto,
                           v_clienteID);

      end;
      else
         v_ram_id_CentroCosto := 0;

      end if;

   end;
   end if;

   if v_ram_id_Estado <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Estado, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Estado) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Estado,
                           v_clienteID);

      end;
      else
         v_ram_id_Estado := 0;

      end if;

   end;
   end if;

   if v_ram_id_Sucursal <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Sucursal, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Sucursal) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Sucursal,
                           v_clienteID);

      end;
      else
         v_ram_id_Sucursal := 0;

      end if;

   end;
   end if;

   if v_ram_id_Vendedor <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Vendedor, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Vendedor) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Vendedor,
                           v_clienteID);

      end;
      else
         v_ram_id_Vendedor := 0;

      end if;

   end;
   end if;

   if v_ram_id_Documento <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Documento, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Documento) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Documento,
                           v_clienteID);

      end;
      else
         v_ram_id_Documento := 0;

      end if;

   end;
   end if;

   if v_ram_id_CondicionPago <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_CondicionPago, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_CondicionPago) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_CondicionPago,
                           v_clienteID);

      end;
      else
         v_ram_id_CondicionPago := 0;

      end if;

   end;
   end if;

   if v_ram_id_Empresa <> 0 then
   begin
      --	exec sp_ArbGetGroups @ram_id_Empresa, @clienteID, @@us_id
      select sp_ArbIsRaiz(v_ram_id_Empresa) into v_IsRaiz;

      if v_IsRaiz = 0 then
      begin
         perform sp_ArbGetAllHojas(v_ram_id_Empresa,
                           v_clienteID);

      end;
      else
         v_ram_id_Empresa := 0;

      end if;

   end;
   end if;

   /*- ///////////////////////////////////////////////////////////////////////
   FIN PRIMERA PARTE DE ARBOLES
   /////////////////////////////////////////////////////////////////////// */

   open rtn for
   
      select fv_id,
             '' TypeTask,
             fv_numero Numero,
             fv_nrodoc Comprobante,
             cli_nombre Cliente,
             doc_nombre Documento,
             est_nombre Estado,
             fv_fecha Fecha,
             fv_fechaentrega Fecha_de_entrega,
             fv_neto Neto,
             fv_ivari IVA_RI,
             fv_ivarni IVA_RNI,
             fv_subtotal Subtotal,
             fv_total Total,
             fv_pendiente Pendiente,
             case fv_firmado
                when 0 then 'No'
                else 'Si'
             end Firmado,
             case impreso
                when 0 then 'No'
                else 'Si'
             end Impreso,
             fv_descuento1 Desc_1,
             fv_descuento2 Desc_2,
             fv_importedesc1 Desc_1,
             fv_importedesc2 Desc_2,
             lp_nombre Lista_de_Precios,
             ld_nombre Lista_de_descuentos,
             cpg_nombre Condicion_de_Pago,
             ccos_nombre Centro_de_costo,
             suc_nombre Sucursal,
             emp_nombre Empresa,
             FacturaVenta.creado,
             FacturaVenta.modificado,
             us_nombre Modifico,
             fv_descrip Observaciones
        from FacturaVenta
        join Documento
          on FacturaVenta.doc_id = Documento.doc_id
        join Empresa
          on Documento.emp_id = Empresa.emp_id
        join CondicionPago
          on FacturaVenta.cpg_id = CondicionPago.cpg_id
        join Estado
          on FacturaVenta.est_id = Estado.est_id
        join Sucursal
          on FacturaVenta.suc_id = Sucursal.suc_id
        join Cliente
          on FacturaVenta.cli_id = Cliente.cli_id
        join Usuario
          on FacturaVenta.modifico = Usuario.us_id
        left join Vendedor
          on FacturaVenta.ven_id = Vendedor.ven_id
        left join CentroCosto
          on FacturaVenta.ccos_id = CentroCosto.ccos_id
        left join ListaPrecio
          on FacturaVenta.lp_id = ListaPrecio.lp_id
        left join ListaDescuento
          on FacturaVenta.ld_id = ListaDescuento.ld_id
        where p_Fini <= fv_fecha
          and p_Ffin >= fv_fecha

        /* -///////////////////////////////////////////////////////////////////////
        INICIO SEGUNDA PARTE DE ARBOLES
        /////////////////////////////////////////////////////////////////////// */

          and ( Cliente.cli_id = v_cli_id
          or v_cli_id = 0 )
          and ( Estado.est_id = v_est_id
          or v_est_id = 0 )
          and ( Sucursal.suc_id = v_suc_id
          or v_suc_id = 0 )
          and ( Documento.doc_id = v_doc_id
          or v_doc_id = 0 )
          and ( CondicionPago.cpg_id = v_cpg_id
          or v_cpg_id = 0 )
          and ( CentroCosto.ccos_id = v_ccos_id
          or v_ccos_id = 0 )
          and ( Vendedor.ven_id = v_ven_id
          or v_ven_id = 0 )
          and ( Empresa.emp_id = v_emp_id
          or v_emp_id = 0 )
          -- Arboles
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 28
                                      and rptarb_hojaid = Cliente.cli_id ) )
          or ( v_ram_id_Cliente = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 21
                                      and rptarb_hojaid = CentroCosto.ccos_id ) )
          or ( v_ram_id_CentroCosto = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 4005
                                      and rptarb_hojaid = Estado.est_id ) )
          or ( v_ram_id_Estado = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 1007
                                      and rptarb_hojaid = Sucursal.suc_id ) )
          or ( v_ram_id_Sucursal = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 15
                                      and rptarb_hojaid = Vendedor.ven_id ) )
          or ( v_ram_id_Vendedor = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 4001
                                      and rptarb_hojaid = Documento.doc_id ) )
          or ( v_ram_id_Documento = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 1005
                                      and rptarb_hojaid = CondicionPago.cpg_id ) )
          or ( v_ram_id_CondicionPago = 0 ) )
          and ( ( exists ( select rptarb_hojaid
                           from rptArbolRamaHoja
                              where rptarb_cliente = v_clienteID
                                      and tbl_id = 1018
                                      and rptarb_hojaid = Empresa.emp_id ) )
          or ( v_ram_id_Empresa = 0 ) )
        
        order by fv_fecha, Comprobante;

end;
$BODY$
  language plpgsql volatile
  cost 100;
alter function sp_lsdoc_facturas_venta(integer, date, date, varchar, varchar, varchar, varchar, varchar, varchar, varchar, varchar)
  owner to postgres;